<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>(Significantly More, but Honestly Never Enough) Comprehensive Notes on C&#43;&#43; - Allen&#39;s Whiteboard</title>
    <meta property="og:title" content="(Significantly More, but Honestly Never Enough) Comprehensive Notes on C&#43;&#43; - Allen&#39;s Whiteboard">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="The following notes are based on tutorials on LearnCpp.com. I take zero credit on any of the following contents except summarizing stuff here and there to fit them into one single post (barely). If &amp;hellip;">
      <meta property="og:description" content="The following notes are based on tutorials on LearnCpp.com. I take zero credit on any of the following contents except summarizing stuff here and there to fit them into one single post (barely). If &amp;hellip;">
      
    

    
    
    
    <meta name="twitter:image" content="https://allenfrostline.com/logo.png">
    
    

    

    
    




    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
<script src="/js/math-code.js"></script>


<script>
  (function (u, c) {
    var d = document, t = 'script', o = d.createElement(t), s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(e); }); }
    s.parentNode.insertBefore(o, s);
  })('//cdn.jsdelivr.net/npm/pangu@4.0.5/dist/browser/pangu.min.js', function () {
    pangu.spacingPage();
  });
</script>



<script async src="/js/center-img.js"></script>


<script>
    window.minimalAnalytics = {
        trackingId: 'G-B4WMGBPB4Z',
        autoTrack: true, 
    };
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-B4WMGBPB4Z"></script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B4WMGBPB4Z');
</script>


<script src="/index_1423847519945263698.js" async></script>


  </head>

  
  <body class="blog">
    <header class="masthead">
      

<h1><a href="/"><img src="/logo.png" alt="allenfrostline" /></a></h1>



      <nav class="menu">
  <ul>
  
  
  <li><a href="/blog/">Blog</a></li>
  
  <li><a href="/pottery/">Pottery</a></li>
  
  <li><a href="/recipe/">Recipe</a></li>
  
  <li><a href="/kotoba">Kotoba</a></li>
  
  <li><a href="/vitae/">Vitae</a></li>
  
  













  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
    <h1>(Significantly More, but Honestly Never Enough) Comprehensive Notes on C&#43;&#43;</h1>
    

    <hr style="margin-top:-1em">

    <h3 style="margin-top:-2.3em">
    
        

        
            2024-05-14
        
    
    </h3>



      </header>



<p>The following notes are based on tutorials on <a href="https://www.learncpp.com" target="_blank">LearnCpp.com</a>. I take zero credit on any of the following contents except summarizing stuff here and there to fit them into one single post (barely). If you find it useful, please feel free to express your gratitude toward Alex and other authors of the original tutorial website.</p>
<h1 id="introduction--getting-started">Introduction / Getting Started</h1>
<p>OK. This is a tediously long post but let&rsquo;s start from the very basics.</p>
<h2 id="introduction-to-programming-languages">Introduction to programming languages</h2>
<p>A computer program is a set of instructions that the computer can perform. There are different levels of programming languages that a computer can run:</p>
<ul>
<li>Machine language: The limited set of instructions that a CPU can understand directly is called <strong>machine code</strong> (or <strong>machine language</strong>, or <strong>instruction set</strong>), which is composed of a sequence of <strong>binary digits</strong> (aka <strong>bits</strong>). Machine codes are usually not <strong>portable</strong>, namely, you have to rewrite them for every different system.</li>
<li>Assembly language: To make machine language more readable, assembly language was invented with short abbreviations of instructions, and numbers are supported now. However, assembly language is still likely not <strong>portable</strong>.  In order for CPU to understand the assembly language, the program must be translated to machine language by using an <strong>assembler</strong>.</li>
<li>High-level language: To address the problem that programs are not generally portable across systems, there we have high-level programming languages, which must still be translated into a format the computer can understand. There are two ways in general:
<ul>
<li>Through a <strong>compiler</strong>, which is a program that reads source code and produces a standalone executable program that can then be run. Compilers can produce very fast and optimized code, sometimes faster than assembly language human writes. Another benefit of compiled programs is that distributing a compiled program does not require distributing the source code. In an non-open-source environment, this is important for IP protection purposes.</li>
<li>Through an <strong>interpreter</strong>, which is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. Interpreters tend to be more flexible than compilers, but are less efficient when running programs because the interpreting process needs to be done every time the program is run. This also means the interpreter is needed every time the program is run.</li>
</ul>
</li>
</ul>
<h2 id="introduction-to-cc">Introduction to C/C++</h2>
<p>The C language was developed in 1972 by Dennis Ritchie at Bell Lab. C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrite most of the Unix operating systems using C. In 1978, Brian Kernighan and Dennis Ritchie published the book <em>The C Programming Language</em> (later known as K&amp;R) which provided an informal standard. In 1983, the American National Standards Institute (ANSI) formed a committee to establish a formal standard for C. They finished in 1989 with the C89 standard. In 1990, the International Organization for Standardization (ISO) adopted C89 and published C90, and later in 1999 the C99 standard.</p>
<p>C++ was developed by Bjarne Stroustrup at Bell Lab as an extension to C since 1979. C++ is mostly considered as a superset of C, but this is not strictly true as C99 introduced a few features that do not exist in C++. C++ was standardized in 1998 by the ISO and got a minor update in 2003, thereafter called C++03. Five major updates to the C++ language (C++11, C++14, C++17, C++20 and C++23) have been made since then, each adding new functionalities. C++11 in particular added a huge number of new capabilities and is widely considered to be the new baseline version of the language.</p>
<p>The underlying design philosophy of C/C++ can be summed up as &ldquo;trust the programmer&rdquo;, which is both wonderful and dangerous.</p>
<h2 id="compiler-linker-and-libraries">Compiler, linker and libraries</h2>
<script src="/js/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        theme: 'forest',
    });
</script>
<div class="mermaid">
    
flowchart LR
    A[Write C++ Program] --> B
    B[Compile the Program] --> C
    C[Link object files] --> D
    D[Test program] -->|debug|B

</div>

<p>The compiler translates <code>*.cpp</code> to corresponding <code>*.o</code> object files. The linker combines all <code>*.o</code> object files, together with C++ Standard Library and other libraries, and then generates an executable file e.g. <code>something.exe</code> on Windows. This whole process is usually referred to as <strong>building</strong>. The specific executable produced as the result of building is sometimes called a <strong>build</strong>.</p>
<p>By combining softwares (editor, compiler, linker, debugger) involved in above steps into one, we have an integrated development environment (IDE).</p>
<h1 id="c-basics">C++ Basics</h1>
<h2 id="preprocessor-directive">Preprocessor directive</h2>
<p>The <strong>preprocessor directives</strong> are the include lines on top of source files e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span></code></pre></div><p>which here indicates that we would like to use the contents of the <code>iostream</code> library (which is the part of the C++ standard library that allows us to read and write text from/to the console).</p>
<h2 id="statements">Statements</h2>
<p>A computer program is a sequence of instructions that tell the computer what to do. A <strong>statement</strong> is a type of instruction that causes the program to perform some action. Most (but not all) statements in C++ end in a semicolon. There are many different kinds of statements in C++:</p>
<ul>
<li>Declaration statements</li>
<li>Jump statements</li>
<li>Expression statements</li>
<li>Compound statements</li>
<li>Selection statements (conditionals)</li>
<li>Iteration statements (loops)</li>
<li>Try blocks</li>
</ul>
<h2 id="functions-and-the-main-function">Functions and the <code>main</code> function</h2>
<p>A <strong>function</strong> is a collection of statements that get executed sequentially (in order, from top to bottom). The name of a function is called its <strong>identifier</strong>.</p>
<p>Every C++ program must have a <code>main</code> function.</p>
<h2 id="comments">Comments</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello world!&#34;</span><span style="font-weight:bold">&gt;</span>;  <span style="color:#998;font-style:italic">// this is a single-line comment
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#998;font-style:italic">/* this is a multi-line
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">   comment in C++ */</span>
</span></span></code></pre></div><h2 id="data-values-objects-and-variables">Data, values, objects and variables</h2>
<p><strong>Data</strong> on a computer is typically stored in a format that is efficient for storage or processing (and is thus not human readable). A single piece of data is called a <strong>value</strong>. An <strong>object</strong> in C++ is a region of storage on RAM that can store a value, and has other associated properties. Although objects in C++ can be unnamed (anonymous), more often we name our objects using an identifier. An object with a name is called a <strong>variable</strong>.</p>
<h2 id="variable-instantiation">Variable instantiation</h2>
<p>We use a special kind of declaration statement called a <strong>definition</strong> to create a variable, e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x;
</span></span></code></pre></div><p>At <strong>compile-time</strong>, when the compiler sees this statement, it makes a note to itself that we are defining a variable named <code>x</code> of type <code>int</code>. Moving forward, whenever the compiler sees <code>x</code>, it knows that we&rsquo;re referencing this variable. In C++, the type of a variable must be known at compile-time and cannot be changed without recompiling the whole program.</p>
<p>At <strong>runtime</strong>, the variable will be instantiated, which means the object will be created and assigned a memory address.</p>
<p>You can define multiple variables in either ways below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> b;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// or
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> a, b;
</span></span></code></pre></div><h2 id="variable-initialization">Variable Initialization</h2>
<p>There are 6 basic ways to initialize a variable in C++:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a;       <span style="color:#998;font-style:italic">// default initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> b <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;   <span style="color:#998;font-style:italic">// copy initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">c</span>(<span style="color:#099">6</span>);    <span style="color:#998;font-style:italic">// direct initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> d {<span style="color:#099">7</span>};   <span style="color:#998;font-style:italic">// direct list initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> e <span style="font-weight:bold">=</span> {<span style="color:#099">8</span>}; <span style="color:#998;font-style:italic">// copy list initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> f {};    <span style="color:#998;font-style:italic">// empty list / value initialization
</span></span></span></code></pre></div><p>The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces. Informally, this is called <strong>list initialization</strong> (or <strong>uniform initialization</strong> or <strong>brace initialization</strong>). List initialization has an added benefit besides providing a uniform interface (for both atomic and a list of values): it disallows <strong>narrowing conversions</strong>. This means that is you try to brace initialize a variable using a value that the variable can not safely hold, the compiler will produce an error instead of a warning or even worse, silently taking the valid part of the input:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> width <span style="font-weight:bold">=</span> <span style="color:#099">4.5</span>;   <span style="color:#998;font-style:italic">// warning: implicit conversion from &#39;double&#39; to &#39;int&#39; changes value from 4.5 to 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> width { <span style="color:#099">4.5</span> }; <span style="color:#998;font-style:italic">// error: a number with a fractional value can&#39;t fit into an int
</span></span></span></code></pre></div><p>You can initialize multiple variables in the following ways (except the last one):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="font-weight:bold">=</span> <span style="color:#099">5</span>, b <span style="font-weight:bold">=</span> <span style="color:#099">6</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">a</span>(<span style="color:#099">5</span>), b(<span style="color:#099">6</span>);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a{<span style="color:#099">5</span>}, b{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="font-weight:bold">=</span> {<span style="color:#099">5</span>}, b <span style="font-weight:bold">=</span> {<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a {}, b {};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a, b(<span style="color:#099">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a, b{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a, b <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;  <span style="color:#998;font-style:italic">// error: a is not initialized!
</span></span></span></code></pre></div><h2 id="unused-initialized-variables-warning">Unused initialized variables warning</h2>
<p>C++ will generate a warning is a variable is initialized but not used. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When compiling the program above, the following warning is generated</p>
<pre tabindex="0"><code>main.cpp:2:9: warning: unused variable &#39;x&#39; [-Wunused-variable]
    int x { 5 };
        ^
1 warning generated.
</code></pre><p>There are a few ways to fix this. First, if the variable is really unused, we can just remove its definition from the program. Second, we can use it somewhere e.g. <code>cout &lt;&lt; x</code>. When neither are desirable solutions, in C++17 we have introduced a new <code>[[maybe_unused]]</code> attribute, which allows us to tell the compiler that we&rsquo;re okay with these variables being unused.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#008080">[[maybe_unused]]</span> <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="introduction-to-iostream-cout-cin-and-endl">Introduction to <code>iostream</code>: <code>cout</code>, <code>cin</code> and <code>endl</code></h2>
<p>We need to include <code>iostream</code> library so that we have access to <code>std::cout</code> etc. We can use <code>std::cout</code> with an <strong>insertion operator <code>&lt;&lt;</code></strong> to send the string to the console to be printed. Similarly, we can print a newline whenever a line of output is complete by using <code>std::endl</code>.</p>
<p>It&rsquo;s good to know that <code>std::cout</code> is buffered, meaning that the slow transferring of a batch of data to an output device is optimized with a potential risk of not printing everything if the program crashes, aborts or is paused (e.g. for debugging) halfway before the buffer is flushed. Also, for the same underlying reason, using <code>\n</code> instead of <code>std::endl</code> is actually preferred for better performance, as the cursor is moved to the next line of console without flushing the buffer.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;x is good&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>endl; <span style="color:#998;font-style:italic">// this is slower than below
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;y is better</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;          <span style="color:#998;font-style:italic">// no flushing, just newline
</span></span></span></code></pre></div><p>Whereas <code>std::cout</code> uses an insertion operator <code>&lt;&lt;</code>, <code>std::cin</code> reads the input using an <strong>extraction operator <code>&gt;&gt;</code></strong>. The input must be stored in a variable to be used later.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> x;
</span></span></code></pre></div><p>It&rsquo;s (also) good to know that the C++ I/O library does not provide a way to capture keyboard input without the user pressing <em>ENTER</em>. In order to do that, one might need to resort to third-party libraries e.g. <code>pdcurses</code>, <code>FXTUI</code>, <code>cpp-terminal</code> or <code>notcurses</code>.</p>
<p>Let&rsquo;s take a look at the following program</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter a number: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> x;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;You entered &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What happens when we enter</p>
<ul>
<li>
<p><code>123</code>: <code>You entered 123</code></p>
<p>Works fine.</p>
</li>
<li>
<p><code>a</code>: <code>You entered 0</code></p>
<p>Nothing to extract really. <code>std::cin</code> goes into failure mode and refused to pass anything to <code>x</code> (which by default is 0).</p>
</li>
<li>
<p><code>123.1</code>: <code>You entered 123</code></p>
<p>This is because list initialization only disallows narrow conversion on the line of definition. The user&rsquo;s input is processed and assigned to <code>x</code> on another line and thus conversion still can happen.</p>
</li>
<li>
<p><code>-3</code>: <code>You entered -3</code></p>
<p>Works fine for negative numbers as well.</p>
</li>
<li>
<p><code>aaa</code>: <code>You entered 0</code></p>
<p>Nothing to extract.</p>
</li>
<li>
<p><code>a123</code>: <code>You entered 0</code></p>
<p>Nothing to extract because the input is lead by character <code>a</code>.</p>
</li>
<li>
<p><code>123a</code>: <code>You entered 123</code></p>
<p>Extracting everything until it can&rsquo;t.</p>
</li>
</ul>
<h2 id="uninitialized-variables">Uninitialized variables</h2>
<p>In C++, leaving the variables uninitialized can be dangerous, so we need to know what will happen when e.g. an integer is defined yet uninitialized:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> globalVar;  <span style="color:#998;font-style:italic">// [GOOD] global variable is zero-initialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> staticVar;  <span style="color:#998;font-style:italic">// [GOOD] static variable is zero-initialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> localVar1;  <span style="color:#998;font-style:italic">// [BAD] local variable is indeterminate when uninitialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> localVar1;  <span style="color:#998;font-style:italic">// [BAD] could be any value or lead to crash
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> localVar2{};  <span style="color:#998;font-style:italic">// [GOOD] local variable is zero-initialized w/ curly braces
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> array[<span style="color:#099">5</span>] <span style="font-weight:bold">=</span> {<span style="color:#099">42</span>};  <span style="color:#998;font-style:italic">// [GOOD] unspecified array values are zero-initialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="keywords-aka-reserved-words">Keywords (aka reserved words)</h2>
<p>There are 92 keywords as of C++23, which all have special meanings in the C++ language:</p>
<p style="margin-bottom:-20px"></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>alignas</code></td>
<td style="text-align:left"><code>const_cast</code></td>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left"><code>staic_assert</code></td>
</tr>
<tr>
<td style="text-align:left"><code>alignof</code></td>
<td style="text-align:left"><code>continue</code></td>
<td style="text-align:left"><code>long</code></td>
<td style="text-align:left"><code>static_cast</code></td>
</tr>
<tr>
<td style="text-align:left"><code>and</code></td>
<td style="text-align:left"><code>co_await</code> (C++20)</td>
<td style="text-align:left"><code>mutable</code></td>
<td style="text-align:left"><code>struct</code></td>
</tr>
<tr>
<td style="text-align:left"><code>and_eq</code></td>
<td style="text-align:left"><code>co_return</code> (C++20)</td>
<td style="text-align:left"><code>namespace</code></td>
<td style="text-align:left"><code>switch</code></td>
</tr>
<tr>
<td style="text-align:left"><code>asm</code></td>
<td style="text-align:left"><code>co_yield</code> (C++20)</td>
<td style="text-align:left"><code>new</code></td>
<td style="text-align:left"><code>template</code></td>
</tr>
<tr>
<td style="text-align:left"><code>auto</code></td>
<td style="text-align:left"><code>decltype</code></td>
<td style="text-align:left"><code>noexcept</code></td>
<td style="text-align:left"><code>this</code></td>
</tr>
<tr>
<td style="text-align:left"><code>bitand</code></td>
<td style="text-align:left"><code>default</code></td>
<td style="text-align:left"><code>not</code></td>
<td style="text-align:left"><code>thread_local</code></td>
</tr>
<tr>
<td style="text-align:left"><code>bitor</code></td>
<td style="text-align:left"><code>delete</code></td>
<td style="text-align:left"><code>not_eq</code></td>
<td style="text-align:left"><code>throw</code></td>
</tr>
<tr>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left"><code>do</code></td>
<td style="text-align:left"><code>nullptr</code></td>
<td style="text-align:left"><code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>break</code></td>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left"><code>operator</code></td>
<td style="text-align:left"><code>try</code></td>
</tr>
<tr>
<td style="text-align:left"><code>case</code></td>
<td style="text-align:left"><code>dynamic_cast</code></td>
<td style="text-align:left"><code>or</code></td>
<td style="text-align:left"><code>typedef</code></td>
</tr>
<tr>
<td style="text-align:left"><code>catch</code></td>
<td style="text-align:left"><code>else</code></td>
<td style="text-align:left"><code>or_eq</code></td>
<td style="text-align:left"><code>typeid</code></td>
</tr>
<tr>
<td style="text-align:left"><code>char</code></td>
<td style="text-align:left"><code>enum</code></td>
<td style="text-align:left"><code>private</code></td>
<td style="text-align:left"><code>typename</code></td>
</tr>
<tr>
<td style="text-align:left"><code>char8_t</code> (C++20)</td>
<td style="text-align:left"><code>explicit</code></td>
<td style="text-align:left"><code>protected</code></td>
<td style="text-align:left"><code>union</code></td>
</tr>
<tr>
<td style="text-align:left"><code>char16_t</code></td>
<td style="text-align:left"><code>export</code></td>
<td style="text-align:left"><code>public</code></td>
<td style="text-align:left"><code>unsigned</code></td>
</tr>
<tr>
<td style="text-align:left"><code>char32_t</code></td>
<td style="text-align:left"><code>extern</code></td>
<td style="text-align:left"><code>register</code></td>
<td style="text-align:left"><code>using</code></td>
</tr>
<tr>
<td style="text-align:left"><code>class</code></td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left"><code>reinterpret_cast</code></td>
<td style="text-align:left"><code>virtual</code></td>
</tr>
<tr>
<td style="text-align:left"><code>compl</code></td>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left"><code>requries</code> (C++20)</td>
<td style="text-align:left"><code>void</code></td>
</tr>
<tr>
<td style="text-align:left"><code>concept</code> (C++20)</td>
<td style="text-align:left"><code>for</code></td>
<td style="text-align:left"><code>return</code></td>
<td style="text-align:left"><code>volatile</code></td>
</tr>
<tr>
<td style="text-align:left"><code>connst</code></td>
<td style="text-align:left"><code>friend</code></td>
<td style="text-align:left"><code>short</code></td>
<td style="text-align:left"><code>wchar_t</code></td>
</tr>
<tr>
<td style="text-align:left"><code>consteval</code> (C++20)</td>
<td style="text-align:left"><code>goto</code></td>
<td style="text-align:left"><code>signed</code></td>
<td style="text-align:left"><code>while</code></td>
</tr>
<tr>
<td style="text-align:left"><code>constexpr</code></td>
<td style="text-align:left"><code>if</code></td>
<td style="text-align:left"><code>sizeof</code></td>
<td style="text-align:left"><code>xor</code></td>
</tr>
<tr>
<td style="text-align:left"><code>constinit</code> (C++20)</td>
<td style="text-align:left"><code>inline</code></td>
<td style="text-align:left"><code>static</code></td>
<td style="text-align:left"><code>xor_eq</code></td>
</tr>
</tbody>
</table>
<p>C++ also defines special identifiers: <code>override</code>, <code>final</code>, <code>import</code> and <code>module</code>. These have special meanings when used in certain contexts but are not reserved otherwise.</p>
<h2 id="identifier-naming-best-practices">Identifier naming best practices</h2>
<ul>
<li>
<p>If the variable/function name is one word, the whole thing should be in lower case e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> value;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">function</span>();
</span></span></code></pre></div></li>
<li>
<p>If the variable or function name is multi-word, both <em>snake case</em> and <em>camel case</em> are preferred.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> some_value;      <span style="color:#998;font-style:italic">// snake case
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">some_function</span>(); <span style="color:#998;font-style:italic">// snake case
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> someValue;       <span style="color:#998;font-style:italic">// camel case
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">someFunction</span>();  <span style="color:#998;font-style:italic">// camel case
</span></span></span></code></pre></div></li>
<li>
<p>Avoid naming identifiers starting with an underscore, as these are often reserved for OS, library and/or compiler use.</p>
</li>
<li>
<p>Name your identifiers as meaningful as possible, except for those trivial variables serving as intermediate purposes.</p>
</li>
</ul>
<h2 id="whitespace-rules">Whitespace rules</h2>
<ul>
<li>
<p>Whitespaces are used as separators in C++, but the compiler doesn&rsquo;t care how many whitespaces are used.</p>
</li>
<li>
<p>Sometimes newlines are used as separators e.g. in single-line comments and preprocessor directives (e.g. <code>#include &lt;iostream&gt;</code>).</p>
</li>
<li>
<p>Quoted text takes whitespaces literally and do not allow newlines. Quoted text separated by nothing but whitespaces or newlines are automatically concatenated:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;this is not the same&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;this is not    the same&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;this is not</span>
</span></span><span style="display:flex;"><span>    allowed<span style="color:#b84">&#34;; // broken by newline, not allowed</span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;this is &#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#b84">&#34;allowed though&#34;</span>;  <span style="color:#998;font-style:italic">// separated by whitespace
</span></span></span></code></pre></div></li>
</ul>
<h2 id="basic-coding-style">Basic coding style</h2>
<ul>
<li>
<p>By converting tabs into spaces automatically, the formatting is self-describing &ndash; code that is spaced using spaces will always look correct regardless of editor. There is no right answer whether using tabs is better or worse than spaces though.</p>
</li>
<li>
<p>The Google C++ style recommends putting the opening curly brace on the same line as the statement, the other commonly accepted alternative is to align the opening and closing braces on the same level of indentation.</p>
</li>
<li>
<p>Each statement within curly braces should start one tab in from the opening brace.</p>
</li>
<li>
<p>Lines should not be too long. Typically by &ldquo;too long&rdquo; we mean more than 80 characters.</p>
</li>
<li>
<p>If a long line is split with an operator (e.g. <code>&lt;&lt;</code> or <code>+</code>), the operator should be placed at the beginning of the next line, not the end of the current line:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">3</span> <span style="font-weight:bold">+</span> <span style="color:#099">4</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">+</span> <span style="color:#099">5</span> <span style="font-weight:bold">+</span> <span style="color:#099">6</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">*</span> <span style="color:#099">7</span> <span style="font-weight:bold">*</span> <span style="color:#099">8</span>;
</span></span></code></pre></div></li>
<li>
<p>Use whitespaces to make your code easier to read by aligning values or comments or adding spacing between blocks of code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 1A: hard to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>cost <span style="font-weight:bold">=</span> <span style="color:#099">57</span>;
</span></span><span style="display:flex;"><span>pricePerItem <span style="font-weight:bold">=</span> <span style="color:#099">24</span>;
</span></span><span style="display:flex;"><span>value <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>numberOfItems <span style="font-weight:bold">=</span> <span style="color:#099">17</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 1B: easier to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>cost          <span style="font-weight:bold">=</span> <span style="color:#099">57</span>;
</span></span><span style="display:flex;"><span>pricePerItem  <span style="font-weight:bold">=</span> <span style="color:#099">24</span>;
</span></span><span style="display:flex;"><span>value         <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>numberOfItems <span style="font-weight:bold">=</span> <span style="color:#099">17</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2A: hard to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello world!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; <span style="color:#998;font-style:italic">// cout lives in the iostream library
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;It is very nice to meet you!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; <span style="color:#998;font-style:italic">// these comments make the code hard to read
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Yeah!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; <span style="color:#998;font-style:italic">// especially when lines are different lengths
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2B: easier to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello world!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;                  <span style="color:#998;font-style:italic">// cout lives in the iostream library
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;It is very nice to meet you!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="color:#998;font-style:italic">// these comments are easier to read
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Yeah!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;                         <span style="color:#998;font-style:italic">// especially when all lined up
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 3A: hard to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// cout lives in the iostream library
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello world!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// these comments make the code hard to read
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;It is very nice to meet you!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// especially when all bunched together
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Yeah!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 3B: easier to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// cout lives in the iostream library
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello world!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// these comments are easier to read
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;It is very nice to meet you!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// when separated by whitespace
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Yeah!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span></code></pre></div></li>
</ul>
<h2 id="literals">Literals</h2>
<p>Literals are values that are inserted directly into the source code. These values usually appear directly in the executable code (unless they are optimized out). In contrast, objects and variables represent memory locations that hold values and these values can be fetched on demand.</p>
<h2 id="operators">Operators</h2>
<p>In mathematics, an <strong>operation</strong> is a process involving zero or more input values (called <strong>operands</strong>) that produce a new value (called an <strong>output value</strong>). The specific operation to be performed is denoted by a symbol usually, called an <strong>operator</strong>. This is the same as in C++. There are operators that are represented by symbols e.g. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code> and insertion <code>&lt;&lt;</code>, extraction <code>&gt;&gt;</code> and equality <code>==</code>. There are also operators that are reserved words e.g. <code>new</code>, <code>delete</code> and <code>throw</code>.</p>
<p>The number of operands an operator takes as input is called the operator&rsquo;s <strong>arity</strong>. Operators in C++ come in four different arities:</p>
<ul>
<li><strong>Unary</strong> operators act on one operand e.g. negative <code>-</code> in <code>-5</code>.</li>
<li><strong>Binary</strong> operators act on two operands (often called <em>left</em> and <em>right</em> operands) e.g. addition <code>+</code> in <code>3 + 4</code>, or insertion <code>&lt;&lt;</code> as in <code>std::cout &lt;&lt; &quot;something&quot;</code>.</li>
<li><strong>Ternary</strong> operators act on three operands. There is only <strong>one</strong> ternary operator in C++, namely the <strong>conditional operator</strong>.</li>
<li><strong>Nullary</strong> operators act on zero operands. There is only <strong>one</strong> nullary operator in C++, namely the <code>throw</code> operator.</li>
</ul>
<p>Note that some operators have different meanings depending on the use case e.g. operator <code>-</code> can mean both negative and subtract.</p>
<p>There is a famous abbreviation for the order in which the arithmetic operators are executed: PEMDAS (parenthesis &gt; exponents &gt; multiplication/division &gt; addition/subtraction).</p>
<h1 id="functions-and-files">Functions and Files</h1>
<h2 id="introduction-to-functions">Introduction to functions</h2>
<p>The syntax/form of a general value-returning function is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>return_type <span style="color:#900;font-weight:bold">function_name</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// function body
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> return_value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and for a non-value-returning functions</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">function_name</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// function body
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>The C++ standard only defines the meaning of 3 status codes for programs: 0, EXIT_SUCCESS and EXIT_FAILURE. Both 0 and EXIT_SUCCESS mean the program executed successfully. EXIT_FAILURE means the program did not execute successfully.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstdlib&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for EXIT_SUCCESS and EXIT_FAILURE
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For maximum portability, we only use 0 or EXIT_SUCCESS to indicate a successful termination, and EXIT_FAILURE to indicate an unsuccessful termination. Function <code>main</code> will implicitly return 0 if no return statement is provided. That being said, the best practice is still to return a value from <code>main</code> explicitly.</p>
<p><strong>C++ disallows calling the <code>main</code> function directly.</strong></p>
<h2 id="function-parameters-and-arguments">Function parameters and arguments</h2>
<p>When a function is called, all its parameters of the functions, as defined in the function header, are created as variables, and the value of each of the arguments is <em>copied</em> into the matching parameter (using <em>copy initialization</em>). The process is called <strong>pass by value</strong>. Function parameters that utilized pass by value are called <strong>value parameters</strong>.</p>
<h2 id="local-variables">Local variables</h2>
<p>Variables defined inside the body of a function are called <strong>local variables</strong> (as opposed to <strong>global variables</strong>), and they&rsquo;re destroyed <em>in the opposite order of creation</em> at the end of the set of curly braces in which they are defined. The <strong>local scope</strong> is thereby defined as where a local variable&rsquo;s lifetime lasts.</p>
<h2 id="forward-declarations">Forward declarations</h2>
<p>The following program will throw a compile error</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;The sum of 3 and 4 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> add(<span style="color:#099">3</span>, <span style="color:#099">4</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>because the C++ compiler compiles codes sequentially. By the time <code>main</code> uses <code>add</code>, the identifier <code>add</code> was even defined yet and thus causes a compile error complaining <code>identifier not found</code>. To address this problem, there are two options:</p>
<ul>
<li>
<p>Option 1: reorder the function definitions</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;The sum of 3 and 4 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> add(<span style="color:#099">3</span>, <span style="color:#099">4</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>Option 2: use a <strong>forward declaration</strong></p>
<p>This is important as option 1 is not always possible, e.g. when function A calls function B within, and vice versa. That means we can never reorder them to allow sequential compiling.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y);  <span style="color:#998;font-style:italic">// with or without parameter names, both are fine
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;The sum of 3 and 4 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> add(<span style="color:#099">3</span>, <span style="color:#099">4</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s crutial to note that, if we forget to actually define the funciton body, the program will still <strong>compile</strong> just fine, but will eventuall fail at the <strong>link</strong> stage.</p>
</li>
</ul>
<h2 id="declaration-and-definition">Declaration and definition</h2>
<p>In C++, all definitions are declarations, but not always the other way around.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Term</th>
<th style="text-align:left">Definition</th>
<th style="text-align:left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Definition</td>
<td style="text-align:left">Implements a function or instantiates a variable. Definitions are always declarations.</td>
<td style="text-align:left"><code>void foo() {} // function definition</code><br><code>int x; // variable definition</code></td>
</tr>
<tr>
<td style="text-align:left">Declaration</td>
<td style="text-align:left">Tells compiler about an identifier and its associated type information</td>
<td style="text-align:left"><code>void foo(); // function declaration</code><br><code>int x; // variable declaration</code></td>
</tr>
<tr>
<td style="text-align:left">Pure declaration</td>
<td style="text-align:left">A declaration that is not a definition</td>
<td style="text-align:left"><code>void foo();</code></td>
</tr>
<tr>
<td style="text-align:left">Initializer</td>
<td style="text-align:left">Provides tan initial value for a defined object</td>
<td style="text-align:left"><code>int x {2}; // 2 here is the initializer</code></td>
</tr>
</tbody>
</table>
<h2 id="the-one-definition-rule-odr">The one definition rule (ODR)</h2>
<p>The <strong>one definition rule</strong> (aka ODR) is a well-known rule in C++, which consists of three parts:</p>
<ul>
<li>Within a <em>file</em>, each function, variable, type or template can only have one definition. Definitions occurring in different scopes do not violate this rule.</li>
<li>Within a <em>program</em>, each function or variable can only have one definition. This rule exists because a program can have more than one files. Functions and variables <strong>not visible to the linker</strong> are excluded from this rule.</li>
<li>Types, templates, inline functions and inline variables are allowed to have duplicate definitions in different files, so long as each definition is <strong>identical</strong>.</li>
</ul>
<p>Violating the first part will issue a redefinition compile error. Violating part two will cause the linker to issue a redefinition error. Violating part three will cause undefined behavior.</p>
<p>Functions that share the same identifier but different sets of parameters are considered to be different functions, so won&rsquo;t violate part one/two of ODR above.</p>
<h2 id="programs-with-multiple-files">Programs with multiple files</h2>
<p>In order to write the following program (which will throw a compile error, see above) into a multi-file program</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;The sum of 3 and 4 is: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> add(<span style="color:#099">3</span>, <span style="color:#099">4</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>we might just write an <code>app.cpp</code> as</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and <code>main.cpp</code> as</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;The sum of 3 and 4 is: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> add(<span style="color:#099">3</span>, <span style="color:#099">4</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="naming-collisions-and-namespaces">Naming collisions and namespaces</h2>
<p>Most naming collisions occur in two ways:</p>
<ul>
<li>Two (or more) identically named functions (or global variables) are introduced into separate files belonging to the same program. This will result in a linker error.</li>
<li>Two (or more) identically named functions (or global variables) are introduced into the same file. This will result in a compiler error.</li>
</ul>
<p>C++ provides plenty of mechanisms for avoiding naming collisions. Besides local scope, we have <strong>namespaces</strong>:</p>
<ul>
<li>The global namespace (aka the global scope)</li>
<li>The <code>std</code> namespace</li>
<li>Other namespaces</li>
</ul>
<p>There are two ways to use a namespace e.g. <code>std</code>:</p>
<ul>
<li>Explicit namespace qualifier <code>::</code> e.g. <code>std::cout</code></li>
<li>Using namespace (not recommended) e.g. <code>using namespace std;</code></li>
</ul>
<h2 id="preprocessors">Preprocessors</h2>
<p>Preprocessors make various changes to the text of the code file, only after which the compilation happens. In modern compilers, the preprocessors are usually built right inside the compiler itself. Most of what the preprocessors do are fairly uninteresting, e.g. strips out comments, ensures each code file ends in a newline, and (most importantly) processing the <code>#include</code> directives.</p>
<p><strong>Preprocessor directives</strong></p>
<p>When the preprocessor runs, it scans through the code file (from top to bottom), looking for preprocessor directives. Preprocessor directives (often called directives) are instructions that start with a <code>#</code> symbol and end with a newline (NOT a semicolon). These directives tell the preprocessor to perform certain text manipulation tasks. Note that the preprocessor does not understand the C++ syntax &ndash; instead, the directives have their own syntax (which in some case resembles C++ syntax, and in other cases, not so much).</p>
<p>Below are some of the most common preprocessor directives:</p>
<ul>
<li>
<p><code>#include</code> to include content of files</p>
</li>
<li>
<p><code>#define</code> to create global macros (in C++ a macro is a rule that defines how text is converted into replacement output text)</p>
<p>There are two types of macros: <em>object</em>-like macros and <em>function</em>-like macros. The latter is usually considered <strong>unsafe</strong>, and almost anything they can do can be done by a normal function. The first, instead, can be used widely and in one of two ways:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define identifier
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define identifier substitution_text
</span></span></span></code></pre></div><p>Note that the substitution only happens in normal code, i.e. it does apply to other preprocessor directives.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define FOO 9 </span><span style="color:#998;font-style:italic">// Here&#39;s a macro substitution
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifdef FOO </span><span style="color:#998;font-style:italic">// This FOO does not get replaced because it’s part of another preprocessor directive
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> FOO <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// This FOO gets replaced with 9 because it&#39;s part of the normal code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>We recommend avoiding the second kind of macros altogether at all, as there are better ways to do the same thing e.g. using named constants. For the first kind, they are accepted more generally.</p>
</li>
<li>
<p><code>#ifdef</code>, <code>#ifndef</code> and <code>#endif</code> for conditional compilation</p>
<p>The <em>conditional compilation</em> preprocessor directives allow one to specify under what conditions something will or will not compile</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define PRINT_JOE
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#999;font-weight:bold">#ifdef PRINT_JOE
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>      std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Joe</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="color:#998;font-style:italic">// will be compiled
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#999;font-weight:bold">#ifdef PRINT_BOB
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>      std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Bob</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="color:#998;font-style:italic">// will not be compiled at all
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#999;font-weight:bold">#ifndef PRINT_BOB
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>      <span style="color:#999;font-weight:bold">#define PRINT_BOB  </span><span style="color:#998;font-style:italic">// will define PRINT_BOB
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#999;font-weight:bold">#ifdef PRINT_BOB
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>      std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Bob</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="color:#998;font-style:italic">// will compile this time
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><code>#if 0</code> can be used to exclude a block of code from being compiled as if it&rsquo;s inside a comment block:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Joe</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="color:#998;font-style:italic">// will be compiled
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#if 0</span><span style="color:#998;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">  std::cout &lt;&lt; &#34;Bob\n&#34;;  // will not be compiled at all
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">  /*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">    this is some previously existing block comment and
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">    because of that, we cannot use block comment again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">    to &#34;comment out&#34; this chunk of codes. using #if 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">    will be the only solution to avoid this part to be
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">    compiled or run by C++
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">  */
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h2 id="the-scope-of-define">The scope of <code>#define</code></h2>
<p>The preprocessor doesn&rsquo;t understand C++, so all preprocessor directives will be resolved <strong>before compilation</strong> from <strong>top to bottom</strong> on a <strong>file-by-file</strong> basis. The following macro <code>MY_NAME</code>, as a result, will be resolved without actually calling <code>foo</code> at all.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">foo</span>() {
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define MY_NAME &#34;Alex&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;My name is: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> MY_NAME <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the following code will print <code>Not printing!</code> because the directives are only valid from the point of definition to the end of the exact file.</p>
<p>function.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">doSomething</span>() {
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifdef PRINT
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Printing!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef PRINT
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Not printing!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>}
</span></span></code></pre></div><p>main.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">doSomething</span>(); <span style="color:#998;font-style:italic">// forward declaration for function doSomething()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define PRINT
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    doSomething();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="header-files">Header files</h2>
<p>The main purpose of a header file (.h or .hpp) is to propagate declarations to code (.cpp) files. Source files (.cpp) should always include their own paired header files (.h or .hpp) if exist. No source files (.cpp) should be included, although C++ preprocessors are able to do that.</p>
<p>We use angled brackets <code>&lt;&gt;</code> for header files that are not written by ourselves. The preprocessor will search for the header only in the directories specified by the <code>include directories</code>. The <code>include directories</code> are configured as part of the project/IDE/compiler settings, and typically default to the directories containing the header files that come with your compiler and/or OS.</p>
<p>When we use double-quotes <code>&quot;&quot;</code> for the header file, we&rsquo;re telling the preprocessor that the header file is written by us and should be first searched in the current directory. If it can&rsquo;t find the file, it will then search the <code>include directories</code>.</p>
<p>When trying to include header files from another directory, you can, but are not recommended to do the following</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;headers/myHeader.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;../moreHeaders/myOtherHeader.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span></code></pre></div><p>Instead, it&rsquo;s advised to change the IDE/compiler setting to include the extra include directories e.g.</p>
<pre tabindex="0"><code>g++ -o main -I/folder/other/headers main.cpp&#34;
</code></pre><p>This is the same in VS Code, as you can add <code>-I/folder/other/headers</code> in the <code>Args</code> section in <code>tasks.json</code> of your project.</p>
<h2 id="the-include-order-of-headers">The <code>#include</code> order of headers</h2>
<p>The best practice is to include headers in the following order:</p>
<ul>
<li>The paired header file</li>
<li>Other headers from your project</li>
<li>3rd party library headers</li>
<li>Standard library headers</li>
</ul>
<p>The headers for each group should be sorted alphabetically unless documentation for a 3rd party library instructs you to do otherwise.</p>
<h2 id="header-file-best-practices-summary">Header file best practices (summary)</h2>
<ul>
<li>Always include <strong>header guards</strong></li>
<li><strong>Do not</strong> define variables or functions inside header files &ndash; only declaration</li>
<li>Give a header file the same name as the paired source file</li>
<li>Each header file should have a specific job and be as independent as possible</li>
<li>A header file should <code>#include</code> all other headers as long as needed so that it can function independently</li>
<li>Only <code>#include</code> headers that we actually need</li>
<li><strong>Do not</strong> <code>#include</code> .cpp files</li>
<li>Prefer putting documentation on
<ul>
<li>what something does or how to use it in the header as it&rsquo;s more likely to be seen there</li>
<li>how something actually works in the source files</li>
</ul>
</li>
</ul>
<h2 id="header-guards">Header guards</h2>
<p>The following project has header guards to prevent including duplicate definitions</p>
<p>square.h:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef SQUARE_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define SQUARE_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getSquareSides</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>wave.h:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef WAVE_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define WAVE_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;square.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>main.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;square.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;wave.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, if we add a source file <code>square.cpp</code> as follows, then the fact that <code>square.h</code> is included twice causes the problem of <code>getSquareSides</code> being defined once in <code>square.cpp</code> and <code>main.cpp</code>, causing a linker error:</p>
<p>square.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;square.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getSquarePerimeter</span>(<span style="color:#458;font-weight:bold">int</span> sideLength) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> sideLength <span style="font-weight:bold">*</span> getSquareSides();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to solve this issue, we can put all definitions into <code>source.cpp</code> and leave only function declarations in <code>square.h</code>:</p>
<p>square.h:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef SQUARE_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define SQUARE_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getSquareSides</span>();
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getSquarePerimeter</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>square.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;square.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getSquareSides</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getSquarePerimeter</span>(<span style="color:#458;font-weight:bold">int</span> sideLength) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> sideLength <span style="font-weight:bold">*</span> getSquareSides();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="how-about-pragma-once">How about <code>#pragma once</code></h2>
<p>In modern compilers there is a simpler (but not as safe) way to do header guard:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#pragma once
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span><span style="color:#998;font-style:italic">// define whatever
</span></span></span></code></pre></div><p>Note: if a header file is copied so that it exists in multiple places on the file system, if somehow both copies of the header get included, header guards will successfully de-dupe the identical headers, but <code>#pragma once</code> won&rsquo;t because the compiler won&rsquo;t realize they are actually identical content.</p>
<h1 id="debugging-c-programs">Debugging C++ Programs</h1>
<h2 id="debugging-tactics">Debugging tactics</h2>
<p>Several tips on debugging a C++ program:</p>
<ul>
<li>Conditionalizing the code using preprocessor directives e.g. <code>ifdef</code>, <code>endif</code> and <code>define</code></li>
<li>Using a logger e.g. <code>plog</code>, <code>glog</code> or <code>spdlog</code></li>
<li>Using an integrated debugger
<ul>
<li>Step into: run line by line inside function</li>
<li>Step over: run and skip the whole function</li>
<li>Step out: when you accidentally step into a function, use this to step out and pause on the next line of the function</li>
<li>Start: starting from the beginning</li>
<li>Continue: continue until the end</li>
<li>Breakpoints: tell debugger to stop no matter what</li>
<li>Variable watchers: monitoring the values of variables</li>
</ul>
</li>
</ul>
<h1 id="fundamental-data-types">Fundamental Data Types</h1>
<h2 id="bits-bytes-and-memory-addressing">Bits, bytes and memory addressing</h2>
<p>The smallest unit of memory is a <strong>binary bit</strong> (aka a <strong>bit</strong>) which can hold 0 or 1. A modern de-facto standard <strong>byte</strong> is 8 bits.</p>
<h2 id="fundamental-data-types-1">Fundamental data types</h2>
<p>Here is a list of fundamental data types in C++</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Data Type (<em>Minimum Size</em> in Bytes)</th>
<th>Meaning</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Floating Point</td>
<td><code>float</code> (4)<br><code>double</code> (8)<br><code>long double</code> (8)</td>
<td>a number with a fractional part</td>
<td><code>3.14159</code></td>
</tr>
<tr>
<td>Integral (Boolean)</td>
<td><code>bool</code> (1)</td>
<td>true or false</td>
<td><code>true</code></td>
</tr>
<tr>
<td>Integral (Character)</td>
<td><code>char</code> (1)<br><code>wchar_t</code> (1)<br><code>char8_t</code> (1, C++20)<br><code>char16_t</code> (2, C++11)<br><code>char32_t</code> (4, C++11)</td>
<td>a single character of text</td>
<td><code>'c'</code></td>
</tr>
<tr>
<td>Integral (Integer)</td>
<td><code>short int</code> (2)<br><code>int</code> (2)<br><code>long int</code> (4)<br><code>long long int</code> (8, C++11)</td>
<td>whole numbers including zero</td>
<td><code>64</code></td>
</tr>
<tr>
<td>Null Pointer</td>
<td><code>std::nullptr_t</code> (4, C++11)</td>
<td>a null pointer</td>
<td><code>nullptr</code></td>
</tr>
<tr>
<td>Void</td>
<td><code>void</code></td>
<td>no type</td>
<td><code>n/a</code></td>
</tr>
</tbody>
</table>
<h2 id="the-void-type">The <code>void</code> type</h2>
<p>There are three use cases of the <code>void</code> type:</p>
<ul>
<li>
<p>Functions that do not return anything</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">writeSomething</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>Functions that take no parameters (depreciated)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getValue</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is compilable in C++ (for backwards compatibility mostly) but not recommended. You can just remove the <code>void</code> in the brackets.</p>
</li>
<li>
<p>Void pointers (advanced, covered later)</p>
</li>
</ul>
<h2 id="the-sizeof-function">The <code>sizeof</code> function</h2>
<p>See above table for the sizes in bytes of different fundamental data types. Notice that using of <code>sizeof</code> on incomplete type e.g. <code>void</code>
will result in a compilation error. Also, <code>sizeof</code> don&rsquo;t take dynamically allocated memory used by an object into consideration, about which we need to have further discussion.</p>
<p>On a side note, how fast a type is in C++ doesn&rsquo;t really depend on how large the memory it uses. Instead of &ldquo;smaller is faster&rdquo;, CPUs are actually optimized w.r.t. the corresponding specs and thus seeing 32-bit <code>int</code> being faster than 16-bit <code>short</code> or an 8-bit <code>char</code> is totally possible on a 32-bit CPU.</p>
<h2 id="signed-integer-ranges">Signed integer ranges</h2>
<p>Again, in C++ only the minimum sizes of fundamental data types are specified, <code>int</code> and <code>short</code> starts with 2 bytes, <code>long</code> 4 bytes and <code>long long</code> 8 bytes. This means the actual size of the integers can vary based on implementation. The corresponding ranges of these types are listed below:</p>
<table>
<thead>
<tr>
<th>Size / Type</th>
<th>Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bit / ?</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>16 bit / <code>short</code>, <code>int</code></td>
<td>-32,768 to 32,769</td>
</tr>
<tr>
<td>32 bit / <code>long</code></td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>64 bit / <code>long long</code></td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>
</tbody>
</table>
<p>Assigning a value beyond the defined range will result in undefined behavior, which is called <strong>integer overflow</strong>.</p>
<h2 id="unsigned-integer-ranges">Unsigned integer ranges</h2>
<p>The corresponding range table for unsigned integer types are:</p>
<table>
<thead>
<tr>
<th>Size / Type</th>
<th>Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bit / ?</td>
<td>0 to 255</td>
</tr>
<tr>
<td>16 bit / <code>unsigned short</code>, <code>unsigned int</code></td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>32 bit / <code>unsigned long</code></td>
<td>0 to 4,294,967,295</td>
</tr>
<tr>
<td>64 bit / <code>unsigned long long</code></td>
<td>0 to 18,446,744,073,709,551,615</td>
</tr>
</tbody>
</table>
<p>Unsigned integer overflow: if an unsigned value is out of range, is it divided by one greater than the largest number of the type, and only the remainder is kept. For example, the number 280 is too big for 1-byte integer, and thus 280 % 256 = 24 is set to the variable in the end.</p>
<h2 id="fixed-width-integers-fast-and-least-integers">Fixed-width integers, fast and least integers</h2>
<p>Different from the native C/C++ integer types which have variable sizes (only minimum sizes were specified in above table), starting from C99 we have fixed-width integers in the <code>stdint.h</code> (later in C++ becoming <code>cstdint.h</code>) header:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int16_t</span> i{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, the fixed-width integers are not guaranteed to be defined on all architectures, nor is it faster than the native C/C++ integer types. This introduces the fast and least integer types:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;least 8: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int_least8_t</span>) <span style="font-weight:bold">*</span> <span style="color:#099">8</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bits</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;least 16: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int_least16_t</span>) <span style="font-weight:bold">*</span> <span style="color:#099">8</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bits</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;least 32: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int_least32_t</span>) <span style="font-weight:bold">*</span> <span style="color:#099">8</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bits</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;fast 8: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int_fast8_t</span>) <span style="font-weight:bold">*</span> <span style="color:#099">8</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bits</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;fast 16: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int_fast16_t</span>) <span style="font-weight:bold">*</span> <span style="color:#099">8</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bits</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;fast 32: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int_fast32_t</span>) <span style="font-weight:bold">*</span> <span style="color:#099">8</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bits</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>where the least integer types guarantee that the integer holds at least given number of bits of width, and the fast integer types guarantee that the given integer type is the fastest with a width of at least given number of bits.</p>
<p>The downsides of these fast and least integers are that nobody really uses them and they might be too dynamic to make programs stable across architectures.</p>
<h2 id="best-practice-for-integral-types">Best practice for integral types</h2>
<p>Best practice:</p>
<ul>
<li>Prefer <code>int</code> when the size of the integer doesn&rsquo;t matter</li>
<li>Prefer <code>std::int#_t</code> when storing a quantity that needs a guaranteed range</li>
<li>Prefer <code>std::uint#_t</code> when doing bit manipulation or where well-defined wrap-around behavior is required</li>
</ul>
<p>Avoid the following if possible:</p>
<ul>
<li><code>short</code> and <code>long</code> integers - use a fixed-width instead</li>
<li>Unsigned types for holding quantities</li>
<li>The 8-bit fixed-width integer types</li>
<li>The fast and least fixed-width types</li>
<li>Any compiler-specific fixed-width integers e.g. <code>__int8</code> and <code>__int16</code> in Visual Studio</li>
</ul>
<h2 id="what-is-stdsize_t">What is <code>std::size_t</code></h2>
<p>The size of <code>std::size_t</code> is the upper limit of any object&rsquo;s size in the system.</p>
<h2 id="floating-point-numbers">Floating point numbers</h2>
<table>
<thead>
<tr>
<th>Category</th>
<th>Data Type (Minimum Size in Bytes)</th>
<th>Typical Size in Bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td>floating point</td>
<td>float (4)</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>double (8)</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>long double (8)</td>
<td>8, 12 or 16</td>
</tr>
</tbody>
</table>
<p>Remember to match the type of literal in initialization to the type of the variable, e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> y{<span style="color:#099">5.0</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span> z{<span style="color:#099">5.0F</span>}; <span style="color:#998;font-style:italic">// notice the suffix `f`
</span></span></span></code></pre></div><p>When we print the floating point numbers, there are a few interesting behaviors that worth attention:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">5.0</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">6.7F</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">9876543.21</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output of above program is</p>
<pre tabindex="0"><code>5
6.7
9.87654e+06
</code></pre><p>because</p>
<ul>
<li><code>std::cout</code> by default doesn&rsquo;t print the fractional part of a number if the fractional part is 0</li>
<li>the number <code>6.7F</code> was printed as expected because it&rsquo;s defined as a short float that defaults to be printed full</li>
<li>the scientific notation is used by default with 6 significant digits only</li>
</ul>
<p>We can override the default precision that <code>std::cout</code> shows by default using an <strong>output manipulator</strong> function named <code>std::setprecision()</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iomanip&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// for output manipulator std::setprecision()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>setprecision(<span style="color:#099">17</span>); <span style="color:#998;font-style:italic">// show 17 digits of precision
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">3.33333333333333333333333333333333333333f</span> <span style="font-weight:bold">&lt;&lt;</span><span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// f suffix means float
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">3.33333333333333333333333333333333333333</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// no suffix means double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which will now print</p>
<pre tabindex="0"><code>3.3333332538604736
3.3333333333333335
</code></pre><p>However, there&rsquo;s a concept called <strong>rounding error</strong> that makes precision handling in floats a headache. See this example</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iomanip&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// for std::setprecision()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> f { <span style="color:#099">123456789.0f</span> }; <span style="color:#998;font-style:italic">// f has 10 significant digits
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>setprecision(<span style="color:#099">9</span>); <span style="color:#998;font-style:italic">// to show 9 digits in f
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> f <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output of the above program is <code>123456792</code> which is a totally different number, and that&rsquo;s because the original number <code>123456789.0</code> has 10 significant digits. In order to show the original number with 9 significant digits only, the number cannot be stored exactly/precisely. A corollary of this is to be wary of using floating point numbers for financial or currency data.</p>
<p>The official ranges of floating point numbers are defined as below</p>
<table>
<thead>
<tr>
<th>Data Type Size in Bytes</th>
<th>Range</th>
<th>Precision</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>±1.18 x 10-38 to ±3.4 x 1038 and 0.0</td>
<td>6-9 significant digits, typically 7</td>
</tr>
<tr>
<td>8</td>
<td>±2.23 x 10-308 to ±1.80 x 10308 and 0.0</td>
<td>15-18 significant digits, typically 16</td>
</tr>
<tr>
<td>80-bits (typically uses 12 or 16 bytes)</td>
<td>±3.36 x 10-4932 to ±1.18 x 104932 and 0.0</td>
<td>18-21 significant digits</td>
</tr>
<tr>
<td>16</td>
<td>±3.36 x 10-4932 to ±1.18 x 104932 and 0.0</td>
<td>33-36 significant digits</td>
</tr>
</tbody>
</table>
<h2 id="nan-and-infinity">NaN and infinity</h2>
<p>There are two special categories of floating point numbers, NaN (not a number) and infinity.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> zero {<span style="color:#099">0.0</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> posinf { <span style="color:#099">5.0</span> <span style="font-weight:bold">/</span> zero }; <span style="color:#998;font-style:italic">// positive infinity
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> posinf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> neginf { <span style="font-weight:bold">-</span><span style="color:#099">5.0</span> <span style="font-weight:bold">/</span> zero }; <span style="color:#998;font-style:italic">// negative infinity
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> neginf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> nan { zero <span style="font-weight:bold">/</span> zero }; <span style="color:#998;font-style:italic">// not a number (mathematically invalid)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> nan <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output of above program is</p>
<pre tabindex="0"><code>inf
-inf
nan
</code></pre><p>Best practice is to avoid using NaN or infinity at all.</p>
<h2 id="boolean-values">Boolean values</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> b;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> b1{<span style="color:#999">true</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> b2{<span style="color:#999">false</span>};
</span></span><span style="display:flex;"><span>b1 <span style="font-weight:bold">=</span> <span style="color:#999">false</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> b3{};  <span style="color:#998;font-style:italic">// default is false &lt;- 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">bool</span> b4{<span style="font-weight:bold">!</span><span style="color:#999">true</span>};  <span style="color:#998;font-style:italic">// initialized to false
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">bool</span> b5{<span style="font-weight:bold">!</span><span style="color:#999">false</span>};  <span style="color:#998;font-style:italic">// initialized to true
</span></span></span></code></pre></div><p>Notice that printing boolean values is the same as printing the integer representation of the variables, i.e. only <code>0</code> and <code>1</code> will be printed. If you want <code>std::cout</code> to print actual <code>true</code> or <code>false</code>, you need to use another manipulator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#999">true</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#999">false</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>boolalpha;  <span style="color:#998;font-style:italic">// from now on, true/false will be printed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#999">true</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#999">false</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>noboolalpha;  <span style="color:#998;font-style:italic">// from now on, 1/0 will be printed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#999">true</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#999">false</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The conversion between a boolean and an integer variable is possible:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">bool</span> bFalse{<span style="color:#099">0</span>};  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">bool</span> bTrue{<span style="color:#099">1</span>};  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">bool</span> bNo{<span style="color:#099">2</span>};  <span style="color:#998;font-style:italic">// error (narrowing conversion is disallowed)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">bool</span> b1 <span style="font-weight:bold">=</span> <span style="color:#099">2</span>;  <span style="color:#998;font-style:italic">// ok (copy initialization allows implicit conversion)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>Inputting boolean values can be a bit unintuitive. See example below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">bool</span> b{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter a boolean value: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;You entered &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output (if you typed <code>true</code>) is</p>
<pre tabindex="0"><code>Enter a Boolean value: true
You entered: 0
</code></pre><p>because <code>std::cin</code> only accepts either <code>0</code> or <code>1</code> for boolean variables, and thus the input <code>true</code> caused a silent fail in <code>std::cin</code> and thus the variable <code>b</code> never got assigned otherwise than its default value <code>false</code>. To allow <code>std::cin</code> to accept <code>true</code> and <code>false</code>, we need to again turn on the alphabetical mode of boolean variables by</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">bool</span> b{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter a boolean value: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> std<span style="font-weight:bold">::</span>boolalpha;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;You entered &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice when <code>std::boolalpha</code> is enabled for <code>std::cin</code>, <code>0</code> and <code>1</code> will no longer work.</p>
<h2 id="chars">Chars</h2>
<p>Some information worth noting:</p>
<ul>
<li>ASCII 0-31 are unprintable chars, 32 is <code style="whitespace:pre"> </code> (space), 48 is <code>0</code>, 65 is <code>A</code> and 97 is <code>a</code>.</li>
<li>Multi-character input is allowed but only one character a time can be read into a <code>char</code> variable using <code>std::cin</code>. That means the subsequent <code>std::cin</code> can still read from the remaining input from the buffer.</li>
<li>Escape sequences are listed below
<ul>
<li><code>\a</code>: makes a beep alert</li>
<li><code>\b</code>: moves the cursor back one space</li>
<li><code>\f</code>: moves the cursor to the next logical page</li>
<li><code>\n</code>: moves the cursor to next line</li>
<li><code>\r</code>: moves the cursor to beginning of line</li>
<li><code>\t</code>: prints a horizontal tab</li>
<li><code>\v</code>: prints a vertical tab</li>
<li><code>\'</code>: prints a single quote</li>
<li><code>\&quot;</code>: prints a double quote</li>
<li><code>\\</code>: prints a backslash</li>
<li><code>\?</code>: prints a question mark (no longer relevant, as you can now always use question marks)</li>
<li><code>\(number)</code>: prints a char represented by an octal number</li>
<li><code>\x(number)</code>: prints a char represented by a hex number</li>
</ul>
</li>
</ul>
<h2 id="implicit-type-conversion-vs-explicit-static_cast">Implicit type conversion vs explicit <code>static_cast</code></h2>
<p>Implicit type conversion happens in the below program:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> print(<span style="color:#099">5.5</span>); <span style="color:#998;font-style:italic">// warning: we&#39;re passing in a double value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output is <code>5</code> in this case, as an integer cannot hold fractional part. Brace initialization, on the other hand, doesn&rsquo;t allow implicit conversion:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> d { <span style="color:#099">5</span> }; <span style="color:#998;font-style:italic">// okay: int to double is safe
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5.5</span> }; <span style="color:#998;font-style:italic">// error: double to int not safe
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Explicit type conversion, in the same time, is supported via the <code>static_cast</code> operator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> print( <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(<span style="color:#099">5.5</span>) ); <span style="color:#998;font-style:italic">// explicitly convert double value 5.5 to an int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the output is still <code>5</code> here as expected. It&rsquo;s worth noting that by converting <code>char</code> into <code>int</code> we can effectively get the the ASCII code of a character:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> ch{<span style="color:#099">97</span>}; <span style="color:#998;font-style:italic">// 97 is ASCII code for &#39;a&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ch <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; has value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(ch) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// print value of variable ch as an int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>where the output is</p>
<pre tabindex="0"><code>a has value 97
</code></pre><p>Meanwhile, by using <code>static_cast</code> to convert unsigned integer to signed integer variable, the compiler will produce undefined behavior and is definitely not recommended.</p>
<h1 id="constants-and-strings">Constants and Strings</h1>
<h2 id="two-types-of-constants">Two types of constants</h2>
<p>C++ supports two different types of constants:</p>
<ul>
<li><strong>Named constants</strong> are constant values that are associated with an identifier, aka <strong>symbolic constants</strong></li>
<li><strong>Literal constants</strong> are constant values that are not associated with an identifier</li>
</ul>
<h2 id="three-types-of-named-constants">Three types of named constants</h2>
<p>There are three ways to define a named constant in C++:</p>
<ul>
<li>Constant variables (most common)</li>
<li>Object-like macros with substitution text</li>
<li>Enumerated constants (covered later)</li>
</ul>
<p>In the first way, namely constant variables, please do remember that <strong>constant variables must be initialized</strong>. Parameters of a function can also be declared constant, but only necessary when passed by reference or pointer/address. When passed by value, a parameter doesn&rsquo;t need to be declared constant to avoid the risk of being changed. Function return value can also be declared constant, but only when it&rsquo;s not a fundamental type. For fundamental type return values, the <code>const</code> qualifier is ignored.</p>
<p>In the second way, we can define a constant via macro e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define MY_NAME &#34;Allen&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;My names is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> MY_NAME <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are, however, at least three major reasons why people prefer the first method over using preprocessor macros:</p>
<ul>
<li>Macros don&rsquo;t follow normal C++ scoping rules - once defined they&rsquo;re there forever and cannot be replaced</li>
<li>It&rsquo;s harder to debug code with macros</li>
<li>Macro substitution behaves differently than everything else in C++ and thus may cause inadvertent mistakes easily</li>
</ul>
<h2 id="type-qualifiers">Type qualifiers</h2>
<p>We have known that <code>const</code> is a type qualifier. As a matter of fact, in C++ there are only two type qualifiers as of C++23, namely <code>const</code> and <code>volatile</code>. Latter is rarely used and is there to tell the compiler that an object may change its value at any time. This disables certain types of optimizations, in exchange.</p>
<h2 id="the-as-if-rule">The <strong>as-if</strong> rule</h2>
<p>In C++, compilers are given a lot of leeway to optimize programs. The <strong>as-if</strong> rule says that the compiler can modify a program however it likes in order to optimize the performance. The only exception is that unnecessary calls to a copy constructor can be elided even if those copy constructors do have observable behavior.</p>
<p>For example, the following program can be optimized step by step:</p>
<p>Version 0 (original program):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">3</span> <span style="font-weight:bold">+</span> <span style="color:#099">4</span> };
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Version 1:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">7</span> };
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Version 2:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">7</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="compile-time-and-runtime-constants">Compile-time and runtime constants</h2>
<p>Constants that are fixed at compile-time are called <strong>compile-time constants</strong> (like above). Constant variables that are only initialized at runtime are called <strong>runtime</strong> constants (see below).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">get_number</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter a number: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> y;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">3</span>};  <span style="color:#998;font-style:italic">// x is compile-time constant
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> y{get_number()};  <span style="color:#998;font-style:italic">// y is runtime constant
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> z{x <span style="font-weight:bold">+</span> y};  <span style="color:#998;font-style:italic">// z is runtime constant
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compile-time constants help optimization, but runtime constants are there just to keep the objects&rsquo; values are not changed.</p>
<h2 id="the-constexpr-keyword">The <code>constexpr</code> keyword</h2>
<p>It&rsquo;s sometimes hard to tell whether a variable will end up being compile-time constant or runtime constant, for example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5</span> };       <span style="color:#998;font-style:italic">// not const at all
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> y { x }; <span style="color:#998;font-style:italic">// obviously a runtime const (since initializer is non-const)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> z { <span style="color:#099">5</span> }; <span style="color:#998;font-style:italic">// obviously a compile-time const (since initializer is a constant expression)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> w { getValue() }; <span style="color:#998;font-style:italic">// not obvious whether this is a runtime or compile-time const
</span></span></span></code></pre></div><p>Notice that, depending on how the function <code>getValue</code> is defined, <code>w</code> actually can be compile-time constant here - we have no idea, Fortunately, we can enlist the compiler&rsquo;s help to ensure we get a compile-time constant when we desire so, simply by using the <code>constexpr</code> instead of <code>const</code>. When a variable is not compile-time constant yet we insist to use <code>constexpr</code>, there will be a compile error. As a result, the best practice is to use <code>constexpr</code> for any variable that should not be modifiable after initialization and whose initializer is known at compile-time.</p>
<p>There are, however, some types that are currently not compatible with <code>constexpr</code> keyword, including <code>std::string</code>, <code>std::vector</code> and other types that use dynamic memory allocation. For those objects we need to use <code>const</code> instead. Also, function parameters cannot be declared as <code>constexpr</code> as <code>constexpr</code> objects must be initialized with a compile-time constant.</p>
<h2 id="constant-folding">Constant folding</h2>
<p>Example 1:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">3</span> <span style="font-weight:bold">+</span> <span style="color:#099">4</span> }; <span style="color:#998;font-style:italic">// 3 + 4 is a constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// this is a runtime expression
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Example 2:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">3</span> <span style="font-weight:bold">+</span> <span style="color:#099">4</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// this is a runtime expression
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In example 1 above, the variable <code>x</code> is a constant variable with its value initialized at compile-time, and as a result, the program will be optimized and consider <code>x</code> a compile-time constant. In example 2, <code>3 + 4</code> is not a constant expression, but because of an optimization process in C++ called <strong>constant folding</strong>, it&rsquo;s still optimized at compile-time.</p>
<h2 id="literal-suffixes">Literal suffixes</h2>
<table>
<thead>
<tr>
<th>Data type</th>
<th>Suffix</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>integral</td>
<td><code>U</code></td>
<td>unsigned int</td>
</tr>
<tr>
<td></td>
<td><code>L</code></td>
<td>long</td>
</tr>
<tr>
<td></td>
<td><code>UL</code></td>
<td>unsigned long</td>
</tr>
<tr>
<td></td>
<td><code>LL</code></td>
<td>long long</td>
</tr>
<tr>
<td></td>
<td><code>ULL</code></td>
<td>unsigned long long</td>
</tr>
<tr>
<td></td>
<td><code>Z</code></td>
<td>the signed version of <code>std::size_t</code> (C++23)</td>
</tr>
<tr>
<td></td>
<td><code>UZ</code></td>
<td><code>std::size_t</code> (C++23)</td>
</tr>
<tr>
<td>floating point</td>
<td><code>F</code></td>
<td>float</td>
</tr>
<tr>
<td></td>
<td><code>L</code></td>
<td>long double</td>
</tr>
<tr>
<td>string</td>
<td><code>S</code></td>
<td><code>std::string</code></td>
</tr>
<tr>
<td></td>
<td><code>SV</code></td>
<td><code>std::string_view</code></td>
</tr>
</tbody>
</table>
<p>You may find lower-case suffixes accepted as well but they&rsquo;re not recommended as lower-case <code>l</code> looks similar <code>1</code>. Another thing to notice is that string literals in C++ are essentially C-style arrays of <code>char</code> with <strong>an extra null terminator</strong>. These C-style string literals are objects that are created at the start of the program and guaranteed to exist for the entirety of the program. In contrast, <code>std::string</code> and <code>std::string_view</code> create temporary objects that have to be used immediately, as they&rsquo;re destroyed at the end of the full expression in which they&rsquo;re created.</p>
<h2 id="magic-numbers">Magic numbers</h2>
<p>Magic numbers are not recommended usually.</p>
<h2 id="numeral-systems-decimal-binary-hexadecimal-and-octal">Numeral systems: decimal, binary, hexadecimal and octal</h2>
<p>By default C++ integers are decimal numbers. Including decimals, there are 4 main numeral systems available in C++, which are decimal (base 10), binary (base 2), hexadecimal (base 16) and octal (base 8).</p>
<table>
<thead>
<tr>
<th>Decimal</th>
<th>Binary</th>
<th>Hexadecimal</th>
<th>Octal</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>8</td>
<td>10</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9</td>
<td>11</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
<td>A</td>
<td>12</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
<td>B</td>
<td>13</td>
</tr>
<tr>
<td>12</td>
<td>1100</td>
<td>C</td>
<td>14</td>
</tr>
<tr>
<td>13</td>
<td>1101</td>
<td>D</td>
<td>15</td>
</tr>
<tr>
<td>14</td>
<td>1110</td>
<td>E</td>
<td>16</td>
</tr>
<tr>
<td>15</td>
<td>1111</td>
<td>F</td>
<td>17</td>
</tr>
<tr>
<td>16</td>
<td>10000</td>
<td>10</td>
<td>20</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>
<p>To use an octal literal, prefix the literal number with a <code>0</code> (zero):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">012</span>};  <span style="color:#998;font-style:italic">// octal 12
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the output would be <code>10</code>, as numbers are output in decimal by default.</p>
<p>To use a hexadecimal literal, prefix your literal number with a <code>0x</code> (zero x):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">0xF</span>};  <span style="color:#998;font-style:italic">// hex F
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the output would be <code>15</code>. One digit of hexadecimal numbers represent 16=2^4 possible values, and thus two makes a full byte. A 32-bit integer, as a result, can be represented by eight hexadecimal digits concisely.</p>
<p>To use a binary literal, prefix your literal number with a <code>0b</code> (zero b):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x1{<span style="color:#099">0b1</span>};  <span style="color:#998;font-style:italic">// binary 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x2{<span style="color:#099">0b11110001</span>};  <span style="color:#998;font-style:italic">// binary 11110001
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x3{<span style="color:#099">0b1111&#39;0001</span>};  <span style="color:#998;font-style:italic">// binary 11110001 with a quotation mark as visual separator
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x1 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> x2 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> x3 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the output is <code>1 241 241</code>. Notice how we used a single quotation mark as separator - this is also supported for other numeral systems e.g. a long decimal integer.</p>
<p>In order to print the values in other numeral systems than the current one, we can use <code>std::dec</code>, <code>std::oct</code>, <code>std::hex</code> manipulators:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">12</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// default is dec
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>hex <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// now hex
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// still hex
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>oct <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// now oct
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// still oct
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>dec <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// now back to dec
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// still dec
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you may have guessed, outputting values in binary is a little harder than the rest three. We need to use a type called <code>std::bitset</code> in C++ STL (specifically, the <code>&lt;bitset&gt;</code> header) that gets the job done:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;bitset&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>bitset<span style="font-weight:bold">&lt;</span><span style="color:#099">8</span><span style="font-weight:bold">&gt;</span> x1{ob1100<span style="color:#a61717;background-color:#e3d2d2">&#39;</span><span style="color:#099">0101</span>};  <span style="color:#998;font-style:italic">// an 8-digit binary number
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>bitset<span style="font-weight:bold">&lt;</span><span style="color:#099">8</span><span style="font-weight:bold">&gt;</span> x2{oxC5};  <span style="color:#998;font-style:italic">// also 8-bit
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x1 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> x2 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// printing the variables
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>bitset<span style="font-weight:bold">&lt;</span><span style="color:#099">4</span><span style="font-weight:bold">&gt;</span>{<span style="color:#099">0b1010</span>} <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// printing a literal
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There is an even better solution in C++20 and C++23, where we can use the <code>&lt;format&gt;</code> header and <code>&lt;print&gt;</code> header correspondingly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;format&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// c++20
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;print&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// c++23
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>format(<span style="color:#b84">&#34;{:b}</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>, <span style="color:#099">0b1010</span>);  <span style="color:#998;font-style:italic">// c++20
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>format(<span style="color:#b84">&#34;{:#b}</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>, <span style="color:#099">0b1010</span>);  <span style="color:#998;font-style:italic">// c++20
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>print(<span style="color:#b84">&#34;{:b} {:#b}&#34;</span>, <span style="color:#099">0b1010</span>, <span style="color:#099">0b1010</span>);  <span style="color:#998;font-style:italic">// c++23
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="conditional-statement">Conditional statement</h2>
<p>The conditional statement is defined in the form <code>condition ? statement1 : statement2</code>. Remember to parenthesize the entire conditional statement to avoid unexpected behavior. Also, remember that statement1 and statement2 must match in types, namely the following won&rsquo;t compile:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> (x <span style="font-weight:bold">!=</span> <span style="color:#099">5</span> <span style="font-weight:bold">?</span> x : <span style="color:#b84">&#34;x is 5&#34;</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="inline-functions-and-variables">Inline functions and variables</h2>
<p>Every time a function is called, there is a certain amount of performance overhead that occurs, specifically:</p>
<ul>
<li>The CPU must store the address of the current instruction it is executing (so that it knows where to return)</li>
<li>The parameters must be instantiated and then initialized</li>
<li>The execution path must then jump to the code in the function body</li>
<li>Finally, the program need to jump back to the location of the function call and copy the return value to the main scope</li>
</ul>
<p>This overhead is significant for small function with frequent calls. Fortunately, in C++ the compiler has a trick that can avoid such overhead: <strong>inline expansion</strong>. This is a process where <strong>a function call is replaced by the code from the called function&rsquo;s definition</strong>. Inline expansion, however, doesn&rsquo;t guarantee performance improvements as there&rsquo;s a tradeoff between removal of the functional overhead vs the cost of a larger executable.</p>
<p>There used to be an <code>inline</code> keyword that suggests a function is inline for compilers. However, the keyword is no longer used and in fact:</p>
<ul>
<li>Using <code>inline</code> to request inline expansion might harm performance</li>
<li>The <code>inline</code> keyword is now just a hint and the compilers simply ignore them now - they&rsquo;ll decide whether to inline expand a function no matter if it has an <code>inline</code> keyword or not</li>
<li>The <code>inline</code> keyword is defined at the wrong level of granularity, as the keyword goes with the function definition but the expansion actually happens only per function call</li>
</ul>
<p>Inline variables, on the other hand, is a modern design of C++ that allows multiple definitions of the same variable identifier across multiple header files. The following, particularly, are implicitly inline:</p>
<ul>
<li>Functions defined inside a class, struct or union type definition (covered later)</li>
<li><code>constexpr</code> / <code>consteval</code> functions (covered later)</li>
<li>Functions implicitly instantiated from function templates (covered later)</li>
<li><code>constexpr</code> static variables (but not <code>constexpr</code> non-static variables)</li>
</ul>
<h2 id="constexpr-and-consteval"><code>constexpr</code> and <code>consteval</code></h2>
<p>Remember we can use <code>constexpr</code> variable to optimize programs for compile-time evaluation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> (x <span style="font-weight:bold">&gt;</span> y <span style="font-weight:bold">?</span> x : y) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is greater!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, if we replace the conditional statement by a function, the same program won&rsquo;t enjoy the compile-time optimization and that means tradeoff of performance for modularity benefits. This isn&rsquo;t ideal. We can instead declare functions as <code>constexpr</code> so that they can be evaluated at compile-time:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">greater</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&gt;</span> y <span style="font-weight:bold">?</span> x : y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> g{greater(x, y)};  <span style="color:#998;font-style:italic">// evaluated at compile-time
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> g <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is greater!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It is worth noting that, despite the example above, <code>constexpr</code> doesn&rsquo;t <strong>guarantee</strong> the compile-time evaluation, but instead just make the function <strong>eligible</strong> for compile-time evaluation. In the following example, because <code>x</code> and <code>y</code> are not <code>constexpr</code>, the function is still evaluated at runtime:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">greater</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&gt;</span> y <span style="font-weight:bold">?</span> x : y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> greater(x, y) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is greater!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Prior to C++20, there were no standard language tools available to test whether a function call is evaluating at compile-time or runtime. In C++20, <code>std::is_constant_evaluated</code> function defined in <code>&lt;type_traits&gt;</code> header gives a boolean indication whether the function call is executing in a constant context:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;type_traits&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">greater</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (std<span style="font-weight:bold">::</span>is_constant_evaluated()) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;greater(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;) is being&#34;</span>
</span></span><span style="display:flex;"><span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; evaluated at compile-time!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;greater(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;) is being&#34;</span>
</span></span><span style="display:flex;"><span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; evaluated at runtime!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&gt;</span> y <span style="font-weight:bold">?</span> x : y);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In addition to testing, we can also <strong>force</strong> a function call to be evaluated at compile-time by ensuring the return value is used where a constant expression is required. This, however, need to be done on a per-call basis and thus can be seen tedious. In C++20, there is a better workaround to enforce this - <code>consteval</code>, which is used to indicated that a function <strong>must</strong> be evaluated at compile-time, otherwise a compile error will result. Such functions are called <strong>immediate functions</strong>. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">consteval</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">greater</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {  <span style="color:#998;font-style:italic">// consteval! not constexpr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&gt;</span> y <span style="font-weight:bold">?</span> x : y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> g {greater(<span style="color:#099">5</span>, <span style="color:#099">6</span>)}; <span style="color:#998;font-style:italic">// evaluated at compile-time because return goes into constexpr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> g <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> greater(<span style="color:#099">5</span>, <span style="color:#099">6</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// still at compile-time, guaranteed!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> greater(x, <span style="color:#099">6</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// compile error!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The downside of <code>consteval</code> keyword is that it <strong>forces</strong> the function to be evaluated at compile-time, which in other words means the function can no longer be evaluated at runtime even if we want to. To solve this problem, we can define a helper function using abbreviated function template in C++20 and <code>auto</code> type (no need to fully understand at this stage)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">consteval</span> <span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">eval_at_compile_time</span>(<span style="font-weight:bold">auto</span> value) {  <span style="color:#998;font-style:italic">// consteval
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> value;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">greater</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {  <span style="color:#998;font-style:italic">// constexpr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&gt;</span> y <span style="font-weight:bold">?</span> x : y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> greater(<span style="color:#099">5</span>, <span style="color:#099">6</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// runtime / compile-time -&gt; we don&#39;t have full control
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> eval_at_compile_time(greater(<span style="color:#099">5</span>, <span style="color:#099">6</span>)) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// guaranteed compile-time
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> greater(x, <span style="color:#099">6</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// runtime, no error!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="input-with-stdstring">Input with <code>std::string</code></h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter your full name: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string name{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> name; <span style="color:#998;font-style:italic">// this won&#39;t work as expected since std::cin breaks on whitespace
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter your favorite color: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string color{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> color;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Your name is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and your favorite color is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> color <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The result from a sample run of the above program gives</p>
<pre tabindex="0"><code>Enter your full name: John Doe
Enter your favorite color: Your name is John and your favorite color is Doe
</code></pre><p>This is because <code>std::cin</code> breaks on whitespaces and thus <code>John</code> and <code>Doe</code> are separately passed to <code>name</code> and <code>color</code> strings. To remedy this issue, we need to use <code>std::getline</code> function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter your full name: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string name{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>getline(std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> std<span style="font-weight:bold">::</span>ws, name); <span style="color:#998;font-style:italic">// read a full line
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter your favorite color: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string color{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>getline(std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> std<span style="font-weight:bold">::</span>ws, color);  <span style="color:#998;font-style:italic">// read a full line
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Your name is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and your favorite color is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> color <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and this time the output is</p>
<pre tabindex="0"><code>Enter your full name: John Doe
Enter your favorite color: blue
Your name is John Doe and your favorite color is blue
</code></pre><p>What is <code>std::ws</code>? It&rsquo;s an input manipulator that tells <code>std::cin</code> to ignore any leading whitespace before extraction. Noticing that whitespace characters include spaces, tabs and newlines, we know the following program won&rsquo;t work as expected:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Pick 1 or 2: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> choice{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> choice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Now enter your name: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string name{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>getline(std<span style="font-weight:bold">::</span>cin, name); <span style="color:#998;font-style:italic">// note: no std::ws here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, you picked &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> choice <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>Pick 1 or 2: 2
Now enter your name: Hello, , you picked 2
</code></pre><p>as we entered only <code>2\n</code>, where <code>2</code> was passed to <code>choice</code> and <code>\n</code> passed to the <code>std::getline</code> function. The function notices that there&rsquo;s nothing before end of the line and thus passed empty string to <code>name</code>. The best practice is, therefore, to keep using <code>std::ws</code> for every <code>std::getline</code>.</p>
<h2 id="the-length-of-strings">The length of strings</h2>
<p>To get the length of a <code>std::string</code> variable, we can</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string name{ <span style="color:#b84">&#34;Alex&#34;</span> };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; has &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> name.length() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; characters</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice the return type is not a regular integer but unsigned integral of type <code>size_t</code>. If you want to use this integer for following computation, it&rsquo;s best to convert the type right away:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> length { <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(name.length()) };
</span></span></code></pre></div><p>In C++20, there&rsquo;s an easier way to get size of strings in signed integral type:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string name{ <span style="color:#b84">&#34;Alex&#34;</span> };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; has &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>ssize(name) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; characters</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="initializing-a-stdstring-is-expensive">Initializing a <code>std::string</code> is expensive</h2>
<p>&hellip;and thus don&rsquo;t randomly initialize duplicate string variables, or pass them as values into functions. However, it&rsquo;s okay to return a string by value when the expression of the return statement resolves to any of the following</p>
<ul>
<li>A local variable of type <code>std::string</code></li>
<li>A <code>std::string</code> that has been returned by value from a function call or operator</li>
<li>A <code>std::string</code> that is created as part of the return statement</li>
</ul>
<p>Because of scope and memory concerns. <code>std::string</code> may also be returned by (const) reference, which will be covered later.</p>
<p>To solve this problem, we have <code>std::string_view</code> (C++17). Instead of quickly copying e.g. a C-string to a new <code>std::string</code> and destroy it right away, we can create a readonly access to the original C-string and do whatever we want (as long as it&rsquo;s readonly, like printing)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_string</span>(std<span style="font-weight:bold">::</span>string_view str) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> str <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view str{<span style="color:#b84">&#34;Hello world&#34;</span>};
</span></span><span style="display:flex;"><span>    print_string(str);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that implicit conversion from <code>std::string_view</code> to a <code>std::string</code> is not allowed and will give a compile error. However, explicitly initializing a <code>std::string</code> with a <code>std::string_view</code> is possible.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_string</span>(std<span style="font-weight:bold">::</span>string str) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> str <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view str{<span style="color:#b84">&#34;Hello world&#34;</span>};
</span></span><span style="display:flex;"><span>    print_string(str);  <span style="color:#998;font-style:italic">// will throw a compile error for implicit conversion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string str2{str};  <span style="color:#998;font-style:italic">// okay: explicit initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_string(str2);  <span style="color:#998;font-style:italic">// okay
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_string(<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&gt;</span>(str));  <span style="color:#998;font-style:italic">// okay: explicit conversion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Assignment, regardless whatever variable a <code>std::string_view</code> was originally viewing, makes it view another variable and that&rsquo;s all. It doesn&rsquo;t change anything and the content being viewed remains readonly.</p>
<p>Also, unlike <code>std::string</code>, <code>std::string_view</code> supports <code>constexpr</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>string_view s{ <span style="color:#b84">&#34;Hello, world!&#34;</span> }; <span style="color:#998;font-style:italic">// s is a string symbolic constant
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> s <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// s will be replaced with &#34;Hello, world!&#34; at compile-time
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That being said, it&rsquo;s best to just use <code>std::string_view</code> as a readonly function parameter instead of general variable in most cases. Specifically, when the underlying object is destroyed, the viewer gives undefined behavior (so don&rsquo;t return a <code>std::string_view</code> from function in most cases); when the underlying object is modified, the viewer is invalidated and again, may give undefined behavior (every time the underlying object is modified, you need to revalidate the viewer with an assignment).</p>
<p>Additionally, <code>std::string_view</code> can return substrings by <code>.remove_prefix(#)</code> and <code>.remove_suffix(#)</code> with <code>#</code> being the number of characters to remove from the view.</p>
<h1 id="operators-1">Operators</h1>
<p>There are two important properties of operators:</p>
<ul>
<li>Precedence: how much priority an operator is given</li>
<li>Associativity: given a chain of operators under the same priority, how should we evaluate them, left-to-right or right-to-left?</li>
</ul>
<p>The following is an exhaustive list of operators with their precedence and associativity:</p>
<table>
<thead>
<tr>
<th>Prec/Asso</th>
<th>Operator</th>
<th>Description</th>
<th>Pattern</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 / LR</td>
<td><code>::</code></td>
<td>Global scope (unary)</td>
<td><code>::name</code></td>
</tr>
<tr>
<td></td>
<td><code>::</code></td>
<td>Namespace scope (binary)</td>
<td><code>class_name::member_name</code></td>
</tr>
<tr>
<td>2 / LR</td>
<td><code>()</code></td>
<td>Parentheses</td>
<td><code>(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>()</code></td>
<td>Function call</td>
<td><code>function_name(parameters)</code></td>
</tr>
<tr>
<td></td>
<td><code>()</code></td>
<td>Initialization</td>
<td><code>type_name(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>{}</code></td>
<td>List initialization (C++11)</td>
<td><code>type_name{expression}</code></td>
</tr>
<tr>
<td></td>
<td><code>type()</code></td>
<td>Functional cast</td>
<td><code>new_type(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>type{}</code></td>
<td>Functional cast (C++11)</td>
<td><code>new_type{expression}</code></td>
</tr>
<tr>
<td></td>
<td><code>[]</code></td>
<td>Array subscript</td>
<td><code>pointer[expression]</code></td>
</tr>
<tr>
<td></td>
<td><code>.</code></td>
<td>Member access from object</td>
<td><code>object.member_name</code></td>
</tr>
<tr>
<td></td>
<td><code>-&gt;</code></td>
<td>Member access from object pointer</td>
<td><code>object_pointer-&gt;member_name</code></td>
</tr>
<tr>
<td></td>
<td><code>++</code></td>
<td>Post-increment</td>
<td><code>lvalue++</code></td>
</tr>
<tr>
<td></td>
<td><code>--</code></td>
<td>Post-decrement</td>
<td><code>lvalue--</code></td>
</tr>
<tr>
<td></td>
<td><code>typeid</code></td>
<td>Run-time type information</td>
<td><code>typeid(type)</code> or <code>typeid(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>const_cast</code></td>
<td>Cast away const</td>
<td><code>const_cast&lt;type&gt;(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>dynamic_cast</code></td>
<td>Run-time type-checked Cast</td>
<td><code>dynamic_cast&lt;type&gt;(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>reinterpret_cast</code></td>
<td>Cast on type to another</td>
<td><code>reinterpret_cast&lt;type&gt;(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>static_cast</code></td>
<td>Compile-time type-checked cast</td>
<td><code>static_cast&lt;type&gt;(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>sizeof...</code></td>
<td>Get parameter pack size</td>
<td><code>sizeof...(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>noexcept</code></td>
<td>Compile-time exception check</td>
<td><code>noexcept(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>alignof</code></td>
<td>Get type alignment</td>
<td><code>alignof(type)</code></td>
</tr>
<tr>
<td>3 / RL</td>
<td><code>+</code></td>
<td>Unary plus</td>
<td><code>+expression</code></td>
</tr>
<tr>
<td></td>
<td><code>-</code></td>
<td>Unary minus</td>
<td><code>-expression</code></td>
</tr>
<tr>
<td></td>
<td><code>++</code></td>
<td>Pre-increment</td>
<td><code>++lvalue</code></td>
</tr>
<tr>
<td></td>
<td><code>--</code></td>
<td>Pre-decrement</td>
<td><code>--lvalue</code></td>
</tr>
<tr>
<td></td>
<td><code>!</code></td>
<td>Logical NOT</td>
<td><code>!expression</code></td>
</tr>
<tr>
<td></td>
<td><code>not</code></td>
<td>Logical NOT</td>
<td><code>not expression</code></td>
</tr>
<tr>
<td></td>
<td><code>~</code></td>
<td>Bitwise NOT</td>
<td><code>~expression</code></td>
</tr>
<tr>
<td></td>
<td><code>(type)</code></td>
<td>C-style case</td>
<td><code>(new_type)expression</code></td>
</tr>
<tr>
<td></td>
<td><code>sizeof</code></td>
<td>Size in bytes</td>
<td><code>sizeof(type)</code> or <code>sizeof(expression)</code></td>
</tr>
<tr>
<td></td>
<td><code>co_await</code></td>
<td>Await asynchronous call (C++20)</td>
<td><code>co_await expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&amp;</code></td>
<td>Address of</td>
<td><code>&amp;lvalue</code></td>
</tr>
<tr>
<td></td>
<td><code>*</code></td>
<td>Dereference</td>
<td><code>*expression</code></td>
</tr>
<tr>
<td></td>
<td><code>new</code></td>
<td>Dynamic memory allocation</td>
<td><code>new type_name</code></td>
</tr>
<tr>
<td></td>
<td><code>new[]</code></td>
<td>Dynamic array allocation</td>
<td><code>new type_name[expression]</code></td>
</tr>
<tr>
<td></td>
<td><code>delete</code></td>
<td>Dynamic memory deletion</td>
<td><code>delete pointer</code></td>
</tr>
<tr>
<td></td>
<td><code>delete[]</code></td>
<td>Dynamic array deletion</td>
<td><code>delete[] pointer</code></td>
</tr>
<tr>
<td>4 / LR</td>
<td><code>-&gt;*</code></td>
<td>Member pointer selector</td>
<td><code>object_pointer-&gt;*pointer_to_member</code></td>
</tr>
<tr>
<td></td>
<td><code>.*</code></td>
<td>Member object selector</td>
<td><code>object.*pointer_to_member</code></td>
</tr>
<tr>
<td>5 / LR</td>
<td><code>*</code></td>
<td>Multiplication</td>
<td><code>expression * expression</code></td>
</tr>
<tr>
<td></td>
<td><code>/</code></td>
<td>Division</td>
<td><code>expression / expression</code></td>
</tr>
<tr>
<td></td>
<td><code>%</code></td>
<td>Remainder</td>
<td><code>expression % expression</code></td>
</tr>
<tr>
<td>6 / LR</td>
<td><code>+</code></td>
<td>Addition</td>
<td><code>expression + expression</code></td>
</tr>
<tr>
<td></td>
<td><code>-</code></td>
<td>Subtraction</td>
<td><code>expression - expression</code></td>
</tr>
<tr>
<td>7 / LR</td>
<td><code>&lt;&lt;</code></td>
<td>Bitwise shift left / insertion</td>
<td><code>expression &lt;&lt; expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&gt;&gt;</code></td>
<td>Bitwise shift right / extraction</td>
<td><code>expression &gt;&gt; expression</code></td>
</tr>
<tr>
<td>8 / LR</td>
<td><code>&lt;=&gt;</code></td>
<td>Three-way comparison (C++20)</td>
<td><code>expression &lt;=&gt; expression</code></td>
</tr>
<tr>
<td>9 / LR</td>
<td><code>&lt;</code></td>
<td>Comparison less than</td>
<td><code>expression &lt; expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&lt;=</code></td>
<td>Comparison less than or equals</td>
<td><code>expression &lt;= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&gt;</code></td>
<td>Comparison greater than</td>
<td><code>expression &gt; expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&gt;=</code></td>
<td>Comparison greater than or equals</td>
<td><code>expression &gt;= expression</code></td>
</tr>
<tr>
<td>10 / LR</td>
<td><code>==</code></td>
<td>Equality</td>
<td><code>expression == expression</code></td>
</tr>
<tr>
<td></td>
<td><code>!=</code></td>
<td>Inequality</td>
<td><code>expression != expression</code></td>
</tr>
<tr>
<td>11 / LR</td>
<td><code>&amp;</code></td>
<td>Bitwise AND</td>
<td><code>expression &amp; expression</code></td>
</tr>
<tr>
<td>12 / LR</td>
<td><code>^</code></td>
<td>Bitwise XOR</td>
<td><code>expression ^ expression</code></td>
</tr>
<tr>
<td>13 / LR</td>
<td><code>|</code></td>
<td>Bitwise OR</td>
<td><code>expression | expression</code></td>
</tr>
<tr>
<td>14 / LR</td>
<td><code>&amp;&amp;</code></td>
<td>Logical AND</td>
<td><code>expression &amp;&amp; expression</code></td>
</tr>
<tr>
<td></td>
<td><code>and</code></td>
<td>Logical AND</td>
<td><code>expression and expression</code></td>
</tr>
<tr>
<td>15 / LR</td>
<td><code>||</code></td>
<td>Logical OR</td>
<td><code>expression || expression</code></td>
</tr>
<tr>
<td></td>
<td><code>or</code></td>
<td>Logical OR</td>
<td><code>expression or expression</code></td>
</tr>
<tr>
<td>16 / RL</td>
<td><code>throw</code></td>
<td>Throw expression</td>
<td><code>throw expression</code></td>
</tr>
<tr>
<td></td>
<td><code>co_yield</code></td>
<td>Yield expression (C++20)</td>
<td><code>co_yield expression</code></td>
</tr>
<tr>
<td></td>
<td><code>?:</code></td>
<td>Conditional</td>
<td><code>expression ? expression : expression</code></td>
</tr>
<tr>
<td></td>
<td><code>=</code></td>
<td>Assignment</td>
<td><code>lvalue = expression</code></td>
</tr>
<tr>
<td></td>
<td><code>*=</code></td>
<td>Multiplication assignment</td>
<td><code>lvalue *= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>/=</code></td>
<td>Division assignment</td>
<td><code>lvalue /= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>%=</code></td>
<td>Remainder assignment</td>
<td><code>lvalue %= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>+=</code></td>
<td>Addition assignment</td>
<td><code>lvalue += expression</code></td>
</tr>
<tr>
<td></td>
<td><code>-=</code></td>
<td>Subtraction assignment</td>
<td><code>lvalue -= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&lt;&lt;=</code></td>
<td>Bitwise shift left assignment</td>
<td><code>lvalue &lt;&lt;= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&gt;&gt;=</code></td>
<td>Bitwise shift right assignment</td>
<td><code>lvalue &gt;&gt;= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>&amp;=</code></td>
<td>Bitwise AND assignment</td>
<td><code>lvalue &amp;= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>|=</code></td>
<td>Bitwise OR assignment</td>
<td><code>lvalue |= expression</code></td>
</tr>
<tr>
<td></td>
<td><code>^=</code></td>
<td>Bitwise XOR assignment</td>
<td><code>lvalue ^= expression</code></td>
</tr>
<tr>
<td>17 / LR</td>
<td><code>,</code></td>
<td>Comma operator</td>
<td><code>expression, expression</code></td>
</tr>
</tbody>
</table>
<h2 id="remainder-and-exponent-operators">Remainder and exponent operators</h2>
<p>The remainder operator in C++ is <code>operator%</code> which takes the sign of the first operand. The exponent operator is provided by the <code>&lt;cmath&gt;</code> header.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cmath&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">21</span> <span style="font-weight:bold">%</span> <span style="color:#099">4</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">-</span><span style="color:#099">21</span> <span style="font-weight:bold">%</span> <span style="color:#099">4</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// the remainder&#39;s sign follows that of the first operand
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>pow(<span style="color:#099">3</span>, <span style="color:#099">4</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to avoid overflow, we sometimes can manually check the limit of the integral types:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for assert
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::int64_t
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;limits&gt;</span><span style="color:#999;font-weight:bold">   </span><span style="color:#998;font-style:italic">// for std::numeric_limits
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int64_t</span> max_int64 <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>numeric_limits<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int64_t</span><span style="font-weight:bold">&gt;::</span>max();
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int64_t</span> min_int64 <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>numeric_limits<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int64_t</span><span style="font-weight:bold">&gt;::</span>min();
</span></span><span style="display:flex;"><span>    assert((<span style="color:#099">10</span> <span style="font-weight:bold">&gt;</span> <span style="color:#099">9</span>) <span style="font-weight:bold">&amp;&amp;</span> <span style="color:#b84">&#34;assert message&#34;</span>);  <span style="color:#998;font-style:italic">// just showing how assert() works
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> max_int64 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> min_int64 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="incrementdecrement-operators">Increment/decrement operators</h2>
<p>There are 4 increment/decrement operators</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Form</th>
<th>operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix increment</td>
<td><code>++x</code></td>
<td>Increment <code>x</code>, then return <code>x</code></td>
</tr>
<tr>
<td>Prefix decrement</td>
<td><code>--x</code></td>
<td>Decrement <code>x</code>, then return <code>x</code></td>
</tr>
<tr>
<td>Postfix increment</td>
<td><code>x++</code></td>
<td>Copy <code>x</code>, then increment <code>x</code>, then return the copy</td>
</tr>
<tr>
<td>Postfix decrement</td>
<td><code>x--</code></td>
<td>Copy <code>x</code>, then decrement <code>x</code>, then return the copy</td>
</tr>
</tbody>
</table>
<p>Best practice is to use the prefix versions most of the time as they are more performant (no copy) and less surprising (thus to cause bugs). For certain cases, avoiding increment/decrement operators is recommended even:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>x <span style="font-weight:bold">+</span> <span style="font-weight:bold">++</span>x
</span></span></code></pre></div><p>The above code evaluates as <code>2 + 2</code> in Visual Studio and GCC, but <code>1 + 2</code> in Clang. To avoid confusion and potential bugs, we should altogether just avoid such coding.</p>
<h2 id="the-comma-operator">The comma operator</h2>
<p>The comma operator works very differently as in Python, thus we&rsquo;re paying extra attention to it. The formal definition of operation <code>x,y</code> is &ldquo;evaluate <code>x</code> and then <code>y</code>, then return the value of <code>y</code>&rdquo;. For example, the following code will print <code>3</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> (<span style="font-weight:bold">++</span>x, <span style="font-weight:bold">++</span>y) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Even worse, check these two lines:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>z <span style="font-weight:bold">=</span> (a, b);
</span></span><span style="display:flex;"><span>z <span style="font-weight:bold">=</span> a, b;
</span></span></code></pre></div><p>The first line is &ldquo;evaluate <code>a</code> first, then evaluate <code>b</code>, and assign <code>b</code> to <code>z</code>&rdquo;. The second line is &ldquo;assign <code>a</code> to <code>z</code>, then evaluate <code>b</code> and discard it right away&rdquo;.</p>
<p>As a result, the best practice is DON&rsquo;T USE COMMA OPERATORS AT ALL.</p>
<h2 id="relational-operators-and-floating-point-comparison">Relational operators and floating point comparison</h2>
<p>The first and third lines below are redundant and should be replaced by the second and last lines instead:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (b1 <span style="font-weight:bold">==</span> <span style="color:#999">true</span>) {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">if</span> (b1) {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">if</span> (b1 <span style="font-weight:bold">==</span> <span style="color:#999">false</span>) {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>b1) {};
</span></span></code></pre></div><p>The following will print <code>d1 &gt; d2</code> despite mathematically <code>d1</code> and <code>d2</code> are equal, and this is because of precision handling in floating points:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> d1{ <span style="color:#099">100.0</span> <span style="font-weight:bold">-</span> <span style="color:#099">99.99</span> }; <span style="color:#998;font-style:italic">// should equal 0.01 mathematically
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">double</span> d2{ <span style="color:#099">10.0</span> <span style="font-weight:bold">-</span> <span style="color:#099">9.99</span> }; <span style="color:#998;font-style:italic">// should equal 0.01 mathematically
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (d1 <span style="font-weight:bold">==</span> d2)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;d1 == d2&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span> <span style="font-weight:bold">if</span> (d1 <span style="font-weight:bold">&gt;</span> d2)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;d1 &gt; d2&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span> <span style="font-weight:bold">if</span> (d1 <span style="font-weight:bold">&lt;</span> d2)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;d1 &lt; d2&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As a result, floating point comparison using relational operators can be dangerous sometimes. Instead of using these native operators, we can define our own &ldquo;approximately equal&rdquo; function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// C++23 version -&gt; so that std::abs is constexpr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// for std::max
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cmath&gt;</span><span style="color:#999;font-weight:bold">     </span><span style="color:#998;font-style:italic">// for std::abs (constexpr in C++23)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">approximatelyEqualRel</span>(<span style="color:#458;font-weight:bold">double</span> a, <span style="color:#458;font-weight:bold">double</span> b, <span style="color:#458;font-weight:bold">double</span> relEpsilon) {
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> (std<span style="font-weight:bold">::</span>abs(a <span style="font-weight:bold">-</span> b) <span style="font-weight:bold">&lt;=</span> (std<span style="font-weight:bold">::</span>max(std<span style="font-weight:bold">::</span>abs(a), std<span style="font-weight:bold">::</span>abs(b)) <span style="font-weight:bold">*</span> relEpsilon));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">approximatelyEqualAbsRel</span>(<span style="color:#458;font-weight:bold">double</span> a, <span style="color:#458;font-weight:bold">double</span> b, <span style="color:#458;font-weight:bold">double</span> absEpsilon, <span style="color:#458;font-weight:bold">double</span> relEpsilon) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Check if the numbers are really close -- needed when comparing numbers near zero.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">if</span> (std<span style="font-weight:bold">::</span>abs(a <span style="font-weight:bold">-</span> b) <span style="font-weight:bold">&lt;=</span> absEpsilon)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#999">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Otherwise fall back to Knuth&#39;s algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> approximatelyEqualRel(a, b, relEpsilon);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With that, we can compare like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> a{ <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> <span style="font-weight:bold">+</span> <span style="color:#099">0.1</span> };  <span style="color:#998;font-style:italic">// almost 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> relEps { <span style="color:#099">1e-8</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> absEps { <span style="color:#099">1e-12</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> same { approximatelyEqualAbsRel(a, <span style="color:#099">1.0</span>, absEps, relEps) };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> same <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We&rsquo;re using C++23 so that <code>std::abs</code> is <code>constexpr</code>, otherwise the compiler will throw an error when instantiating <code>same</code>. In that case, we can fix the above program by defining our own <code>abs</code> function.</p>
<h2 id="logical-operators">Logical operators</h2>
<p>There are three kinds of logical operators: logical NOT (<code>!</code>), logical OR <code>||</code> and logical AND <code>&amp;&amp;</code>. The latter two share a property called <strong>short circuit evaluation</strong>, which means the left operand, if determining the final result already, will terminate the evaluation early without the right operand being evaluated at all. If we overload these operators with our own function definitions, this short circuit behavior is gone.</p>
<p>Another thing worth noting is that <code>&amp;&amp;</code> actually has high precedence than <code>||</code>. As a result, when mixing <code>&amp;&amp;</code> and <code>||</code>, it&rsquo;s best to use parentheses whenever possible.</p>
<h1 id="bit-manipulations">Bit Manipulations</h1>
<h2 id="bit-flags-and-bit-manipulation-via-stdbitset">Bit flags and bit manipulation via <code>std::bitset</code></h2>
<p>When defining bit flags, we use <code>std::bitset</code> from <code>&lt;bitset&gt;</code> header:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;bitset&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>bitset<span style="font-weight:bold">&lt;</span><span style="color:#099">8</span><span style="font-weight:bold">&gt;</span> mybitset {};  <span style="color:#998;font-style:italic">// 8 bits = 8 flags
</span></span></span></code></pre></div><p>The class <code>std::bitset</code> provides some key functions that are useful for bit manipulation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>test()  <span style="color:#998;font-style:italic">// query whether a bit is a 0 or 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>set()   <span style="color:#998;font-style:italic">// turn a bit on (this will do nothing if the bit is already on)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>reset() <span style="color:#998;font-style:italic">// turn a bit off (same as above)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>flip()  <span style="color:#998;font-style:italic">// flip a bit from 0 to 1 (or vice versa)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>all()   <span style="color:#998;font-style:italic">// check if all are 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>any()   <span style="color:#998;font-style:italic">// check if any is 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>none()  <span style="color:#998;font-style:italic">// check if none is 1
</span></span></span></code></pre></div><h2 id="bitwise-operators">Bitwise operators</h2>
<p>C++ provides 6 bit manipulation operators, often called <strong>bitwise</strong> operators:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Symbol</th>
<th>Form</th>
<th>Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>left shift</td>
<td><code>&lt;&lt;</code></td>
<td><code>x &lt;&lt; y</code></td>
<td>all bits in <code>x</code> shift left by <code>y</code> bits</td>
</tr>
<tr>
<td>right shift</td>
<td><code>&gt;&gt;</code></td>
<td><code>x &gt;&gt; y</code></td>
<td>all bits in <code>x</code> shift right by <code>y</code> bits</td>
</tr>
<tr>
<td>bitwise NOT</td>
<td><code>~</code></td>
<td><code>~x</code></td>
<td>all bits in x get flipped</td>
</tr>
<tr>
<td>bitwise AND</td>
<td><code>&amp;</code></td>
<td><code>x &amp; y</code></td>
<td>each bit in <code>x</code> AND each bit in <code>y</code></td>
</tr>
<tr>
<td>bitwise OR</td>
<td><code>|</code></td>
<td><code>x | y</code></td>
<td>each bit in <code>x</code> OR each bit in <code>y</code></td>
</tr>
<tr>
<td>bitwise XOR</td>
<td><code>^</code></td>
<td><code>x ^ y</code></td>
<td>each bit in <code>x</code> XOR each bit in <code>y</code></td>
</tr>
</tbody>
</table>
<p>Of all operators above, we have a corresponding assignment version.</p>
<h1 id="scope-duration-and-linkage">Scope, Duration and Linkage</h1>
<h2 id="user-defined-namespaces">User-defined namespaces</h2>
<p>Imagine we have the project structure as below:</p>
<p>foo.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">do_something</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>goo.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">do_something</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">-</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>with these two files only, the project will compile just fine, as we&rsquo;re not combining them together. Now, let&rsquo;s say we have another file main.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">do_something</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> do_something(<span style="color:#099">1</span>, <span style="color:#099">2</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We would get a linker error right away for defining the same function twice. Notice that this error doesn&rsquo;t require the <code>main</code> to actually call the <code>do_something</code> function - in fact, simply by declaring the function in main.cpp cause the error. To resolve this issue (without renaming one of the two function definitions), we can define our own namespace:</p>
<p>foo.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Foo {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">do_something</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>goo.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Goo {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">do_something</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> x <span style="font-weight:bold">-</span> y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can, if needed, define nested namespaces in either of the following ways:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Foo {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">namespace</span> Goo {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// or
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Foo<span style="font-weight:bold">::</span>Goo {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When using the nested namespaces a lot, we can define namespace aliases like below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Temp <span style="font-weight:bold">=</span> Foo<span style="font-weight:bold">::</span>Goo;
</span></span></code></pre></div><h2 id="local-variables-and-global-variables">Local variables and global variables</h2>
<ul>
<li>Local variables have <strong>block scope</strong>: they&rsquo;re in scope from definition to the end of the block</li>
<li>Local variables have automatic storage <strong>duration</strong>: same as above</li>
<li>Best practice is to define local variables in the smallest scope allowed</li>
</ul>
<p>On the contrary:</p>
<ul>
<li>Global variables are defined outside all functions including <code>main</code></li>
<li>Global variables can be defined inside a global namespace</li>
<li>Best practice is to define a global variable, if not constant, with a prefix <code>g</code> or <code>g_</code></li>
</ul>
<h2 id="internal-linkage-and-internal-variables">Internal linkage and internal variables</h2>
<p>An identifier with <strong>internal linkage</strong> can be seen and used within a single translation unit, but it is not accessible from other translation units (that is, it is not exposed to other linkers). This means if two source files share the same linker, the identifiers with internal linkage will be treated as independent and thus not violating ODR for duplicate definitions.</p>
<p>To make a global variable internal (and thus making it an <strong>internal variable</strong>), we can use the keyword <code>static</code>. Notice that <code>static</code> is ignored for const global variables as <em>they&rsquo;re internal by default already</em>.</p>
<p>There are typically two reasons to give an identifier internal linkage:</p>
<ul>
<li>There s an identifier we want to make sure isn&rsquo;t accessible to other files</li>
<li>To be pedantic about avoiding naming collisions</li>
</ul>
<h2 id="external-linkage-and-external-variables">External linkage and external variables</h2>
<p>An identifier with <strong>external linkage</strong> can be seen and used by other other files. In that sense, external variables are more &ldquo;global&rdquo; than global variables. <em>Functions and non-constant global variables are external by default.</em> Constant global variables can be defined as external using <code>extern</code> keyword.</p>
<h2 id="sharing-global-constants-across-files">Sharing global constants across files</h2>
<p>Prior to C++17, the following is the best practice:</p>
<ul>
<li>Create a header file</li>
<li>Inside the header file, define a namespace</li>
<li>Inside the namespace, define all the constants (make sure they&rsquo;re <code>constexpr</code>)</li>
<li><code>#include</code> the header to wherever you need those constants</li>
</ul>
<p>Because constant global variables are by default internal, each .cpp file are actually going to have an independent copy of all these constants and header guards won&rsquo;t stop this from happening. Changing any of these constants, therefore, will result in lengthy recompiling/rebuilding time for large projects. In addition, it can involve a large lump of memory every time a copy is needed.</p>
<p>Instead of above, we can</p>
<ul>
<li>Create a header file and corresponding cpp file</li>
<li>Inside both files, define a namespace</li>
<li>Inside the namespace of the header file, declare all the constants as <code>extern const</code> (using <code>const</code> instead of <code>constexpr</code> here because <code>constexpr</code> cannot be forward declared)</li>
<li>Inside the namespace of the cpp file, define the constants</li>
</ul>
<p>We can, after learning <code>inline</code> function and variables, define the constants as <code>inline constexpr</code>:</p>
<ul>
<li>Create a header file</li>
<li>Inside the header file, define a namespace</li>
<li>Inside the namespace, define all the constants as <code>inline constexpr</code></li>
</ul>
<h2 id="static-local-variables">Static local variables</h2>
<p>We have covered what <code>static</code> global variable means, now let&rsquo;s talk about <code>static</code> local variables. Using the <code>static</code> keyword on a local variable changes the duration from <code>automatic duration</code> (from definition to end of block) to <code>static duration</code> (from definition to explicit destroy) - just like a global variable. One of the most common use case of <code>static</code> local variables is unique ID generation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">generate_unique_id</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> s_item_id {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> s_item_id<span style="font-weight:bold">++</span>;  <span style="color:#998;font-style:italic">// make copy; inc original; return copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>Another use case is when you have a function that requires a constant caching that takes a lot of time to generate on the first time.</p>
<h2 id="scope-duration-and-linkage-summary">Scope, duration and linkage summary</h2>
<p>One last time let&rsquo;s go over these concepts:</p>
<ul>
<li>scope: where the identifier is accessible</li>
<li>duration: birth to death of an identifier</li>
<li>linkage: whether multiple declarations of an identifier refer to the same entity or not</li>
</ul>
<p>In table format:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Scope</th>
<th>Duration</th>
<th>Linkage</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Local variables</td>
<td><code>int x;</code></td>
<td>Block</td>
<td>Automatic</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>Static local variables</td>
<td><code>static int s_x;</code></td>
<td>Block</td>
<td>Static</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>Dynamic local variables</td>
<td><code>int* x {new int{}};</code></td>
<td>Block</td>
<td>Dynamic</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>Function parameters</td>
<td><code>void foo(int x)</code></td>
<td>Block</td>
<td>Automatic</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>External non-constant global variables</td>
<td><code>int g_x;</code></td>
<td>Global</td>
<td>Static</td>
<td>External</td>
<td>Initialized or uninitialized</td>
</tr>
<tr>
<td>Internal non-constant global variables</td>
<td><code>static int g_x;</code></td>
<td>Global</td>
<td>Static</td>
<td>Internal</td>
<td>Initialized or uninitialized</td>
</tr>
<tr>
<td>Internal constant global variables</td>
<td><code>constexpr int g_x{1};</code></td>
<td>Global</td>
<td>Static</td>
<td>Internal</td>
<td>Must be initialized</td>
</tr>
<tr>
<td>External constant global variables</td>
<td><code>extern const int g_x{1};</code></td>
<td>Global</td>
<td>Static</td>
<td>External</td>
<td>Must be initialized</td>
</tr>
<tr>
<td>Inline constant global variables (C++17)</td>
<td><code>inline constexpr int g_x{1};</code></td>
<td>Global</td>
<td>Static</td>
<td>External</td>
<td>Must be initialized</td>
</tr>
</tbody>
</table>
<h2 id="unnamed-and-inline-namespaces">Unnamed and inline namespaces</h2>
<p>We have a few different namespaces available:</p>
<ul>
<li>Global namespace: no need for any accessor <code>::</code></li>
<li>Normal named namespace: need name accessor <code>name::</code></li>
<li>Unnamed namespace (aka anonymous namespace): anything defined inside an anonymous namespace is seen as &ldquo;static&rdquo;, that is, they can only be accessed, globally, within the current source file; no need for any accessor <code>::</code></li>
<li>Inline namespace: overtaking the global namespace</li>
</ul>
<p>Using inline namespaces allow us to &ldquo;switch&rdquo; easily between multiple versions of functions etc without changing the old code.</p>
<h1 id="control-flow-and-error-handling">Control Flow and Error Handling</h1>
<h2 id="categories-of-flow-control-statements">Categories of flow control statements</h2>
<table>
<thead>
<tr>
<th>Category</th>
<th>Meaning</th>
<th>Implemented in C++ by</th>
</tr>
</thead>
<tbody>
<tr>
<td>Conditional statements</td>
<td>Execute only if some condition is met</td>
<td><code>if</code>, <code>switch</code></td>
</tr>
<tr>
<td>Jumps</td>
<td>Start executing the statement at some other location</td>
<td><code>goto</code>, <code>break</code>, <code>continue</code></td>
</tr>
<tr>
<td>Function calls</td>
<td>Function calls a jumps to some other location <strong>and back</strong></td>
<td>Function call, <code>return</code></td>
</tr>
<tr>
<td>Loops</td>
<td>Repeatedly execute some sequence of code until end condition is met</td>
<td><code>while</code>, <code>do-while</code>, <code>for</code>, <code>ranged-for</code></td>
</tr>
<tr>
<td>Halts</td>
<td>Quit running the whole program</td>
<td><code>std::exit</code>, <code>std::abort</code></td>
</tr>
<tr>
<td>Exceptions</td>
<td>Error handling</td>
<td><code>try</code>, <code>throw</code>, <code>catch</code></td>
</tr>
</tbody>
</table>
<h2 id="if-conditions">If conditions</h2>
<p>Only thing that needs attention is the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="color:#999">true</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The program above won&rsquo;t compile because both definitions of <code>x</code> are within the conditional blocks and thus destroyed by <code>std::cout</code> needs it.</p>
<h2 id="null-statements">Null statements</h2>
<p>A <strong>null statement</strong> is an expression with just a semicolon:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (x <span style="font-weight:bold">&gt;</span> <span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>    ;
</span></span></code></pre></div><p>which is equivalent to</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (x <span style="font-weight:bold">&gt;</span> <span style="color:#099">10</span>);
</span></span></code></pre></div><p>and thus can be dangerous, for example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (nuclear_code_activated());
</span></span><span style="display:flex;"><span>    blow_up_the_world();
</span></span></code></pre></div><p>The world will be blown up no matter whether the button is pressed or not, because what&rsquo;s actually going on in the example above is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (nuclear_code_activated()) {
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>blow_up_the_world();
</span></span></code></pre></div><h2 id="constexpr-if-statements"><code>constexpr</code> if statements</h2>
<p>Check this example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> g {<span style="color:#099">9.8</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (g <span style="font-weight:bold">==</span> <span style="color:#099">9.8</span>) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;gravity is noraml</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;gravity is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> g <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above example will compile but the if statement is only evaluated at compile time, which is wasteful as <code>g</code> is <code>constexpr</code>. In C++17 we can optimize the flow using <code>constexpr</code> if statements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> g {<span style="color:#099">9.8</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> <span style="font-weight:bold">constexpr</span> (g <span style="font-weight:bold">==</span> <span style="color:#099">9.8</span>) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;gravity is normal</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;gravity is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> g <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Modern compilers may or may not use a warning to advise such conversion of if statement for optimization purposes, and the may or may not automatically do the <code>constexpr</code> treatment for you. So when such optimization is required, it&rsquo;s best to be explicit than letting the compiler to decide.</p>
<h2 id="switch-statements"><code>switch</code> statements</h2>
<p>A <code>switch</code> statement is nothing but a chain of <code>if-else-if</code> statements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">switch</span> (statement) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">case</span> <span style="color:#099">1</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">case</span> <span style="color:#099">2</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that a switch statement is evaluated case by case sequentially and it won&rsquo;t automatically break out of the <code>switch</code> block without explicitly using <code>break</code> or <code>return</code>. As a result, the best practice is to keep a <code>break</code> or <code>return</code> at all cases, and keep a <code>default</code> in the end. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (<span style="color:#099">2</span>) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">case</span> <span style="color:#099">1</span><span style="font-weight:bold">:</span> <span style="color:#998;font-style:italic">// Does not match
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">1</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// Skipped
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">case</span> <span style="color:#099">2</span><span style="font-weight:bold">:</span> <span style="color:#998;font-style:italic">// Match!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">2</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// Execution begins here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">case</span> <span style="color:#099">3</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">3</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// This is also executed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">case</span> <span style="color:#099">4</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">4</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// This is also executed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">5</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// This is also executed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is called <code>switch</code> overflow (or fall-through). When fall-through happens, compilers usually give warnings as it&rsquo;s usually not intentional. That being said, if it is indeed desired, we can use the <code>[[fallthrough]]</code> attribute to indicate the compiler that a warning won&rsquo;t be necessary:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (<span style="color:#099">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#099">1</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">1</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#099">2</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">2</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#008080">[[fallthrough]]</span>;  <span style="color:#998;font-style:italic">// fall through starting from here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">case</span> <span style="color:#099">3</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">3</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="sequential-case-labels">Sequential <code>case</code> labels</h2>
<p>Because <code>case</code> labels are not statements (they&rsquo;re labels), we can stack them if desired:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">is_vowel</span>(<span style="color:#458;font-weight:bold">char</span> c) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;a&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;e&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;i&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span><span style="color:#b84">&#39;o&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;u&#39;</span> <span style="font-weight:bold">||</span>
</span></span><span style="display:flex;"><span>        c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;A&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;E&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;I&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;O&#39;</span> <span style="font-weight:bold">||</span> c <span style="font-weight:bold">==</span> <span style="color:#b84">&#39;U&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above can be rewritten using <code>switch</code> statement as</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">is_vowel</span>(<span style="color:#458;font-weight:bold">char</span> c) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (c) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;a&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;e&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;i&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;o&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;u&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;A&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;E&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;I&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;O&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;U&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#999">true</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#999">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is not fall-through because only one case is being evaluated and executed.</p>
<h2 id="switch-case-scoping"><code>switch</code> case scoping</h2>
<p>It&rsquo;s worth noting that different from <code>if</code> statements where there&rsquo;s an implicit block, under <code>switch</code> cases there&rsquo;re not individual blocks. Instead, all cases share the same <code>switch</code> block:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">switch</span> (<span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> a;      <span style="color:#998;font-style:italic">// okay: definition is allowed before the case labels
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> b{ <span style="color:#099">5</span> }; <span style="color:#998;font-style:italic">// illegal: initialization is not allowed before the case labels
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">case</span> <span style="color:#099">1</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> y; <span style="color:#998;font-style:italic">// okay but bad practice: definition is allowed within a case
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        y <span style="font-weight:bold">=</span> <span style="color:#099">4</span>; <span style="color:#998;font-style:italic">// okay: assignment is allowed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">case</span> <span style="color:#099">2</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> z{ <span style="color:#099">4</span> }; <span style="color:#998;font-style:italic">// illegal: initialization is not allowed if subsequent cases exist
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        y <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;      <span style="color:#998;font-style:italic">// okay: y was declared above, so we can use it here too
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">case</span> <span style="color:#099">3</span><span style="font-weight:bold">:</span> { <span style="color:#998;font-style:italic">// note addition of explicit block here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="color:#458;font-weight:bold">int</span> x{ <span style="color:#099">4</span> }; <span style="color:#998;font-style:italic">// okay, variables can be initialized inside a block inside a case
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="while-and-do-while-statements"><code>while</code> and <code>do-while</code> statements</h2>
<p>Skipped.</p>
<h2 id="for-loops"><code>for</code> loops</h2>
<p>The general template is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (init<span style="font-weight:bold">-</span>statement; condition; end<span style="font-weight:bold">-</span>expression) {
</span></span><span style="display:flex;"><span>    statement;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which can be very confusing if we allow null statements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (;;) {
</span></span><span style="display:flex;"><span>    statement;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above is equivalent to</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">while</span> (<span style="color:#999">true</span>) {
</span></span><span style="display:flex;"><span>    statement;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A <code>for</code> loop can also have multiple variables in the init-statement:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">0</span>}, y{<span style="color:#099">10</span>}; x <span style="font-weight:bold">&lt;</span> <span style="color:#099">10</span>; <span style="font-weight:bold">++</span>x, <span style="font-weight:bold">--</span>y) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="break-continue-and-early-return"><code>break</code>, <code>continue</code> and early <code>return</code></h2>
<p>Skipped.</p>
<h2 id="halts">Halts</h2>
<p>In <code>&lt;cstdlib&gt;</code> we have <code>std::exit</code> and <code>std::atexit</code> defined. <code>std::exit</code> terminates the program with the given exit status code. It also performs a number of cleanup functions:</p>
<ul>
<li>objects with static storage duration are destroyed</li>
<li>file cleanup if files are used in the program</li>
<li>return the control back to the OS with the status code</li>
</ul>
<p>However, <code>std::exit</code> doesn&rsquo;t clean up any local variables, and because of that, it&rsquo;s advised to avoid <code>std::exit</code> generally. If we really need to use <code>std::exit</code> and have concerns like such, we can use <code>std::atexit</code> to register our own custom cleanup functions before calling <code>std::exit</code>.</p>
<p>For multi-threaded programs, calling <code>std::exit</code> in a subprocess can crash the main program because of destroyed static objects. To remedy this problem, C++ has provided another pair of halting functions that doesn&rsquo;t clean up the static objects: <code>std::quick_exit</code> and <code>std::at_quick_exit</code>.</p>
<p>In addition, C++ has provided <code>std::abort</code> for abnormal termination, and <code>std::terminate</code> for exception handling. Notice that <code>std::terminate</code> actually calls <code>std::abort</code> implicitly.</p>
<h2 id="stdcout-vs-stdcerr"><code>std::cout</code> vs <code>std::cerr</code></h2>
<p>We know that <code>std::cout</code> is buffered. This means the output may or may not be printed to console by the time the program crashes (if ever). In contrast, <code>std::cerr</code> is unbuffered and thus can always print the needed error message to console.</p>
<h2 id="clearing-buffer-in-stdcin">Clearing buffer in <code>std::cin</code></h2>
<p>We can simply</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cin.ignore(<span style="color:#099">100</span>, <span style="color:#b84">&#39;\n&#39;</span>);
</span></span></code></pre></div><p>which ignores the following 100 characters in the buffer until and including the next &lsquo;\n&rsquo;. Even better, we can just ignore the maximum allowed length of stream:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;limits&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">ignore_line</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin.ignore(std<span style="font-weight:bold">::</span>numeric_limits<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>streamsize<span style="font-weight:bold">&gt;::</span>max(), <span style="color:#b84">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-failure-mode-of-stdcin">The failure mode of <code>std::cin</code></h2>
<p>When an input is invalid and extraction fails, the wrong input is kept in the buffer and <code>std::cin</code> enters the failure mode. In order to continue input, we need to</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (std<span style="font-weight:bold">::</span>cin.fail()) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin.clear();
</span></span><span style="display:flex;"><span>    ignore_line();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Because <code>std::cin</code> has an automatic boolean conversion indicating whether the last input succeeded, we can also</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>std<span style="font-weight:bold">::</span>cin) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin.clear();
</span></span><span style="display:flex;"><span>    ignore_line();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>One last corner case is when end-of-file (EOF) character (via ctrl-D) is passed, the whole input stream closes. This is something that can&rsquo;t be fixed by <code>std::cin.clear()</code> and thus we need to modify the above resetting logic to</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>std<span style="font-weight:bold">::</span>cin) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (std<span style="font-weight:bold">::</span>cin.eof()) {
</span></span><span style="display:flex;"><span>        exit(<span style="color:#099">0</span>);  <span style="color:#998;font-style:italic">// we can just shut down the program
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin.clear();  <span style="color:#998;font-style:italic">// back to normal input stream
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    ignore_line();     <span style="color:#998;font-style:italic">// ignore bad characters remaining in the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting that when the user input overflows the range of target variable, e.g. passing 40,000 to int16 (whose range is -32,768 to 32,767), the assignment still happens:</p>
<ul>
<li>The closest limit is assigned to the value</li>
<li>The input stream goes into failure mode</li>
</ul>
<h2 id="assert-and-static_assert"><code>assert</code> and <code>static_assert</code></h2>
<p>In C++, runtime assertions are implemented via the <code>assert</code> preprocessor macro, which lives in the <code>&lt;cassert&gt;</code> header:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for assert
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cmath&gt;</span><span style="color:#999;font-weight:bold">    </span><span style="color:#998;font-style:italic">// for std::sqrt
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#458;font-weight:bold">double</span> x, <span style="color:#458;font-weight:bold">double</span> y) {
</span></span><span style="display:flex;"><span>    assert(y <span style="font-weight:bold">&gt;</span> <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (x <span style="font-weight:bold">&lt;=</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>sqrt(<span style="color:#099">2</span> <span style="font-weight:bold">*</span> x <span style="font-weight:bold">/</span> y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;The answer is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> f(<span style="color:#099">100</span>, <span style="font-weight:bold">-</span><span style="color:#099">9</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can make our assertion statement more descriptive by adding a followup string to it</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>assert(condition <span style="font-weight:bold">&amp;&amp;</span> <span style="color:#b84">&#34;my assert message&#34;</span>);
</span></span></code></pre></div><p>This is because the logical AND (<code>&amp;&amp;</code>) operator has short circuit property and thus any <code>false</code> condition would yield the whole compound statement inside the parenthesis and thus including the added string literal in the error message.</p>
<p>It&rsquo;s worth noting that <code>assert</code> macro comes with a small performance cost at each time the condition is checked, and thus in production code it&rsquo;s usually advised to not use <code>assert</code> at all, as your code should be fully tested already. We can use the <code>NDEBUG</code> macro to turn off <code>assert</code> statements in some IDEs.</p>
<p>C++ also has another type of assertion called <code>static_assert</code>. This is basically the compile-time version of the <code>assert</code> which is runtime. Unlike <code>assert</code> which is a macro defined in <code>&lt;cassert&gt;</code>, <code>static_assert</code> is actually a keyword and thus no header is needed. A <code>static_assert</code> takes the following form:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">static_assert</span>(condition, message);
</span></span></code></pre></div><p>where the condition must be constant expression, and if any error, it would be a compiler error. Prior to C++17, the message used to be required, but this is no longer the case.</p>
<h2 id="generating-random-numbers">Generating random numbers</h2>
<p>Using Mersenne Twister:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;random&gt;</span><span style="color:#999;font-weight:bold">   </span><span style="color:#998;font-style:italic">// for std::mt19937
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>mt19937 mt{}; <span style="color:#998;font-style:italic">// instantiate a 32-bit Mersenne Twister
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> count{<span style="color:#099">1</span>}; count <span style="font-weight:bold">&lt;=</span> <span style="color:#099">40</span>; <span style="font-weight:bold">++</span>count) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> mt() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\t&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (count <span style="font-weight:bold">%</span> <span style="color:#099">5</span> <span style="font-weight:bold">==</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which will print 40 32-bit PRNG as a 8x5 table.</p>
<p>We can also generate uniform distribution:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;random&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>mt19937 mt{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>uniform_int_distribution die6{<span style="color:#099">1</span>, <span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> count{<span style="color:#099">1</span>}; count <span style="font-weight:bold">&lt;=</span> <span style="color:#099">40</span>; <span style="font-weight:bold">++</span>count) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> die6(mt) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\t&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (count <span style="font-weight:bold">%</span> <span style="color:#099">10</span> <span style="font-weight:bold">==</span> <span style="color:#099">0</span>) std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can seed the random number generator as <code>mt{42}</code> instead of the default seed <code>mt{1}</code>, but more preferably we can use the <code>std::random_device{}</code> to achieve better pseudo-randomness:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;random&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>mt19937 mt{ std<span style="font-weight:bold">::</span>random_device{}() };
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// other following code
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that <code>random_device</code> only gives 32-bit (4 bytes) integer to seed the Mersenne number, but the random number generator is 624 bytes in size (156 folds of the size given). This means we&rsquo;re effectively <strong>underseeding</strong> the generator, potentially making the result less random. To cope with that we can use <code>std::seed_seq</code> which basically combines a sequence of seed numbers, each of 4 bytes, into a large seeding object to be passed to the generator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;random&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>random_device rd{}; <span style="color:#998;font-style:italic">// just device, not called yet
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>seed_seq ss { rd(), rd(), rd(), rd(), rd(), rd(), rd() };  <span style="color:#998;font-style:italic">// you can go all the way to 156 of rd() if you want
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>mt19937 mt{ss};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>uniform_int_distribution die6{<span style="color:#099">1</span>, <span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> count{<span style="color:#099">1</span>}; count <span style="font-weight:bold">&lt;=</span> <span style="color:#099">40</span>; <span style="font-weight:bold">++</span>count) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> die6(mt) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\t&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (count <span style="font-weight:bold">%</span> <span style="color:#099">10</span> <span style="font-weight:bold">==</span> <span style="color:#099">0</span>) std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="type-conversion-and-function-overloading">Type Conversion and Function Overloading</h1>
<h2 id="implicit-type-conversion">Implicit type conversion</h2>
<p>Implicit type conversion happens in all of the following case:</p>
<p>When initializing a variable with a value of a different type:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> d {<span style="color:#099">3</span>}; <span style="color:#998;font-style:italic">// int converted to double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>d <span style="font-weight:bold">=</span> <span style="color:#099">6</span>;  <span style="color:#998;font-style:italic">// int converted to double
</span></span></span></code></pre></div><p>When the type of a return value is different from the function&rsquo;s declared return type:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span> <span style="color:#900;font-weight:bold">something</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">3.0</span>; <span style="color:#998;font-style:italic">// double 3.0 converted to float
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>When using certain binary operators with operands of different types:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> division {<span style="color:#099">4.0</span> <span style="font-weight:bold">/</span> <span style="color:#099">3</span>};  <span style="color:#998;font-style:italic">// int 3 converted to double
</span></span></span></code></pre></div><p>When an argument passed to a function is a different type than the function parameter:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">something</span>(<span style="color:#458;font-weight:bold">long</span> l) {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>something (<span style="color:#099">3</span>);  <span style="color:#998;font-style:italic">// int 3 converted to long
</span></span></span></code></pre></div><h2 id="numeric-promotion">Numeric promotion</h2>
<p>Because C++ is designed to be portable and performant across a wide range of architectures, the language designers did not want to assume a given CPU would be able to efficiently manipulate values that were narrower than the natural data size for that CPU.</p>
<p>To help address this challenge, C++ defines a category of type conversions informally called the <strong>numeric promotions</strong>. A numeric promotion is the type conversion of certain narrower numeric types (such as a char) to certain wider numeric types (typically int or double) that can be processed efficiently and is less likely to have a result that overflows.</p>
<p>All numeric promotions are value-preserving, which means that the converted value will always be equal to the source value (it will just have a different type). Since all values of the source type can be precisely represented in the destination type, value-preserving conversions are said to be “safe conversions”.</p>
<p>Because promotions are safe, the compiler will freely use numeric promotion as needed, and will not issue a warning when doing so.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printInt</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printDouble</span>(<span style="color:#458;font-weight:bold">double</span> d) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> d <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    printDouble(<span style="color:#099">5.0</span>); <span style="color:#998;font-style:italic">// no conversion necessary
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    printDouble(<span style="color:#099">4.0f</span>); <span style="color:#998;font-style:italic">// numeric promotion of float to double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="narrowing-conversion">Narrowing conversion</h2>
<p>In contrast to numeric conversion that are widening (note: numeric promotion, which widens a type to the native type, is just a subset of general numeric conversion), narrowing conversions are in most cases not recommended. If we really need to do so, we&rsquo;d better do it explicitly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">some_function</span>(<span style="color:#458;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> d{<span style="color:#099">5.0</span>};
</span></span><span style="display:flex;"><span>    some_function(d);  <span style="color:#998;font-style:italic">// bad: implicit convertion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    some_function(<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(d));  <span style="color:#998;font-style:italic">// good: explicit conversion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting (and praising) that brace initialization doesn&rsquo;t allow narrow conversion implicitly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i {<span style="color:#099">3.65</span>};  <span style="color:#998;font-style:italic">// won&#39;t compile at all!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>&hellip;except the value being converted is <code>constexpr</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> n1 {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> n2 {n1};  <span style="color:#998;font-style:italic">// not considered narrowing due to constexpr excludion clause
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> n3 {n1};  <span style="color:#998;font-style:italic">// error: brace initializtion disallows narrowing
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="arithmetic-conversion">Arithmetic conversion</h2>
<p>What happens when we evaluate e.g. <code>2 + 5.5</code>? There is actually a list of prioritized types for <strong>usual arithmetic conversion</strong>:</p>
<ul>
<li><code>long double</code> (highest)</li>
<li><code>double</code></li>
<li><code>float</code></li>
<li><code>unsigned long long</code></li>
<li><code>long long</code></li>
<li><code>unsigned long</code></li>
<li><code>long</code></li>
<li><code>unsigned int</code></li>
<li><code>int</code> (lowest)</li>
</ul>
<p>If the operands are not of the same type, the type with higher priority will be returned.</p>
<h2 id="explicit-type-conversion-casting">Explicit type conversion (casting)</h2>
<p>C++ supports 5 different types of casts: C-style casts, static casts, const casts, dynamic casts and reinterpret casts. The latter four are often referred to as <strong>named casts</strong>.</p>
<p>C-style casts:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x {<span style="color:#099">10</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y {<span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> d {(<span style="color:#458;font-weight:bold">double</span>)x <span style="font-weight:bold">/</span> y};  <span style="color:#998;font-style:italic">// convert x to double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> d <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// prints: 3.5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also use a more function-call like syntax:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> d {<span style="color:#458;font-weight:bold">double</span>(x) <span style="font-weight:bold">/</span> y};  <span style="color:#998;font-style:italic">// same as above
</span></span></span></code></pre></div><p>Static cast:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> c {<span style="color:#b84">&#39;a&#39;</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> c <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(c) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints: a 97
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>static_cast</code> is intentionally less powerful than the C-style cast, for example, you cannot remove the <code>const</code> from a variable after the cast:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref{<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;&gt;</span>(x)};  <span style="color:#998;font-style:italic">// error: dropping the const qualifier here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    ref <span style="font-weight:bold">=</span> <span style="color:#099">6</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="typedef-and-type-aliases"><code>typedef</code> and type aliases</h2>
<p>There are two ways the create type aliases, an old, backward-compatible way using <code>typedef</code>, and a more modern way with <code>using</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">long</span> Miles;  <span style="color:#998;font-style:italic">// typedef { some existing type } { (as) some name }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">using</span> Miles <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">long</span>;  <span style="color:#998;font-style:italic">// using { some name (for) } = { some existing type }
</span></span></span></code></pre></div><p>The old <code>typedef</code> can be hard to read sometimes:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">typedef</span> <span style="color:#900;font-weight:bold">int</span> (<span style="font-weight:bold">*</span>FuncType)(<span style="color:#458;font-weight:bold">double</span>, <span style="color:#458;font-weight:bold">char</span>);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> FuncType <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">int</span>(<span style="font-weight:bold">*</span>)(<span style="color:#458;font-weight:bold">double</span>, <span style="color:#458;font-weight:bold">char</span>);
</span></span></code></pre></div><p>Type aliases are very useful when we want to hide platform specific details on typing. For example, on some platforms, an <code>int</code> is of 2 bytes while on others 4. We can define the explicit types in a header file like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifdef INT_2_BYTES
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> <span style="color:#458;font-weight:bold">int8_t</span> <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">char</span>;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> <span style="color:#458;font-weight:bold">int16_t</span> <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">int</span>;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> <span style="color:#458;font-weight:bold">int32_t</span> <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> <span style="color:#458;font-weight:bold">int8_t</span> <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">char</span>;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> <span style="color:#458;font-weight:bold">int16_t</span> <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">short</span>;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> <span style="color:#458;font-weight:bold">int32_t</span> <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">int</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>Using type aliases can make complex types easier to read and use:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">using</span> VectPairSI <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>pair<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string, <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;&gt;</span>;
</span></span></code></pre></div><h2 id="type-deduction-using-auto">Type deduction using <code>auto</code></h2>
<p>Type deduction (also sometimes called <strong>type inference</strong>) is a feature that allows the compiler to deduce the type of an object from the object’s initializer. To use type deduction, the auto keyword is used in place of the variable’s type:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> d {<span style="color:#099">5.0</span>}; <span style="color:#998;font-style:italic">// double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> i {<span style="color:#099">1</span> <span style="font-weight:bold">+</span> <span style="color:#099">2</span>}; <span style="color:#998;font-style:italic">// int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> x {i}; <span style="color:#998;font-style:italic">// int as well
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> sum {add(<span style="color:#099">5</span>, <span style="color:#099">6</span>)};  <span style="color:#998;font-style:italic">// compiler konws add() returns and int, so auto works for function as well
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> x; <span style="color:#998;font-style:italic">// invalid: no idea of type
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> y {};  <span style="color:#998;font-style:italic">// invalid: same as above
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting that type deduction drops <code>const</code> and <code>constexpr</code> qualifiers implicitly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x {<span style="color:#099">5</span>};  <span style="color:#998;font-style:italic">// x has type const int (compile-time)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> y {x};  <span style="color:#998;font-style:italic">// y is just an int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">constexpr</span> z {x};  <span style="color:#998;font-style:italic">// z is constexpr int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>For strings, it&rsquo;s a bit tricky, as <code>auto</code> by default infers the type to be <code>char*</code>. In order to make <code>auto</code> to deduct a string literal into <code>string</code> type, we need to use literal suffixes:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> <span style="font-weight:bold">namespace</span> std<span style="font-weight:bold">::</span>literals;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> s1 {<span style="color:#b84">&#34;goo&#34;</span>s};   <span style="color:#998;font-style:italic">// string
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> s2 {<span style="color:#b84">&#34;foo&#34;</span>sv};  <span style="color:#998;font-style:italic">// string_view
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For function return types (note: different from the returned values of a function with given type, see above) it&rsquo;s even trickier. When the compiler <strong>knows</strong> the returned type of a function is unique and deterministic, we can use the <code>auto</code> keyword in a similar way as for variables:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}  <span style="color:#998;font-style:italic">// this works
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">something</span>(<span style="color:#458;font-weight:bold">bool</span> b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (b) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">6.5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// won&#39;t compile
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">foo</span>();  <span style="color:#998;font-style:italic">// this compiles
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    foo();  <span style="color:#998;font-style:italic">// but throws a compiler error here, because the function definition isn&#39;t specified yet
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">foo</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// only defned here after main
</span></span></span></code></pre></div><p>To solve the forward declaration problem in the above example, we can use the <strong>trailing return type</strong> syntax:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>) <span style="font-weight:bold">-&gt;</span> <span style="color:#458;font-weight:bold">int</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    add(<span style="color:#099">5</span>, <span style="color:#099">2</span>);  <span style="color:#998;font-style:italic">// won&#39;t throw compiler error anymore
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) <span style="font-weight:bold">-&gt;</span> <span style="color:#458;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}  <span style="color:#998;font-style:italic">// even though the definition is here
</span></span></span></code></pre></div><p><strong>Note that type deduction doesn&rsquo;t apply to function parameters. If you use <code>auto</code> like the example below, it would only compile for C++20 and beyond and because of a different feature called function templates, rather than type deduction:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#includer &lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">add_and_print</span>(<span style="font-weight:bold">auto</span> x, <span style="font-weight:bold">auto</span> y) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">+</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    add_and_print(<span style="color:#099">2</span>, <span style="color:#099">3</span>);  <span style="color:#998;font-style:italic">// int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    add_and_print(<span style="color:#099">2.5</span>, <span style="color:#099">3.5</span>);  <span style="color:#998;font-style:italic">// double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="function-overloading">Function overloading</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) { <span style="color:#998;font-style:italic">// integer version
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">double</span> x, <span style="color:#458;font-weight:bold">double</span> y) { <span style="color:#998;font-style:italic">// floating point version
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> x <span style="font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler knows how to differentiate the overloaded functions. Specifically:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Used for differentiation?</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number of parameters</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>Type of parameters</td>
<td>Yes</td>
<td>Excludes <code>typedef</code>, type alias and const qualifier. Includes ellipses.</td>
</tr>
<tr>
<td>Return type</td>
<td>No</td>
<td></td>
</tr>
</tbody>
</table>
<p>Note that for member functions, <code>const</code>/<code>volatile</code> and ref-qualifiers are indeed used for overloading.</p>
<p>Given above we define a function&rsquo;s <strong>type signature</strong> as the combination of the following</p>
<ul>
<li>function name</li>
<li>number of parameters</li>
<li>parameter types</li>
<li>function-level qualifiers</li>
</ul>
<p>which doesn&rsquo;t include the return type.</p>
<h2 id="deleting-functions">Deleting functions</h2>
<p>When we want to avoid undesired usage of functions e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_int</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print_int(<span style="color:#099">5</span>);    <span style="color:#998;font-style:italic">// prints 5; ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_int(<span style="color:#b84">&#39;a&#39;</span>);  <span style="color:#998;font-style:italic">// prints 97; ???
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_int(<span style="color:#999">true</span>); <span style="color:#998;font-style:italic">// prints 1; ???
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can define the function as deleted by using the <code>= delete</code> specifier:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_int</span>(<span style="color:#458;font-weight:bold">char</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_int</span>(book) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span></code></pre></div><p>This way, when we evaluate e.g. <code>print_int('a')</code>, there will be a compile error. This is explicit but sometimes too verbose. If we want to delete all other overloads of the function, we can use function templates:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_int</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> print_int(T x) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;  <span style="color:#998;font-style:italic">// deleting all other types
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print_int(<span style="color:#099">5</span>);  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_int(<span style="color:#b84">&#39;a&#39;</span>);  <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_int(<span style="color:#999">true</span>);  <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="default-arguments">Default arguments</h2>
<p>Functions can have default arguments and that can be really convenient:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y<span style="font-weight:bold">=</span><span style="color:#099">10</span>, <span style="color:#458;font-weight:bold">int</span> z<span style="font-weight:bold">=</span><span style="color:#099">20</span>) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;x=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, y=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, z=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> z <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>);  <span style="color:#998;font-style:italic">// prints: x=1, y=2, z=3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print(<span style="color:#099">1</span>, <span style="color:#099">2</span>);  <span style="color:#998;font-style:italic">// prints: x=1, y=2, z=20
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, default arguments cannot be re-declared:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y<span style="font-weight:bold">=</span><span style="color:#099">10</span>); <span style="color:#998;font-style:italic">// forward declaration
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y<span style="font-weight:bold">=</span><span style="color:#099">20</span>);  <span style="color:#998;font-style:italic">// error
</span></span></span></code></pre></div><p>Therefore, the best practice is to define default arguments in header files as forward declarations:</p>
<p>in foo.h:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef FOO_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define FOO_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y<span style="font-weight:bold">=</span><span style="color:#099">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>in main.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;foo.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {  <span style="color:#998;font-style:italic">// no default arguments defined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;x=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, y=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">5</span>);  <span style="color:#998;font-style:italic">// still prints x=5, y=10 as expected
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="templated-functions">Templated functions</h2>
<p>In C++, the template system was designed to simplify the process of creating functions (or classes) that are able to work with different data types. For example, below is a templated max function</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>T max(T x, T y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&lt;</span> y) <span style="font-weight:bold">?</span> y : x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which is actually very similar to the templated/overloaded <code>std::max</code> function defined the in the STL:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span><span style="font-weight:bold">&lt;</span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">T</span>, <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Compare</span><span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">const</span> T<span style="font-weight:bold">&amp;</span> max(<span style="font-weight:bold">const</span> T<span style="font-weight:bold">&amp;</span> a, <span style="font-weight:bold">const</span> T<span style="font-weight:bold">&amp;</span> b, Compare comp);
</span></span></code></pre></div><p>In order to use a templated function, we need to instantiate it like below</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;max.h&#34;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// assuming our templated max function is defined here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> max<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(<span style="color:#099">1</span>, <span style="color:#099">2</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Thanks to template argument deduction, we can also do one of below instead:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>max<span style="font-weight:bold">&lt;&gt;</span>(<span style="color:#099">1</span>, <span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>max(<span style="color:#099">1</span>, <span style="color:#099">2</span>);
</span></span></code></pre></div><p>This deduction doesn&rsquo;t always work, e.g.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>max(<span style="color:#b84">&#34;what?&#34;</span>);  <span style="color:#998;font-style:italic">// error
</span></span></span></code></pre></div><p>but we can effectively avoid this kind of unknown behavior by deleting certain instantiations of templated functions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> max(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>, <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span></code></pre></div><p>Another headache happens in the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, <span style="font-weight:bold">typename</span> U<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>T max(T x, U y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&lt;</span> y) <span style="font-weight:bold">?</span> y : x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> max(<span style="color:#099">2</span>, <span style="color:#099">2.5</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What&rsquo;s gonna happen? Because in this case, by type deduction, type <code>T</code> is <code>int</code> and <code>U</code> is <code>double</code>, and because <code>double</code> takes precedence over <code>int</code> in arithmetic rules, we&rsquo;re effectively comparing 2.0 versus 2.5. However, as the return type is <code>T</code> namely <code>int</code>, how can we return 2.5 back? We cannot simply say using <code>U</code> as return type, as the user can always just switch the two input arguments. The better way is to utilize the <code>auto</code> type as return type:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, <span style="font-weight:bold">typename</span> U<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> max(T x, U y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&lt;</span> y) <span style="font-weight:bold">?</span> y : x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Starting from C++20, we can even use <code>auto</code> as argument types to create templated functions, which is called <strong>abbreviated function templates</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">max</span>(<span style="font-weight:bold">auto</span> x, <span style="font-weight:bold">auto</span> y) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (x <span style="font-weight:bold">&lt;</span> y) <span style="font-weight:bold">?</span> y : x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which is translated by compiler automatically into the correctly templated max function above.</p>
<h2 id="non-type-template-parameters">Non-type template parameters</h2>
<p>In addition to type parameters, in C++ we can also pass non-type parameters to templates. A <strong>non-type template parameter</strong> is a template parameter with a fixed type that servers as a place holder for a <code>constexpr</code> value passed in as a template argument. A non-type template parameter can be any of the following types:</p>
<ul>
<li>An integral type</li>
<li>An enumeration type</li>
<li><code>std::nullptr_t</code></li>
<li>A floating point type (since C++20)</li>
<li>A literal class type (since C++20)</li>
<li>A pointer or reference to
<ul>
<li>an object</li>
<li>a function</li>
<li>a member function</li>
</ul>
</li>
</ul>
<p>We have seen non-type template parameters before, when we introduced <code>std::bitset</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;bitset&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>bitset<span style="font-weight:bold">&lt;</span><span style="color:#099">8</span><span style="font-weight:bold">&gt;</span> bits{ <span style="color:#099">0b0000&#39;0101</span> }; <span style="color:#998;font-style:italic">// The &lt;8&gt; is a non-type template parameter
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here is a simple example involving a non-type template parameter:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span> N<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> print() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> N <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It might seem trivial in this case, but when we want to <code>static_assert</code> an argument (remember that arguments cannot be <code>constexpr</code> and thus cannot be checked at compile-time), we can use this trick to achieve our goal.</p>
<p>Just like <code>auto</code> in type template parameters, we can also use <code>auto</code> for automatic type deduction in non-type parameters:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">auto</span> N<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> print() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> N <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print<span style="font-weight:bold">&lt;</span><span style="color:#099">5</span><span style="font-weight:bold">&gt;</span>();
</span></span><span style="display:flex;"><span>    print<span style="font-weight:bold">&lt;</span><span style="color:#b84">&#39;c&#39;</span><span style="font-weight:bold">&gt;</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="compound-types-references-and-pointers">Compound Types: References and Pointers</h1>
<h2 id="what-are-compound-data-types-in-c">What are compound data types in C++?</h2>
<p><strong>Compound data types</strong> (also sometimes called <strong>composite data types</strong>) are data types that can be constructed from fundamental data types (or other compound data types). Each compound data type has its own unique properties as well. C++ supports the following compound types:</p>
<ul>
<li>Functions</li>
<li>Arrays</li>
<li>Pointer types
<ul>
<li>to object</li>
<li>to function</li>
<li>to data member</li>
<li>to member function</li>
</ul>
</li>
<li>Reference types
<ul>
<li>lvalue references</li>
<li>rvalue references</li>
</ul>
</li>
<li>Enumerated types
<ul>
<li>Unscoped enumerations</li>
<li>Scoped enumerations</li>
</ul>
</li>
<li>Class types
<ul>
<li>Structs</li>
<li>Classes</li>
<li>Unions</li>
</ul>
</li>
</ul>
<h2 id="value-categories-lvalue-and-rvalue">Value categories (lvalue and rvalue)</h2>
<p>Prior to C++11, there were only two value categories: lvalue and rvalue. In C++11, three additional value categories were added to support a new feature called <code>move</code> semantics: glvalue, prvalue and xvalue.</p>
<p>An <strong>lvalue</strong> is an expression that evaluates to an identifiable object or function (or bit-field). Entities with identities can be accessed via an identifier, reference or pointer. Therefore, we have <strong>modifiable</strong> and <strong>non-modifiable</strong> lvalues.</p>
<p>An <strong>rvalue</strong> is an expression that is not an lvalue. Commonly seen rvalues include literals (except C-style string literals, which are lvalues) and the return value of functions and operators that return by value. Rvalues are not identifiable and only exist within the scope of the expression in which they are used.</p>
<h2 id="lvalue-references">Lvalue references</h2>
<p>In C++, a reference is an alias for an existing object. Once a reference has been defined, any operation on the reference is applied to the object being referenced. An lvalue reference (commonly just called a reference since prior to C++11 there was only one type of reference) acts as an alias for an existing lvalue (such as a variable).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span>     <span style="color:#998;font-style:italic">// int type
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span>    <span style="color:#998;font-style:italic">// an lvalue reference on an int object
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&amp;</span> <span style="color:#998;font-style:italic">// an lvalue reference on a double object
</span></span></span></code></pre></div><p>For who knows about pointers already - the ampersand symbol here <strong>does not</strong> mean &ldquo;the address of&rdquo;, but &ldquo;lvalue reference to&rdquo; an object.</p>
<p>A reference, once initialized, cannot be <strong>reseated</strong>, meaning that we cannot reassign it to reference another object:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref{x};  <span style="color:#998;font-style:italic">// ref now is an alias of x
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    ref <span style="font-weight:bold">=</span> y;      <span style="color:#998;font-style:italic">// assign 6 to x! not reseating ref
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting that, although reference variables follow the same scoping and duration rules as normal variables, references and referents can have independent lifetimes. A reference can be destroyed before the object it references to, and the object can be destroyed without the reference as well.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref{x}; <span style="color:#998;font-style:italic">// ref is an alias to x
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ref <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }  <span style="color:#998;font-style:italic">// ref destroyed here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// x destroyed here
</span></span></span></code></pre></div><p>Dangling references, namely references with their referents destroyed already, are dangerous in coding and should be avoided. Luckily, they mostly only occur when we try to return functions by references/addresses.</p>
<p>Last bit but quite shockingly perhaps, <strong>references are not objects</strong>. They may or may not require storage and are not considered objects in C++. As a result, we cannot define a reference to another reference, as an lvalue reference must reference an identifiable object.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> var{};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref1{var};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref2{ref1}; <span style="color:#998;font-style:italic">// referencing var, not ref1
</span></span></span></code></pre></div><h2 id="lvalue-references-to-const">Lvalue references to <code>const</code></h2>
<p>An lvalue reference can not directly reference a <code>const</code> object:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5</span> }; <span style="color:#998;font-style:italic">// x is a non-modifiable (const) lvalue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref { x }; <span style="color:#998;font-style:italic">// error: ref can not bind to non-modifiable lvalue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can use the <code>const</code> keyword on the reference to do that:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref{x};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>in which case we call <code>ref</code> as a <strong>const reference</strong>.</p>
<p>We can also bind a const reference to a modifiable lvalue, which just means we&rsquo;re not going to modify the original object.</p>
<p>Furthermore, we can also bind a const lvalue reference to an rvalue, in which case we effectively <strong>extend the lifetime</strong> of the temporary rvalue object and can safely use the value until the end of the current scope. This does not, however, work with return by (even const) references.</p>
<p>Last and least used, we can define <code>constexpr</code> references in certain cases:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> g_x {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref1{g_x}; <span style="color:#998;font-style:italic">// ok: constexpr ref to global
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> s_x {<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref2{s_x}; <span style="color:#998;font-style:italic">// ok: constexpr ref to static local
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">static</span> <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> s_xc{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref2c{s_xc};  <span style="color:#998;font-style:italic">// ok: constexpr const ref to static const local (...)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">7</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref3{x};   <span style="color:#998;font-style:italic">// compile error: constexpr ref to non-static local
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="pass-by-lvalue-references">Pass by lvalue references</h2>
<p>Some objects are expensive to copy so we prefer to pass them by lvalue references to functions. Also, pass by (non-<code>const</code>) reference allows us to modify the original object within the function.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printValue</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> y) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>    printValue(x); <span style="color:#998;font-style:italic">// ok: x is a modifiable lvalue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> z { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>    printValue(z); <span style="color:#998;font-style:italic">// error: z is a non-modifiable lvalue, cannot be passed as regular lvalue ref
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    printValue(<span style="color:#099">5</span>); <span style="color:#998;font-style:italic">// error: 5 is an rvalue, cannot be passed as lvalue reference
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can fix it by passing by <code>const</code> lvalue reference:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printValue</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> y) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> z{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    printValue(z);  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    printValue(<span style="color:#099">5</span>);  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>We can now answer the question of why we don’t pass everything by reference:</p>
<ul>
<li>For objects that are cheap to copy, the cost of copying is similar to the cost of binding, so we favor pass by value so the code generated will be faster.</li>
<li>For objects that are expensive to copy, the cost of the copy dominates, so we favor pass by (const) reference to avoid making a copy.</li>
</ul>
<p>How do we tell is a type is &ldquo;cheap to copy&rdquo; or not? Below is a function-like macro that tries to answer this question:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Function-like macro that evaluates to true if the type (or object) is
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// equal to or smaller than the size of two memory addresses
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#define isSmall(T) (sizeof(T) &lt;= 2 * sizeof(void*))
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">S</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> c;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>boolalpha;          <span style="color:#998;font-style:italic">// print true or false rather than 1 or 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> isSmall(<span style="color:#458;font-weight:bold">int</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> isSmall(<span style="color:#458;font-weight:bold">double</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> isSmall(S) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;      <span style="color:#998;font-style:italic">// false
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Last not is that it&rsquo;s always better (except if you&rsquo;re using C++14 or older, where <code>std::string_view</code> is not available) to use <code>std::string_view</code> than <code>const std::string&amp;</code> because <code>std::string_view</code> has less expensive copy/initialization than the potential type conversion that happens when we use <code>const std::string&amp;</code>.</p>
<h2 id="introduction-to-pointers-and-the-address-of-operator-">Introduction to pointers and the address-of operator <code>&amp;</code></h2>
<p>The <code>&amp;</code> symbol tends to cause confusion because it has different meanings depending on context:</p>
<ul>
<li>When following a type name, <code>&amp;</code> denotes an lvalue reference: <code>int&amp; ref</code></li>
<li>When used in a unary context in an expression, <code>&amp;</code> is the address-of operator: <code>std::cout &lt;&lt; &amp;x</code></li>
<li>When used in a binary context in an expression, <code>&amp;</code> is the bitwise AND operator: <code>std::cout &lt;&lt; x &amp; y</code></li>
</ul>
<p>Paired with the address-of operator <code>&amp;</code>, we have the dereference operator <code>*</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;     <span style="color:#998;font-style:italic">// prints 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">&amp;</span>x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// prints address of x
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>(<span style="font-weight:bold">&amp;</span>x) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// prints the value at the memory address of x, which is 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>In short, <code>&amp;</code> gives the address of RHS object, and <code>*</code> gives the object of the RHS address.</p>
<p>With this concept in mind, we define a <strong>pointer</strong> as an object that holds a memory address as its value:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x;     <span style="color:#998;font-style:italic">// a normal int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> y;    <span style="color:#998;font-style:italic">// an lvalue reference to an int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> z;    <span style="color:#998;font-style:italic">// a pointer to an int
</span></span></span></code></pre></div><p>Notice we generally recommend putting the dereference operator <code>*</code> next to the type, just like the reference operator <code>&amp;</code>. But when it comes to multiple definitions in the same line, it becomes somewhat awkward:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> x, <span style="font-weight:bold">*</span> z;  <span style="color:#998;font-style:italic">// we CANNOT define them as int* x, y
</span></span></span></code></pre></div><p>but we still would recommend placing <code>*</code> right next to the type and keeping a space between it and the variable - although a better suggestion is to not define multiple variables in the same line.</p>
<p>The size of a pointer is always the same, as it&rsquo;s just the address in the memory represented by a bunch of bits / hexadecimal digits. So on a 32-bit machine, the size of a pointer is always 32 bits (4 bytes), and on a 64-bit machine, it&rsquo;s always 64 bits (8 bytes).</p>
<h2 id="pointer-initialization-and-assignment">Pointer initialization and assignment</h2>
<p>Initialization:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> d{<span style="color:#099">2.2</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> p1;      <span style="color:#998;font-style:italic">// uninitialized pointer (holds garbage address)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> p2{};    <span style="color:#998;font-style:italic">// a null pointer
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> p3{<span style="font-weight:bold">&amp;</span>x};  <span style="color:#998;font-style:italic">// a pointer at address of x
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> p4{<span style="font-weight:bold">&amp;</span>d};  <span style="color:#998;font-style:italic">// error: initializing an int pointer to address of a double
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> p5{<span style="color:#099">5</span>};   <span style="color:#998;font-style:italic">// error: cannot initialize with an int literal
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> p6{ <span style="color:#099">0x0012FF7C</span>};  <span style="color:#998;font-style:italic">// error: 0x0012FF7C is here just an integer literal
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Assignment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr {<span style="font-weight:bold">&amp;</span>x};  <span style="color:#998;font-style:italic">// initializing ptr to address of x
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>y;  <span style="color:#998;font-style:italic">// re-assign ptr to address of y
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">=</span> <span style="color:#099">7</span>;  <span style="color:#998;font-style:italic">// assigning 7 to variable y
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="differences-between-pointers-and-references">Differences between pointers and references</h2>
<ul>
<li>References must be initialized, pointers are not required to (but are recommended to)</li>
<li>References are not objects, pointers are</li>
<li>References can not be reseated, pointers can</li>
<li>References must always be bound to an object, pointers can point to nothing (nullptr)</li>
<li>References are &ldquo;safe&rdquo; (except dangling references), pointers are inherently dangerous</li>
</ul>
<h2 id="null-pointers">Null pointers</h2>
<p>A null pointer (often shortened to just <strong>null</strong>) is a pointer that points at nothing, and the easiest way to create it is by initializing with empty braces:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr {};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr2 { <span style="font-weight:bold">nullptr</span> };  <span style="color:#998;font-style:italic">// more explicit, same result
</span></span></span></code></pre></div><p>Notice that dereferencing a null pointer can lead to undefined behavior. Luckily, we can always check before doing anything:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">&amp;</span>x };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (ptr <span style="font-weight:bold">==</span> <span style="font-weight:bold">nullptr</span>)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;ptr is null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;ptr is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Even simpler, we can rely on the implicit conversion of a pointer to boolean, realizing that a <code>nullptr</code> converts to false, and anything else true.</p>
<p>Notice that we <strong>cannot</strong> use this trick to avoid dangling pointers automatically, as a dangling pointer doesn&rsquo;t necessarily points at a null value, but most of the time rubbish/random stuff.</p>
<h2 id="pointers-and-const">Pointers and const</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr {<span style="font-weight:bold">&amp;</span>x};       <span style="color:#998;font-style:italic">// compile error: const int* -&gt; int*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr{<span style="font-weight:bold">&amp;</span>x};  <span style="color:#998;font-style:italic">// okay
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">=</span> <span style="color:#099">6</span>;            <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>y;            <span style="color:#998;font-style:italic">// okay: just reseating
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> z{<span style="color:#099">7</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr {<span style="font-weight:bold">&amp;</span>z}; <span style="color:#998;font-style:italic">// okay: const int pointer
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">=</span> <span style="color:#099">8</span>;            <span style="color:#998;font-style:italic">// error: cannot change const int value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    z <span style="font-weight:bold">=</span> <span style="color:#099">8</span>;               <span style="color:#998;font-style:italic">// okay
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr {<span style="font-weight:bold">&amp;</span>z}; <span style="color:#998;font-style:italic">// int pointer that is constant
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>y;            <span style="color:#998;font-style:italic">// error: cannot reseat a const pointer
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">=</span> <span style="color:#099">1</span>;            <span style="color:#998;font-style:italic">// okay: ptr is an int pointer, can change value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr{<span style="font-weight:bold">&amp;</span>z};   <span style="color:#998;font-style:italic">// const pointer to const int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="pass-by-value-reference-and-address">Pass by value, reference and address</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_by_value</span>(std<span style="font-weight:bold">::</span>string s) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> s <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_by_reference</span>(std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> s) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> s <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_by_address</span>(std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">*</span> s_ptr) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>s_ptr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string s{<span style="color:#b84">&#34;hello&#34;</span>};
</span></span><span style="display:flex;"><span>    print_by_value(s);        <span style="color:#998;font-style:italic">// making a copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_by_reference(s);    <span style="color:#998;font-style:italic">// not making a copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print_by_address(<span style="font-weight:bold">&amp;</span>s);     <span style="color:#998;font-style:italic">// not making a copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">*</span> s_ptr {<span style="font-weight:bold">&amp;</span>str};
</span></span><span style="display:flex;"><span>    print_by_address(s_ptr);  <span style="color:#998;font-style:italic">// not making a copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>As user might just pass a null pointer to a function, it&rsquo;s still considered dangerous. So we should prefer passing by (const) references.</p>
<p>A little more tricky, what if we want to change a pointer to a null pointer by using a function? One might do this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">nullify</span>(<span style="color:#008080">[[maybe_unused]]</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr) {
</span></span><span style="display:flex;"><span>    ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr{<span style="font-weight:bold">&amp;</span>x};
</span></span><span style="display:flex;"><span>    nullify(ptr);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, <code>ptr</code> will not be <code>nullptr</code> after calling the function, this is because the changing the address held by the pointer parameter has no impact on the address held by the original argument/object. When the function is called, <code>ptr</code> receives a copy of the address (a copy, of <strong>the address</strong>, has indeed happened) and thus whatever happens to within the function, stays with the copied pointer, not the original.</p>
<p>We might pass by the reference of the pointer object, as pointers are objects:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">nullify</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*&amp;</span> refptr) {
</span></span><span style="display:flex;"><span>    refptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and it would work perfectly. Worth noting that it may sound funky <code>int*&amp;</code> but the order actually makes a lot sense, since we&rsquo;re now passing by the (reference of) a (pointer to int), and even better, compiler will actually throw an error if we accidentally do the order wrong, as <code>int&amp;*</code> doesn&rsquo;t make sense for a pointer must hold address for an object, and a reference is not an object, sadly.</p>
<h2 id="return-by-reference-and-address">Return by reference and address</h2>
<p>Returning by reference avoids making a copy:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_program_name() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string s_program_name {<span style="color:#b84">&#34;computer&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> s_program_name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the name of the program is&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> get_program_name();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s generally recommended not to return a non-const static local variable by reference. It&rsquo;s non-trivial that assigning/initializing a normal variable with a returned reference makes a copy:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> get_next_id() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> s_x {<span style="color:#099">0</span>};  <span style="color:#998;font-style:italic">// non-const
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">++</span>s_x;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> s_x;  <span style="color:#998;font-style:italic">// returning a copy, not reference
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> id1 { get_next_id() };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> id2 { get_next_id() };  <span style="color:#998;font-style:italic">// id1 and id2 are NOT references on the same variable
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> id1 <span style="font-weight:bold">&lt;&lt;</span> id2 <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output would be <code>12</code> and that&rsquo;s desired. It&rsquo;s important to realize that <code>id1</code> and <code>id2</code> above are not two references of the same variable. They&rsquo;re returned by value effectively.</p>
<p>One other case where we return by reference is to return the original parameters of the function by reference (when we&rsquo;ve passed them by reference already).</p>
<p>Return by address is almost identical in terms of use case as returning by reference, except that we can potentially return <code>nullptr</code> suggesting &ldquo;nothing&rdquo; is returned. A big disadvantage of returning by address, therefore, is that the user has the obligation to check whether the returned pointer is a null pointer before dereferencing it.</p>
<h2 id="in-and-out-parameters">In and out parameters</h2>
<p>Parameters that are used only for receiving input from the caller are sometimes called <strong>in parameters</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x) {  <span style="color:#998;font-style:italic">// x is an in parameter
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In parameters are usually passed by value or const reference.</p>
<p>A function parameter that is used only for the purpose of returning information back to the caller is called an <strong>out parameter</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cmath&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for sin and cos
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">get_sin_cos</span>(<span style="color:#458;font-weight:bold">double</span> degrees, <span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&amp;</span> sin_out, <span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&amp;</span> cos_out) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> pi { <span style="color:#099">3.14159265358979323846</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> radians <span style="font-weight:bold">=</span> degrees <span style="font-weight:bold">*</span> pi <span style="font-weight:bold">/</span> <span style="color:#099">180.0</span>;
</span></span><span style="display:flex;"><span>    sin_out <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>sin(radians);
</span></span><span style="display:flex;"><span>    cos_out <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>cos(radians);
</span></span><span style="display:flex;"><span>}  <span style="color:#998;font-style:italic">// not returning anything
</span></span></span></code></pre></div><p>We should generally avoid using out parameters except in the rare case where no better options exist.</p>
<h2 id="type-deduction-with-pointers-references-and-const">Type deduction with pointers, references and const</h2>
<p>Type deduction, in addition to dropping <code>const</code> qualifiers, also drops the references:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_string_ref();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ref {get_string_ref()};     <span style="color:#998;font-style:italic">// ref&#39;s type deduced as string instead of string&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> ref2 {get_string_ref()};   <span style="color:#998;font-style:italic">// ref2&#39;s type is string&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In terms of <code>const</code> dropping, type deduction drops the <strong>top-level</strong> <code>const</code> qualifiers (and leave the <strong>low-level</strong> unchanged):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> x;          <span style="color:#998;font-style:italic">// top-level
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr;       <span style="color:#998;font-style:italic">// top-level
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref;       <span style="color:#998;font-style:italic">// low-level
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr;       <span style="color:#998;font-style:italic">// low-level
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ref;       <span style="color:#998;font-style:italic">// low-level, but if reference is dropped... then becomes top-level
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr; <span style="color:#998;font-style:italic">// left const is low-level, right const is top-level
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// top-level const will be dropped, and low-level unched:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> z {x};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> z {ref};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span> z {ptr};
</span></span></code></pre></div><p>Specifically, for const references we have example below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> getConstRef(); <span style="color:#998;font-style:italic">// some function that returns a const reference
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ref1{ getConstRef() };        <span style="color:#998;font-style:italic">// std::string (reference and top-level const dropped)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> ref2{ getConstRef() };  <span style="color:#998;font-style:italic">// const std::string (reference dropped, const reapplied)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> ref3{ getConstRef() };       <span style="color:#998;font-style:italic">// const std::string&amp; (reference reapplied, low-level const not dropped)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> ref4{ getConstRef() }; <span style="color:#998;font-style:italic">// const std::string&amp; (reference and const reapplied)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The best practice is to reapply both reference and <code>const</code> like in <code>ref4</code> to make it more explicit, although the reapplication of <code>const</code> isn&rsquo;t necessary.</p>
<p>All above works identically with <code>constexpr</code>.</p>
<p>When it comes to type deduction with pointers, things are different this time - type deduction don&rsquo;t drop pointers at all:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">*</span> get_string_ptr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr { get_string_ptr() };     <span style="color:#998;font-style:italic">// ptr is string*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> ptr2 { get_string_ptr() };   <span style="color:#998;font-style:italic">// also string* just better explicity
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the above example, <code>ptr</code> and <code>ptr2</code> are effectively the same. However, as a pointer type must resolve to a pointer initializer, they can differ in certain situation, for example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr {<span style="font-weight:bold">*</span>get_string_ptr()};     <span style="color:#998;font-style:italic">// type is string
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> ptr2 {<span style="font-weight:bold">*</span>get_string_ptr()};   <span style="color:#998;font-style:italic">// compile error, as initializer is not a pointer
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>Another difference occurs when we introduce <code>const</code> pointers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> <span style="font-weight:bold">const</span> ptr2 {get_string_ptr()};      <span style="color:#998;font-style:italic">// string* const (const pointer)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> ptr1 {get_string_ptr()};      <span style="color:#998;font-style:italic">// string* const (const pointer)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr4 {get_string_ptr()};     <span style="color:#998;font-style:italic">// string* const (const pointer)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> ptr3 {get_string_ptr()};     <span style="color:#998;font-style:italic">// const string* (pointer to const)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>A maybe better example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string s{};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr {<span style="font-weight:bold">&amp;</span>s};  <span style="color:#998;font-style:italic">// const string* const
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr1{ptr};              <span style="color:#998;font-style:italic">// const string* (top-level const droppped)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> ptr2{ptr};             <span style="color:#998;font-style:italic">// const string*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> <span style="font-weight:bold">const</span> ptr3{ptr};        <span style="color:#998;font-style:italic">// const string* const (top-level const reapplied)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> ptr4(ptr);        <span style="color:#998;font-style:italic">// const string* const
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr5{ptr};       <span style="color:#998;font-style:italic">// const string* const
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> ptr6{ptr};       <span style="color:#998;font-style:italic">// const string* (only const auto* is different... const for low-level only)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> <span style="font-weight:bold">const</span> ptr7{ptr};  <span style="color:#998;font-style:italic">// error: (const auto) = (const string* const) already. applying duplicate const
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> ptr8{ptr}; <span style="color:#998;font-style:italic">// const string* const (the right const is for top-level reapplication)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h1 id="compound-types-enums-and-structs">Compound Types: Enums and Structs</h1>
<h2 id="unscoped-enumerations">Unscoped enumerations</h2>
<p>Let&rsquo;s say we want to define a bunch of colors, the most basic way is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> red {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> green {<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> blue {<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> apple_color {red};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> shirt_color {green};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which is not intuitive and involves magic numbers. We can define the colors as <code>constexpr</code> instead, to make it better for reading:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> red {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> green {<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> blue {<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> apple_color {red};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> shirt_color {green};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Or even, to avoid using type <code>int</code>, we can use type alias:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">using</span> Color <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">int</span>;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> Color red {<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> Color green {<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> Color blue {<span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Color apple_color {red};
</span></span><span style="display:flex;"><span>    Color shirt_color {green};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, this doesn&rsquo;t prevent somebody to initialize a <code>Color</code> variable like</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Color something {<span style="color:#099">9</span>};
</span></span></code></pre></div><p>as <code>Color</code> is nothing but an alias of <code>int</code>.</p>
<p>We can use an <strong>enumeration</strong> (also known as <strong>enum</strong>) in this case. C++ supports two kinds of enumerations, unscoped and scoped. Here we talk about unscoped enums:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> {
</span></span><span style="display:flex;"><span>    red,
</span></span><span style="display:flex;"><span>    green,
</span></span><span style="display:flex;"><span>    blue,  <span style="color:#998;font-style:italic">// trailing comma optional but recommended
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};  <span style="color:#998;font-style:italic">// the enum definition ends with a semicolon, it&#39;s just a definition statement
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Pet</span> {
</span></span><span style="display:flex;"><span>    cat,
</span></span><span style="display:flex;"><span>    dog,
</span></span><span style="display:flex;"><span>    pig,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Color apple_color {red};
</span></span><span style="display:flex;"><span>    Color shirt_color {green};
</span></span><span style="display:flex;"><span>    Color cup_color {blue};
</span></span><span style="display:flex;"><span>    Color socks_color {white};  <span style="color:#998;font-style:italic">// error: white not in Color
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Color hat_color {<span style="color:#099">9</span>};        <span style="color:#998;font-style:italic">// error: 2 is not in Color
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Color some_color {pig};     <span style="color:#998;font-style:italic">// error: pig is not in Color
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting that by default the enumerators are automatically assigned corresponding integer values from 0. If we explicitly assign the enumerator to a value, automatic incrementation would apply:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> {
</span></span><span style="display:flex;"><span>    red <span style="font-weight:bold">=</span> <span style="font-weight:bold">-</span><span style="color:#099">3</span>,
</span></span><span style="display:flex;"><span>    blue,       <span style="color:#998;font-style:italic">// assigned -2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    green,      <span style="color:#998;font-style:italic">// assigned -1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    yellow <span style="font-weight:bold">=</span> <span style="color:#099">3</span>, <span style="color:#998;font-style:italic">// assigned 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    orange <span style="font-weight:bold">=</span> <span style="color:#099">3</span>, <span style="color:#998;font-style:italic">// also assigned 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    black,      <span style="color:#998;font-style:italic">// assigned 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>and the corresponding integral values will be automatically used when e.g. passed to <code>std::cout</code>. If we want to print the name instead of integer value, we need to explicit tell the compiler to do so:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>string_view get_color(Color color) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (color) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> black:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;black&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> red:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;red&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// etc
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;???&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Even better, we may just directly overload the <code>&lt;&lt;</code> operator for <code>std::cout</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> out, Color color) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (color) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> black:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> out <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;black&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> red:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> out <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;red&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// etc
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> out <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;???&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can specify the used integral type by an enum if we want to:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> <span style="font-weight:bold">:</span> std<span style="font-weight:bold">::</span><span style="color:#458;font-weight:bold">int8_t</span> {
</span></span><span style="display:flex;"><span>    black,
</span></span><span style="display:flex;"><span>    red,
</span></span><span style="display:flex;"><span>    white,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Another potentially relevant topic is how we convert integer to enumerator (the other way round is easy):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> {
</span></span><span style="display:flex;"><span>    red,
</span></span><span style="display:flex;"><span>    black,
</span></span><span style="display:flex;"><span>    yellow,
</span></span><span style="display:flex;"><span>    orange,
</span></span><span style="display:flex;"><span>    blue,
</span></span><span style="display:flex;"><span>    green,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Color color {<span style="color:#099">5</span>};         <span style="color:#998;font-style:italic">// compile error: cannot implicit convert
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    color <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;               <span style="color:#998;font-style:italic">// compile error: cannot implicit convert
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Color color {<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>Color<span style="font-weight:bold">&gt;</span>(<span style="color:#099">3</span>)};  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    color <span style="font-weight:bold">=</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>Color<span style="font-weight:bold">&gt;</span>(<span style="color:#099">2</span>);        <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we set an explicit base type for the enum, then implicit conversion would work (for brace initialization):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> <span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>    red,
</span></span><span style="display:flex;"><span>    black,
</span></span><span style="display:flex;"><span>    yellow,
</span></span><span style="display:flex;"><span>    orange,
</span></span><span style="display:flex;"><span>    blue,
</span></span><span style="display:flex;"><span>    green,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Color color {<span style="color:#099">5</span>};   <span style="color:#998;font-style:italic">// ok for brace initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Color color2(<span style="color:#099">2</span>);   <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Color color3 <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;  <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    color <span style="font-weight:bold">=</span> <span style="color:#099">2</span>;         <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For the same reason we cannot simply <code>&gt;&gt;</code> input an enumerator. We can use <code>static_cast</code> to explicitly convert an inputted integer to an enumerator type, or we can overload the <code>&gt;&gt;</code> operator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>istream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&gt;&gt;</span>(std<span style="font-weight:bold">::</span>istream<span style="font-weight:bold">&amp;</span> in, Color<span style="font-weight:bold">&amp;</span> color) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> input{};
</span></span><span style="display:flex;"><span>    in <span style="font-weight:bold">&gt;&gt;</span> input;
</span></span><span style="display:flex;"><span>    color <span style="font-weight:bold">=</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>Color<span style="font-weight:bold">&gt;</span>(input);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> in;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Enumerated typed can be useful in production for error codes:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">FileReadResult</span> {
</span></span><span style="display:flex;"><span>    readResultSuccess,
</span></span><span style="display:flex;"><span>    readResultErrorFileOpen,
</span></span><span style="display:flex;"><span>    readResultErrorFileRead,
</span></span><span style="display:flex;"><span>    readResultErrorFileParse,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FileReadResult <span style="color:#900;font-weight:bold">readFileContents</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>openFile())
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> readResultErrorFileOpen;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>readFile())
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> readResultErrorFileRead;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>parseFile())
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> readResultErrorFileParse;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> readResultSuccess;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (readFileContents() <span style="font-weight:bold">==</span> readResultSuccess)
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// print error message
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and for limited parameter values:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">SortOrder</span> {
</span></span><span style="display:flex;"><span>    alphabetical,
</span></span><span style="display:flex;"><span>    alphabeticalReverse,
</span></span><span style="display:flex;"><span>    numerical,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">sort_data</span>(SortOrder order) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (order) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> alphabetical:
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// something
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> alphabeticalReverse:
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// something
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> numeral:
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// something
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// raise error?
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that when the scope is valid, we can use both <code>red</code> and <code>Color::red</code> per our preference. This means our namespace is, unfortunately, always polluted by such enums. We can avoid that by wrapping enums inside corresponding <code>namespaces</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Color {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> {
</span></span><span style="display:flex;"><span>        red,
</span></span><span style="display:flex;"><span>        green,
</span></span><span style="display:flex;"><span>        blue,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="scoped-enumerations-enum-class">Scoped enumerations (enum class)</h2>
<p>Check the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span> {
</span></span><span style="display:flex;"><span>        red,
</span></span><span style="display:flex;"><span>        blue,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Fruit</span> {
</span></span><span style="display:flex;"><span>        banana,
</span></span><span style="display:flex;"><span>        apple,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Color color { red };
</span></span><span style="display:flex;"><span>    Fruit fruit { banana };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (color <span style="font-weight:bold">==</span> fruit) <span style="color:#998;font-style:italic">// The compiler will compare color and fruit as integers
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;color and fruit are equal</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; <span style="color:#998;font-style:italic">// and find they are equal!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;color and fruit are not equal</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To solve this problem, we can either rely on users to use explicit <code>Color::red</code> everywhere and that they won&rsquo;t compare <code>Color::red</code> versus <code>Fruit::banana</code>, or, we can instead use the scoped enumerations (also known as <strong>enum class</strong>es):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Color</span> { <span style="color:#998;font-style:italic">// &#34;enum class&#34; defines this as a scoped enumeration rather than an unscoped enumeration
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        red, <span style="color:#998;font-style:italic">// red is considered part of Color&#39;s scope region
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        blue,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Fruit</span> {
</span></span><span style="display:flex;"><span>        banana, <span style="color:#998;font-style:italic">// banana is considered part of Fruit&#39;s scope region
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        apple,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Color color { Color<span style="font-weight:bold">::</span>red }; <span style="color:#998;font-style:italic">// note: red is not directly accessible, we have to use Color::red
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Fruit fruit { Fruit<span style="font-weight:bold">::</span>banana }; <span style="color:#998;font-style:italic">// note: banana is not directly accessible, we have to use Fruit::banana
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">if</span> (color <span style="font-weight:bold">==</span> fruit) <span style="color:#998;font-style:italic">// compile error: the compiler doesn&#39;t know how to compare different types Color and Fruit
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;color and fruit are equal</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;color and fruit are not equal</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that here <code>class</code> is just an &ldquo;overly&rdquo; overloaded keyword and doesn&rsquo;t suggest <code>Color</code> and <code>Fruit</code> are of &ldquo;class type&rdquo;. They are just scoped enumerator types, and the real class types are <code>struct</code>, <code>class</code> and <code>union</code>.</p>
<p>Another thing that a scoped enum is different from unscoped enum, is that they <strong>don&rsquo;t</strong> implicitly convert to integers.</p>
<p>Last but not least, if we find ourselves in a situation where we really have to &ldquo;import&rdquo; all the enumerators into a scope, we can always un-scope an enum by <code>using enum</code> statements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>string_view get_color(Color color) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> <span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Color</span>;  <span style="color:#998;font-style:italic">// just in this scope, get rid of all Color:: namespaces
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">switch</span> (color) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> black: <span style="color:#998;font-style:italic">//  instead of Color::black
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;black&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> red:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;red&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// etc
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">default</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;???&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="introduction-to-structs-members-and-member-selection">Introduction to structs, members and member selection</h2>
<p>Below is an example of a struct definition:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> id {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> age {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> wage {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Employee aaron;   <span style="color:#998;font-style:italic">// not initialized; no error, but we don&#39;t know what aaron.wage would be
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Employee joe {};  <span style="color:#998;font-style:italic">// deafult initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    joe.id <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;       <span style="color:#998;font-style:italic">// updating member variables
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    joe.age <span style="font-weight:bold">=</span> <span style="color:#099">32</span>;
</span></span><span style="display:flex;"><span>    joe.wage <span style="font-weight:bold">=</span> <span style="color:#099">50000.0</span>;
</span></span><span style="display:flex;"><span>    Employee frank {<span style="color:#099">1</span>, <span style="color:#099">22</span>, <span style="color:#099">60000.0</span>};   <span style="color:#998;font-style:italic">// aggregation initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Employee bob {<span style="color:#099">2</span>, <span style="color:#099">50</span>};              <span style="color:#998;font-style:italic">// aggregation initialization w/ partial missing to default; ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> Employee lucy{};             <span style="color:#998;font-style:italic">// const struct; must be initialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Employee zoe (<span style="color:#099">10</span>, <span style="color:#099">38</span>, <span style="color:#099">30000.0</span>);    <span style="color:#998;font-style:italic">// direct initialization (C++20, not recommended)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The last type of initialization is only valid after C++20 and is not recommended, as it doesn&rsquo;t currently work with aggregates that utilize brace elision (notably <code>std::array</code>).</p>
<p>In the cases where we have a number of members to initialize in order, it might be messy when we all of a sudden introduce a new member:</p>
<p>Old:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> a {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> c {};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Foo foo {<span style="color:#099">1</span>, <span style="color:#099">2</span>}; <span style="color:#998;font-style:italic">// foo.a=1, foo.c=2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>New:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> a {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> b {};  <span style="color:#998;font-style:italic">// just added
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> c {};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Foo foo {<span style="color:#099">1</span>, <span style="color:#099">2</span>};  <span style="color:#998;font-style:italic">// note now foo.a=1 foo.b=2, foo.c=0!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To avoid this kind of bug-prone design, we can use designated initializers (available since C++20):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Foo foo {.a{<span style="color:#099">1</span>}, .c{<span style="color:#099">3</span>}};       <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Foo foo {.a<span style="font-weight:bold">=</span><span style="color:#099">1</span>, .c<span style="font-weight:bold">=</span><span style="color:#099">3</span>};         <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Foo foo {.b{<span style="color:#099">2</span>}, .a{<span style="color:#099">1</span>}};       <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    foo <span style="font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">32</span>, <span style="color:#099">20</span>};            <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    foo <span style="font-weight:bold">=</span> {.a<span style="font-weight:bold">=</span><span style="color:#099">1</span>, .b<span style="font-weight:bold">=</span><span style="color:#099">32</span>, .c<span style="font-weight:bold">=</span><span style="color:#099">100</span>};  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Besides designated initialization, we can also initialize a struct using another:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Foo x <span style="font-weight:bold">=</span> foo;  <span style="color:#998;font-style:italic">// copy initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Foo <span style="color:#900;font-weight:bold">x</span>(foo);   <span style="color:#998;font-style:italic">// direct initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Foo x {foo};  <span style="color:#998;font-style:italic">// list initialization
</span></span></span></code></pre></div><h2 id="default-member-initialization">Default member initialization</h2>
<p>When we define a struct (or class) type, we can provide a default initialization value for each member as part of the type definition. This process is called <strong>non-static member initialization</strong>, and the initialization value is called a <strong>default member initializer</strong>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Something</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> z {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Something s1; <span style="color:#998;font-style:italic">// s1.x is uninitialized (value initialized to 0); s1.y=0; s1.z=2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Something s2 { <span style="color:#099">5</span>, <span style="color:#099">6</span>, <span style="color:#099">7</span>}; <span style="color:#998;font-style:italic">// s2.x=5; s2.y=6; s2.z=7
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="passing-and-returning-structs">Passing and returning structs</h2>
<p>We can pass structs by const references to avoid making copies:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> id {}
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> age {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> wage {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print_employee</span>(<span style="font-weight:bold">const</span> Employee<span style="font-weight:bold">&amp;</span> employee) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;id=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> employee.id
</span></span><span style="display:flex;"><span>              <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, age=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> employee.age
</span></span><span style="display:flex;"><span>              <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, wage=&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> employee.wage
</span></span><span style="display:flex;"><span>              <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>we can also return structs, but this time usually by values, as to not return a dangling reference. Note that thanks to return type deducing, we don&rsquo;t need to initialize a struct first, return by value and let compiler copy initialize it again - we can just pass the list that compiler may use to initialize the struct and let type deduction work:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Employee <span style="color:#900;font-weight:bold">get_employee</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> Employee(<span style="color:#099">1</span>, <span style="color:#099">23</span>, <span style="color:#099">10&#39;000</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// is the same as
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>Employee <span style="color:#900;font-weight:bold">get_employee</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> {<span style="color:#099">1</span>, <span style="color:#099">23</span>, <span style="color:#099">10&#39;000</span>};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="nested-structs">Nested structs</h2>
<p>Once we have a struct defined, we can define another that houses it:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// assuming we have `Employee` defined already
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Company</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> number_of_employees {};
</span></span><span style="display:flex;"><span>    Employee CEO {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Company my_company {<span style="color:#099">7</span>, {<span style="color:#099">1</span>, <span style="color:#099">23</span>, <span style="color:#099">10&#39;000</span>}};  <span style="color:#998;font-style:italic">// nested list initilization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>We can even wrap the type definition inside the second one, if we believe it&rsquo;s not necessary to be exposed to global level:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Company</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> id {}
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> age {};
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">double</span> wage {};
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> number_of_employees {};
</span></span><span style="display:flex;"><span>    Employee CEO {};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>With this structure, we can now only access the <code>Employee</code> struct via <code>Company::Employee</code>.</p>
<h2 id="the-size-of-structs">The size of structs</h2>
<p>The size of a struct is <strong>NOT</strong> equal to the size of all its members, but <strong>AT LEAST AT LARGE AS</strong> of the sum of all sizes:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Foo1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> a {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">short</span> b {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">short</span> c {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Foo2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">short</span> a {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> b {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">short</span> c {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the size of int is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; bytes</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the size of short is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">short</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; bytes</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the size of Foo1 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(Foo1) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; bytes</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the size of Foo2 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(Foo2) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; bytes</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output would be</p>
<pre tabindex="0"><code>the size of int is 4 bytes
the size of short is 2 bytes
the size of Foo1 is 8 bytes
the size of Foo2 is 12 bytes
</code></pre><p>The size of <code>Foo1</code> and <code>Foo2</code> are different merely because of the order of member declarations. That is related to the data structure alignment which is a more advanced topic.</p>
<h2 id="member-selection-with-pointer-and-references">Member selection with pointer and references</h2>
<p>We can access the members of a struct via itself (object) using <code>.</code>, via its reference using <code>.</code>, and via its pointer using <code>-&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// assuming we have `Employee` defined
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Employee john {<span style="color:#099">1</span>, <span style="color:#099">23</span>, <span style="color:#099">10&#39;000</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> john.id <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;     <span style="color:#998;font-style:italic">// object.member
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> Employee<span style="font-weight:bold">&amp;</span> john2 {john};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> john2.id <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// reference.member
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> Employee<span style="font-weight:bold">*</span> ptr {<span style="font-weight:bold">&amp;</span>john};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ptr<span style="font-weight:bold">-&gt;</span>id <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;     <span style="color:#998;font-style:italic">// pointer-&gt;member
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="class-templates">Class templates</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Pair</span> {
</span></span><span style="display:flex;"><span>    T x {};
</span></span><span style="display:flex;"><span>    T y {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;&gt;</span> <span style="color:#998;font-style:italic">// tells the compiler we&#39;re not using template parameter
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Pair</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> n {};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>We can define function under template along with the struct:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Pair</span> {
</span></span><span style="display:flex;"><span>    T x {};
</span></span><span style="display:flex;"><span>    T y {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> T max(Pair<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;</span> p) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (p.x <span style="font-weight:bold">&lt;</span> p.y <span style="font-weight:bold">?</span> p.y : p.x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can use class templates across multiple files, as long as we put the definitions in (and include properly, into source files) the header files:</p>
<p>pair.h:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef PAIR_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define PAIR_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Pair</span> {
</span></span><span style="display:flex;"><span>    T first {};
</span></span><span style="display:flex;"><span>    T second {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> T max(Pair<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;</span> p) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (p.first <span style="font-weight:bold">&lt;</span> p.second <span style="font-weight:bold">?</span> p.second : p.first);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>foo.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;pair.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">foo</span>() {
</span></span><span style="display:flex;"><span>    Pair<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> p1{<span style="color:#099">1</span>,<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> max(p1) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#a61717;background-color:#e3d2d2">&#39;</span> is larger<span style="color:#a61717;background-color:#e3d2d2">\</span>n<span style="color:#a61717;background-color:#e3d2d2">&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>main.cpp:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;pair.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">foo</span>();  <span style="color:#998;font-style:italic">// forward declaration
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>    Pair<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span> p2{<span style="color:#099">1.2</span>, <span style="color:#099">2.3</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> max(p2) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;is larger</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Starting from C++17, when instantiating an object from a class template, the compiler can deduce the template types from the types of the object&rsquo;s initializer, which is called <strong>class template argument deduction</strong> or <strong>CTAD</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;utility&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::pair
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>pair<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> p1 {<span style="color:#099">1</span>, <span style="color:#099">2</span>};    <span style="color:#998;font-style:italic">// p1 has explicit type std::pair&lt;int, int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>pair p2 {<span style="color:#099">1</span>,<span style="color:#099">2</span>};               <span style="color:#998;font-style:italic">// p2 is deduced to be of type std::pair&lt;int, int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>pair<span style="font-weight:bold">&lt;&gt;</span> p3 {<span style="color:#099">1</span>,<span style="color:#099">2</span>};             <span style="color:#998;font-style:italic">// error: too few template arguments, both arguments not deduced
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>pair<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> p4 {<span style="color:#099">1</span>,<span style="color:#099">2</span>};          <span style="color:#998;font-style:italic">// error: too few template arguments, second argument not deduced
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>We can omit the argument type specification for good to utilize this feature, but notice in above example that we cannot omit only a few of the types, nor can we leave empty brackets <code>&lt;&gt;</code>.</p>
<p>Another thing to keep in mind is that, although C++17 introduced CTAD, it doesn&rsquo;t work all the time in C++17. In the following example, the program doesn&rsquo;t compile and throws some error like &ldquo;class template argument deduction failed&rdquo; in C++17 (but compiles fine in C++20, because C++20 can automatically generate deduction guides). This is when we need to hint the compiler with some <strong>deduction guide</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, <span style="font-weight:bold">typename</span> U<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Pair</span> {
</span></span><span style="display:flex;"><span>    T first {};
</span></span><span style="display:flex;"><span>    U second {};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// without the following deduction guide, we will have a compile error:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, <span style="font-weight:bold">typename</span> U<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>Pair(T, U) <span style="font-weight:bold">-&gt;</span> Pair<span style="font-weight:bold">&lt;</span>T, U<span style="font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Pair p {<span style="color:#099">1</span>,<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In addition to deduction guide, we can also provide the default type for type template parameters (so C++17 can fall back to the default types when it cannot decide):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">=</span><span style="color:#458;font-weight:bold">int</span>, <span style="font-weight:bold">typename</span> U<span style="font-weight:bold">=</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Pair</span> {
</span></span><span style="display:flex;"><span>    T first {};
</span></span><span style="display:flex;"><span>    U second {};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>This is also what happens when we define a variable as just <code>Pair p</code> without initializer.</p>
<p>Last thing to remember, is that CTAD <strong>doesn&rsquo;t work</strong> with non-static member initialization. In other words, it cannot work inside another struct:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>pair p {<span style="color:#099">1</span>,<span style="color:#099">2</span>};  <span style="color:#998;font-style:italic">// error: CTAD doesn&#39;t work here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><h2 id="alias-templates">Alias templates</h2>
<p>We can create a type alias for a class template where all template arguments are specified:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// assuing we have defined `Pair` struct
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> Point <span style="font-weight:bold">=</span> Pair<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span>    Point p {<span style="color:#099">1</span>,<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Instead of <code>using</code> explicit templates, we can also created <strong>alias template</strong> which is an alias regardless of template argument:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// assuming we have defined `Pair` struct
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> Coord <span style="font-weight:bold">=</span> Pair<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;</span>;
</span></span></code></pre></div><h1 id="introduction-to-classes">Introduction to Classes</h1>
<h2 id="classes-vs-structs">Classes vs structs</h2>
<p>A class is define as follows</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_id {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_age {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> m_wage {};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Notice the ending semicolon as class declaration is also considered a statement. It&rsquo;s apparent that classes are very similar to structs:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> id {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> age {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> wage {};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Both class and struct can have member functions, except that a struct&rsquo;s constructor cannot be user-defined.</p>
<p>The difference lies in the accesibility of their members, which we will cover in the following sections.</p>
<h2 id="const-class-objects-and-const-member-functions">Const class objects and const member functions</h2>
<p>There are some rules concerning the const-ness of the class object and its members.</p>
<ul>
<li>
<p>You <strong>cannot</strong> modify the members of a const class object.</p>
</li>
<li>
<p>You <strong>cannot</strong> call a non-const member function of a const class object.</p>
<p>So make the function const if you need to.</p>
</li>
<li>
<p>You <strong>can</strong> call a const member function of a non-const class object.</p>
</li>
<li>
<p>When passing a class object by const reference, it&rsquo;s considered a const class object inside the function.</p>
</li>
<li>
<p>You <strong>can</strong> overload a non-const function with its const version and vice versa</p>
</li>
</ul>
<h2 id="public-and-private-members-and-access-specifiers">Public and private members and access specifiers</h2>
<p>By default, the members of a struct are public and the members of a class are private. That is why in convention it is recommended to name member variables of classes with a prefix <code>m_</code> suggesting that they&rsquo;re private members (same logic goes with <code>s_</code> for static and <code>g_</code> for global variables).</p>
<p>We can set the access levels via access specifiers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Date</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> print() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> m_year <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;/&#39;</span> <span style="font-weight:bold">&lt;&lt;</span> m_month <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;/&#39;</span> <span style="font-weight:bold">&lt;&lt;</span> m_day;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_year {<span style="color:#099">2024</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_month {<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_date {<span style="color:#099">28</span>};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Together with protected members, we have the full summary of access level within classes:
p| Access           | Member Access   | Derived Class Access | Public Access   |</p>
<table>
<thead>
<tr>
<th>Access</th>
<th>Member Access</th>
<th>Derived Class Access</th>
<th>Public Access</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>protected</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>private</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>where &ldquo;derived class access&rdquo; means whether the derived class object can access its parent&rsquo;s member.</p>
<p>In practice, we&rsquo;re best to avoid using access specifiers for structs altogether, while keeping all data members of a class private (or protected) if possible. Classes normally have public member functions if they&rsquo;re intended user interface.</p>
<h2 id="the-benefits-of-encapsulation">The benefits of encapsulation</h2>
<p>There are quite a few benefits in encapsulating data and functions inside a class:</p>
<ul>
<li>Class becomes easier to use with less complexity</li>
<li>Data hiding allows us to maintain invariants</li>
<li>Easier error detection/handling and debugging!</li>
<li>Encapsulation makes it possible to change implementation without breaking existing programs</li>
</ul>
<p>That being said, when a function can totally be implemented as a non-member function, it is always recommended to do so instead of blindly adding to the encapsulation. This makes the class more light-weighted and straightforward.</p>
<h2 id="introduction-to-constructors">Introduction to constructors</h2>
<p>A constructor is a special member function that is automatically called after a non-aggregate class type object is created.</p>
<p>Constructors must have the same name as the class (with the same capitalization). For template classes, this name excludes the template parameters. Constructors have no return type (not even void). Below is a simple example of a class with constructor defined:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_x {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_y {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Foo(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) { <span style="color:#998;font-style:italic">// here&#39;s our constructor function that takes two initializers
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Foo(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;) constructed</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Foo(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> m_x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> m_y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;)</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Foo foo{ <span style="color:#099">6</span>, <span style="color:#099">7</span> }; <span style="color:#998;font-style:italic">// calls Foo(int, int) constructor
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    foo.print();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can list initialize the members of the class inside the constructor:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    Foo(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y)<span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        m_x {x}, m_y {y} {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Foo(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;) constructed</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Notice that the member initialization happens in the order of the member variables&rsquo; definitions, instead of the list initialization.</p>
<h2 id="default-constructors">Default constructors</h2>
<p>A class comes without explicit definition a default constructor:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Foo() {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>We can customize the default constructor by modifying the constructor body. However, a class can only have one default constructor, so we cannot define a default constructor without arguments, and define another one with all-default arguments.</p>
<p>In practice, it is recommended to write explicit default constructor instead of leaving the empty body:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Foo() <span style="font-weight:bold">=</span> <span style="font-weight:bold">default</span>;  <span style="color:#998;font-style:italic">// instead of empty body
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>It&rsquo;s more than just an asthetic difference: user defined default constructor with empty body won&rsquo;t zero-initialize the member variables if we forgot to:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">UserDefault</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_x;  <span style="color:#998;font-style:italic">// not initialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> m_y {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    UserDefault() {}
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> m_x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> m_y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">ExplicitDefault</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_x;  <span style="color:#998;font-style:italic">// not initialized 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> m_y {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    ExplicitDefault() <span style="font-weight:bold">=</span> <span style="font-weight:bold">default</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> m_x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> m_y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    UserDefault ud{};
</span></span><span style="display:flex;"><span>    ud.print();
</span></span><span style="display:flex;"><span>    ExplicitDefault ed{};
</span></span><span style="display:flex;"><span>    ed.print();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The fisrt will print <code>85 0</code> instead of <code>0 0</code> in this case.</p>
<h2 id="delegating-constructors">Delegating constructors</h2>
<p>Constructors are allowed to delegate (transfer responsibility for) initilization to another constructor from the same class type. This process is sometimes called <strong>constructor chaining</strong> and such constructors are called <strong>delegating constructors</strong>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_id {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Employee(std<span style="font-weight:bold">::</span>string_view name)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">:</span> Employee(name, <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>We can, however, in this case reduce the constructor by using default arguments:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_id {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Employee(std<span style="font-weight:bold">::</span>string_view name, <span style="color:#458;font-weight:bold">int</span> id <span style="font-weight:bold">=</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">:</span> m_name {name}
</span></span><span style="display:flex;"><span>    , m_id {id} {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Employee(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> id <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;)</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="copy-constructors">Copy constructors</h2>
<p>If you don&rsquo;t provide one explicitly, C++ will create a public implicit copy constructor for you. By default, a copy constructor does memberwise initializations and nothing else.</p>
<p>If you decide to provide a customized copy constructor (not recommended), you should avoid doing anything other than copying, and remember to always pass a const reference in the parameter.</p>
<p>You can explicitly use the <code>default</code> specifier just like the default constructor, if you prefer to have an explicit copy constructor.</p>
<p>You can also use <code>delete</code> to prevent copies and throw compile errors if a copy on the underlying class isn&rsquo;t desired:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Fraction</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Fraction(<span style="font-weight:bold">const</span> Fraction<span style="font-weight:bold">&amp;</span> fraction) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;  <span style="color:#998;font-style:italic">// throw compile error if copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>There is a concept called &ldquo;copy ellision&rdquo; which basically describes an optimization by compiler that turns</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Something s {Something (<span style="color:#099">5</span>)};
</span></span></code></pre></div><p>into</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Something s {<span style="color:#099">5</span>};
</span></span></code></pre></div><p>so that redundant copy is skipped (or rather, elided). Copy ellision was optional before C++17 and became mandatory afterwards.</p>
<h2 id="explicit-constructors">Explicit constructors</h2>
<p>While C++ supports implicit conversion, <strong>only one user-defined conversion may be applied</strong> each time. This means implicit conversion sometimes has to be converted to (partially, at least) explicit definitions. Meanwhile, sometimes we need to explicity from the user-passed argument and such implicit conversion may cause confusion. To solve such problems, we can specify a constructor to be explicit:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Dollars</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_dollars {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">explicit</span> Dollars(<span style="color:#458;font-weight:bold">int</span> d)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">:</span> m_dollars{d} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(Dollars d) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;$&#39;</span> <span style="font-weight:bold">&lt;&lt;</span> d.getDollars() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">5</span>);            <span style="color:#998;font-style:italic">// prints 5, no confusion/conversion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    print(Dollars{<span style="color:#099">5</span>});   <span style="color:#998;font-style:italic">// prints $5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h1 id="more-on-classes">More on Classes</h1>
<h2 id="the-hidden-this-pointer-and-member-function-chaining">The hidden <code>this</code> pointer and member function chaining</h2>
<p>Inside every member function, the keyword <code>this</code> is a const pointer that holds the address of the current implicit object.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Simple</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_id {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Simple(<span style="color:#458;font-weight:bold">int</span> id)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">:</span> m_id {id}{
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">setID</span>(<span style="color:#458;font-weight:bold">int</span> id) {
</span></span><span style="display:flex;"><span>        m_id <span style="font-weight:bold">=</span> id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> m_id <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>  <span style="color:#998;font-style:italic">// this is the same as
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">this</span><span style="font-weight:bold">-&gt;</span>m_id   <span style="color:#998;font-style:italic">// this with explicit this-&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>As a refresher of pointers, <code>this-&gt;m_id</code> is equivalently <code>(*this).m_id</code>.</p>
<p>How the compiler rewrites the <code>setID</code> function is that it turns the function to a static function with <code>this</code> being its first argument:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">setID</span>(Simple<span style="font-weight:bold">*</span> <span style="font-weight:bold">const</span> <span style="font-weight:bold">this</span>, <span style="color:#458;font-weight:bold">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">this</span><span style="font-weight:bold">-&gt;</span>m_id <span style="font-weight:bold">=</span> id;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For my fellow Python users, here <code>static</code> is the same as <code>@staticmethod</code> in concept. That means the function is nothing but similar to a normal function.</p>
<p>In general, despite being more explicit, it is not recommended to use <code>this-&gt;</code> everywhere. Instead, using the <code>m_</code> prefix is a much more concise way while doing the same effect.</p>
<p>In addition to using <code>this</code> to access and set member variables, we can also use <code>this</code> to chain up consecutive function calls. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Calc</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> add(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">+=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">sub</span>(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">-=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">mul</span>(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>    <span style="color:#a61717;background-color:#e3d2d2">```</span>m_value <span style="font-weight:bold">*=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getVaue</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above class requires us to do consecutive calculation in the following manner:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Calc calc{};
</span></span><span style="display:flex;"><span>    calc.add(<span style="color:#099">5</span>);
</span></span><span style="display:flex;"><span>    calc.sub(<span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span>    calc.mul(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> calc.getValue() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Instead of above we can do a much concise calculation by using <code>this</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Calc</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Calc<span style="font-weight:bold">&amp;</span> add(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">+=</span> value;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Calc<span style="font-weight:bold">&amp;</span> sub(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">-=</span> value;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Calc<span style="font-weight:bold">&amp;</span> mul(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">*=</span> value;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getValue</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Calc calc{};
</span></span><span style="display:flex;"><span>    calc
</span></span><span style="display:flex;"><span>        .add(<span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>        .sub(<span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>        .mul(<span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> calc.getValue() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also reset a class object back to its default state by</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">reset</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span> <span style="font-weight:bold">=</span> {};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting that <code>this</code> was added to C++ before reference was a thing, and should it be done today, it would definitely be implemented as a self reference, just like many other moderner languages.</p>
<h2 id="classes-and-header-files">Classes and header files</h2>
<p>To address the problem of larger and larger classes, C++ allows us to separate the declaration from class member function definitions. For example,</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Date</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_year;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_month;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_day;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>  <span style="color:#998;font-style:italic">// a bunch of declarations only below
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Date(<span style="color:#458;font-weight:bold">int</span> year, <span style="color:#458;font-weight:bold">int</span> month, <span style="color:#458;font-weight:bold">int</span> day);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() <span style="font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getYear</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_year};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getMonth</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_month};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getDay</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_day};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Date<span style="font-weight:bold">::</span>Date(<span style="color:#458;font-weight:bold">int</span> year, <span style="color:#458;font-weight:bold">int</span> month, <span style="color:#458;font-weight:bold">int</span> day)<span style="color:#998;font-style:italic">// actual definition
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">:</span> m_year{year},
</span></span><span style="display:flex;"><span>      m_month{month},
</span></span><span style="display:flex;"><span>      m_day{day} {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Even further, we can put declarations and definitions in different files. For example, inside <code>date.h</code> we can have</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#pragma once
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Date</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_year {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_month {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_day {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Date(<span style="color:#458;font-weight:bold">int</span> year, <span style="color:#458;font-weight:bold">int</span> month, <span style="color:#458;font-weight:bold">int</span> day);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() <span style="font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getYear</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_year};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getMonth</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_month};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getDay</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_day};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>and in <code>date.cpp</code> we have</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;date.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Date<span style="font-weight:bold">::</span>Date(<span style="color:#458;font-weight:bold">int</span> year, <span style="color:#458;font-weight:bold">int</span> month, <span style="color:#458;font-weight:bold">int</span> day)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">:</span> m_year {year},
</span></span><span style="display:flex;"><span>      m_month {moth},
</span></span><span style="display:flex;"><span>      m_day {day} {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> Date<span style="font-weight:bold">::</span>print() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Date(&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> m_year <span style="font-weight:bold">&lt;&lt;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> m_month <span style="font-weight:bold">&lt;&lt;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#b84">&#34;, &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> m_day <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If you&rsquo;re concered about the one-definition rule (ODR), rest easy as types are exempt from it and there is no issue to include class definitions into multiple files. Meanwhile, the rule that forbids multiple definitions inside the same file still has its effect and thus we cannot include the same class into <strong>the same file</strong> multiple times, thus the header guards or <code>#pragma once</code>.</p>
<h2 id="nested-types">Nested types</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">enum</span> <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">FruitType</span> {
</span></span><span style="display:flex;"><span>    apple,
</span></span><span style="display:flex;"><span>    banana,
</span></span><span style="display:flex;"><span>    cherry
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Fruit</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> PercentageType <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">int</span>;
</span></span><span style="display:flex;"><span>    FruitType m_type { };
</span></span><span style="display:flex;"><span>    PercentageType m_percentageEaten { <span style="color:#099">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Fruit(FruitType type) <span style="font-weight:bold">:</span> m_type { type } {}
</span></span><span style="display:flex;"><span>    FruitType <span style="color:#900;font-weight:bold">getType</span>() { <span style="font-weight:bold">return</span> m_type; }
</span></span><span style="display:flex;"><span>    PercentageType <span style="color:#900;font-weight:bold">getPercentageEaten</span>() { <span style="font-weight:bold">return</span> m_percentageEaten; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">isCherry</span>() { <span style="font-weight:bold">return</span> m_type <span style="font-weight:bold">==</span> FruitType<span style="font-weight:bold">::</span>cherry; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Fruit apple { FruitType<span style="font-weight:bold">::</span>apple };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (apple.getType() <span style="font-weight:bold">==</span> FruitType<span style="font-weight:bold">::</span>apple)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;I am an apple&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;I am not an apple&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note how we define the type alias inside the private chunk to be used in public etc.</p>
<p>Another interesting feature of nested classes is that they can access the private members of their parent class, as long as they&rsquo;re defined inside the parent class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_id;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Printer</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">void</span> print(<span style="font-weight:bold">const</span> Employee<span style="font-weight:bold">&amp;</span> e) {
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> e.m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Notice how the <code>Printer</code> class can access the private members of <code>Employee</code> (although <code>this</code> is not implicitly accessible).</p>
<h2 id="introduction-to-destructors">Introduction to destructors</h2>
<p>There are several rules about destructors:</p>
<ul>
<li>The destructor must have the same name as the class, preceded by a tilde (~)</li>
<li>The destructor can not take arguments</li>
<li>The destructor has no return type</li>
</ul>
<p>The following is an example of a destructor:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Simple</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_id {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Simple(<span style="color:#458;font-weight:bold">int</span> d)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_id {id} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>Simple() {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Destructing Simple &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> m_id <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>If a non-aggregate class type object has no user-declared desturctor this compiler will generate a destructor with an empty body. The destructor is called an implicit destructorm and it is effectively just a placeholder.</p>
<p>It&rsquo;s important to note that when <code>std::exit()</code> is called, the destructors won&rsquo;t be triggered and thus no cleanup work shall happen (which is bad).</p>
<h2 id="class-template-with-member-functions">Class template with member functions</h2>
<p>Let&rsquo;s combine type template and class template:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Pair</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    T m_first {};
</span></span><span style="display:flex;"><span>    T m_second {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Pair(<span style="font-weight:bold">const</span> T<span style="font-weight:bold">&amp;</span> first, <span style="font-weight:bold">const</span> T<span style="font-weight:bold">&amp;</span> second)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_first {first},
</span></span><span style="display:flex;"><span>          m_second {second} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">isEqual</span>(<span style="font-weight:bold">const</span> Pair<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;&amp;</span> pair);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> Pair<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;::</span>isEqual(<span style="font-weight:bold">const</span> Pair<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;&amp;</span> pair) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m_first <span style="font-weight:bold">==</span> pair.m_first <span style="font-weight:bold">&amp;&amp;</span> m_second <span style="font-weight:bold">==</span> pair.m_second;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Pair p1 { <span style="color:#099">5</span>, <span style="color:#099">6</span> };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>boolalpha <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;isEqual(5,6): &#34;</span>
</span></span><span style="display:flex;"><span>              <span style="font-weight:bold">&lt;&lt;</span> p1.isEqual(Pair{<span style="color:#099">5</span>,<span style="color:#099">6</span>}) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cuut <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>boolalpha <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;isEqual(5,7): &#34;</span>
</span></span><span style="display:flex;"><span>              <span style="font-weight:bold">&lt;&lt;</span> p1.isEqual(Pair(<span style="color:#099">5</span>,<span style="color:#099">6</span>)) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="static-member-variables">Static member variables</h2>
<p>Static member variables are shared by all objects of the class.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Something</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> s_value;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Something first {};
</span></span><span style="display:flex;"><span>    Something second {};
</span></span><span style="display:flex;"><span>    first.s_value <span style="font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> first.s_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> second.s_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s worth noting that static member variables are not associated with the objects at all, which actually makes sense, since they exist even before a class gets instantiated. In order to access the member, we can just use <code>Something::s_value</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Something</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> s_value;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> Something<span style="font-weight:bold">::</span>s_value {<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Something<span style="font-weight:bold">::</span>s_value <span style="font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> Something<span style="font-weight:bold">::</span>s_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>See, no object involved in this example.</p>
<p>Static member variables cannot be initialized at the same time as definition, hence the extra line outside the class definition. There are two exceptions, though:</p>
<ul>
<li>A const variable can be instantiated static</li>
<li>An inline variable can be instantiated static (this is the preferred way if we have a non-const variable and want it static)</li>
</ul>
<h2 id="static-member-functions">Static member functions</h2>
<p>Note that static member variables are not accessible via class if they&rsquo;re private. To solve this problem, we need static member functions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Something</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="font-weight:bold">inline</span> <span style="color:#458;font-weight:bold">int</span> s_value {<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> getValue() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> s_value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> Something<span style="font-weight:bold">::</span>s_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> Something<span style="font-weight:bold">::</span>getValue() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Is also worth noting (and quite natural) that a static function has no access to the <code>this</code> pointer, since no object must be involved. Also, C++ doesn&rsquo;t support static constructors (which quite makes sense too).</p>
<h2 id="friend-non-member-functions">Friend non-member functions</h2>
<p>When we want a non-member function to ba able to access the private variables, we need <strong>friendship</strong>. Inside the body of a class, a <strong>friend declaration</strong> using the <code>friend</code> keyword can be used to tell the compiler that some other class or function is now a friend, which in C++ means they have been granted access to the private and protected members of the said class.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Accumulator</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> add(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">+=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="font-weight:bold">const</span> Accumulator<span style="font-weight:bold">&amp;</span> accumulator);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="font-weight:bold">const</span> Accumulator<span style="font-weight:bold">&amp;</span> accumulator) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> accumulator.m_value;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Accumulator acc {};
</span></span><span style="display:flex;"><span>    acc.add(<span style="color:#099">5</span>);
</span></span><span style="display:flex;"><span>    print(acc);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Instead of declaring a friend non-member function and define it outside the class, as can also just define the friend function inside the class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Accumulator</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> add(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        m_value <span style="font-weight:bold">+=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="font-weight:bold">const</span> Accumulator<span style="font-weight:bold">&amp;</span> accumulator) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> accumulator.m_value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>A function can be friend of multiple classes</strong>.</p>
<h2 id="friend-classes-and-friend-member-functions">Friend classes and friend member functions</h2>
<p>Just like friend non-member functions, we can define friend classes and member functions.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Storage</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Storage(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> m_value{value} {}
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Display</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Display</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">bool</span> m_display {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Display(<span style="color:#458;font-weight:bold">bool</span> display) <span style="font-weight:bold">:</span> m_display {display} {}
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">displayStorage</span>(<span style="font-weight:bold">const</span> Storage<span style="font-weight:bold">&amp;</span> storage) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (m_display) {
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> storage.m_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>which declares the class <code>Display</code> to be a friend of <code>Storage</code> and thus make the prior to be able to access the private members of the latter. Instead of doing that for the whole class, we can also declare only the function as the friend of <code>Storage</code>. It&rsquo;s worth noting that in order to avoid a compile error, we need to have <code>Storage</code> declared before <code>Display</code>. If that&rsquo;s not possible for the full class, we can at least do <strong>forward declaration</strong> and just write this on the top:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Storage</span>;
</span></span></code></pre></div><h2 id="ref-qualifier">Ref qualifier</h2>
<p>Let&rsquo;s say we have the following member function tht returns a const reference:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> getName() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_name; }
</span></span></code></pre></div><p>and want to avoid the potential problem of dangling references. We could ref-qualify this function by adding a <code>&amp;</code> qualifier to the overload that will match only lvalue implicit objects, and a <code>&amp;&amp;</code> qualifier to the overload that will match only rvalue implicit objects:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> getName() <span style="font-weight:bold">const</span> <span style="font-weight:bold">&amp;</span> {<span style="font-weight:bold">return</span> m_name;}  <span style="color:#998;font-style:italic">// &amp; for lvalue implicit (return by reference)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> <span style="color:#900;font-weight:bold">getName</span>() <span style="font-weight:bold">const</span> <span style="font-weight:bold">&amp;&amp;</span> {<span style="font-weight:bold">return</span> m_name;}        <span style="color:#998;font-style:italic">// &amp;&amp; for rvalue implicit (return by value)
</span></span></span></code></pre></div><p>With the above overloading, we can safely run the below program without worrying about dangling references:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> Employee joe{};
</span></span><span style="display:flex;"><span> joe.setName(<span style="color:#b84">&#34;Joe&#34;</span>);
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> joe.getName() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// Joe is an lvalue, so now returned by reference
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> createEmployee(<span style="color:#b84">&#34;Frank&#34;</span>).getName() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// Frank is an rvalue, so now returned by value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Two things to note about ref-qualifying:</p>
<ul>
<li>The non-ref-qualified overloads will conflict with ref-qualified overloads, so you must use one or the other</li>
<li>If only an lvalue-qualified overload is provided (post single-<code>&amp;</code>, no rvalue overload defined), then any call to the function with an rvalue implicit object will result in a compilation error &ndash; this actually provides a great way to detect and prevent the use of rvalue implicit objects at all.</li>
</ul>
<h1 id="dynamic-arrays-stdvector">Dynamic Arrays: <code>std::vector</code></h1>
<h2 id="introduction-to-containers-and-arrays">Introduction to containers and arrays</h2>
<p>The following types are containers under the general programming definition, but are not considered to be containers by the C++ standard:</p>
<ul>
<li>C-style arrays</li>
<li><code>std::string</code></li>
<li><code>std::vector&lt;bool&gt;</code></li>
</ul>
<p>To be a container in C++, the container must implement all of the requirements <a href="https://en.cppreference.com/w/cpp/named_req/Container">here</a>. That being said, since <code>std::string</code> and <code>std::vector&lt;bool&gt;</code> implement most of the requirements, they behave like containers in most circumstances and are sometimes called &ldquo;pseudo-containers&rdquo;.</p>
<p>Of the provided container classes, <code>std::vector</code> and <code>std::array</code> see the most use and will be where we focus the bulk of our attention.</p>
<p>An <strong>array</strong> is a container data type that stores a sequence of values contiguously (meaning each element is placed in an adjacent memory location with no gaps). Arrays allow fast, direct access to any element and are conceptually simple and easy to use.</p>
<p>There are three types of primary array types in C++: C-style arrays, <code>std::vector</code> container class and <code>std::array</code> container class. C-style arrays were inherited from the C language. For backwards compatibility, these arrays are defined as part of the core C++ language (much like the fundamental data types). They are also sometimes called &ldquo;naked arrays&rdquo;, &ldquo;fixed-sized arrays&rdquo; or &ldquo;built-in arrays&rdquo;. To help make arrays safer and easier to use in C++, the <code>std::vector</code> container class was introduced in C++03 and is the most flexible of the three array types, and has a bunch of useful capabilities that the other array types don&rsquo;t. Finally, the <code>std::array</code> container class was introduced in C++11 as a direct replacement for C-style arrays. It is more limited than <code>std::vector</code> but can also be more efficient, especially for smaller arrays.</p>
<h2 id="introduction-to-stdvector-and-list-constructors">Introduction to <code>std::vector</code> and list constructors</h2>
<p>The <code>std::vector</code> container is defined in the <code>&lt;vector&gt;</code> header as a class template with a template type parameter that defines the type of the elements. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> empty{};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can initialie the <code>std::vector</code> with a list of values also:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> primes {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector vowels {<span style="color:#b84">&#39;a&#39;</span>, <span style="color:#b84">&#39;e&#39;</span>, <span style="color:#b84">&#39;i&#39;</span>, <span style="color:#b84">&#39;o&#39;</span>, <span style="color:#b84">&#39;u&#39;</span>};  <span style="color:#998;font-style:italic">// type char deduced by CTAD
</span></span></span></code></pre></div><p>The above is called a <strong>list constructor</strong> and is provided often by container classes. The list constructor does three things:</p>
<ul>
<li>Ensures the container has enough storage to hold all the initialization values</li>
<li>Sets the length of the container to the number of elements in the initializer list</li>
<li>Initializes the elements to the values in the initializer list (in sequential order)</li>
</ul>
<p>We can access the elements like the following:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> pp <span style="font-weight:bold">=</span> primes[<span style="color:#099">0</span>] <span style="font-weight:bold">+</span> primes[<span style="color:#099">1</span>];
</span></span></code></pre></div><p>Notice <code>operator[]</code> does not do any <strong>bounds checking</strong> and thus passing an invalid index (negative / greater than or equal to the length of the array) will result in undefined behavior.</p>
<p>One of the defining characteristics of arrays is that the elements are always allocated contiguously in memory, meaning the elements are all adjacent in memory (with no gaps between them):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector primes {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;An int is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;bytes</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">&amp;</span>(primes[<span style="color:#099">0</span>]) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">&amp;</span>(primes[<span style="color:#099">1</span>]) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">&amp;</span>(primes[<span style="color:#099">2</span>]) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This produces the following output:</p>
<pre tabindex="0"><code>An int is 4 bytes
00DBF720
00DBF724
00DBF728
</code></pre><p>We can construct a vector of specific length to avoid the following kind of work:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> data <span style="font-weight:bold">=</span> {<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>}; <span style="color:#998;font-style:italic">// ten zeros
</span></span></span></code></pre></div><p>by using the explicit constructor <code>explicit std::vector&lt;T&gt;(int)</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> data(<span style="color:#099">10</span>); <span style="color:#998;font-style:italic">// vector containing ten int elements, value-initialized to zero
</span></span></span></code></pre></div><p>Notice the above initialization uses direct initialization with parentheses instead of braces &ndash; there is apparent ambiguity from using braces in this case since both list constructor and the explicit constructor can take this form. The reality is, C++ has a special rule to select a matching list constructor over other constructors (but we should always just avoid such confusion).</p>
<p>Lastly, the following is a list of examples of different ways to initialize a vector:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> v1 <span style="font-weight:bold">=</span> <span style="color:#099">10</span>;   <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> v2(<span style="color:#099">10</span>);    <span style="color:#998;font-style:italic">// explicit constructor; ten zeros
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> v3{<span style="color:#099">10</span>};    <span style="color:#998;font-style:italic">// list constructor; just single zero
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> v4 <span style="font-weight:bold">=</span> {<span style="color:#099">10</span>}; <span style="color:#998;font-style:italic">// copy constructor; single zero
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> v5({<span style="color:#099">10</span>});  <span style="color:#998;font-style:italic">// copy constructor; single zero
</span></span></span></code></pre></div><h2 id="the-unsigned-length-and-subscript-problem">The unsigned length and subscript problem</h2>
<p>Before everything, let&rsquo;s talk about history.</p>
<p>As Bjarne Stroustrup <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf">recalls</a>, when the container classes in the C++ standard library was being designed (circa 1997), the designers had to choose whether to make the length (and array subscripts). They chose to make them unsigned as lengths cannot be nagative naturally, and unsigned type allows greater maximum (important back in the 16-bit days).</p>
<p>In retrospect, this is generally regarded as having been the wrong choice, because negative signed integer will be implicitly converted to a large unsigned integer producing a garbage result, and the commonly used <code>operator[]</code> doesn&rsquo;t do range-checking at all.</p>
<p>Above being said, we can ask a container for its length using <code>size()</code> member function (which returns the length as unsigned <code>size_type</code>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector prime{<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;length: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> prime.size() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unlike <code>std::string</code> and <code>std::string_view</code> which have both <code>length()</code> and <code>size()</code> member functions (that do the same thing), <code>std::vector</code> (together with most other container types) only has <code>size()</code>. Starting from C++17, we can also use <code>std::size</code> non-member function to do the same thing:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>size(prime)
</span></span></code></pre></div><p>Then, starting from C++20, we have <code>std::ssize()</code> to get the length as a large signed integral type (usually <code>std::ptrdiff_t</code>) which is the type normally used as the signed counterpart to <code>std::size_t</code>. This is the only function of the three that returns the length as a signd type. When saving the returned value to an integral type, you can either use <code>int</code> (but with <code>static_cast</code> to avoid implicit narrowing conversion warning/error). Or, you can use <code>auto</code> to let the compiler to deduce the type used for the variable.</p>
<p>On the other hand, while <code>operator[]</code> does no bounds checking, we have <code>at()</code> member function that does runtime bounds checking:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>prime.at(<span style="color:#099">5</span>);  <span style="color:#998;font-style:italic">// throws exception of type std::out_of_range
</span></span></span></code></pre></div><p>Alternatively, we can also define the index as a <code>constexpr int</code> or <code>std::size_t</code> to avoid implicit narrowing conversion (but alas, no bounds checking).</p>
<h2 id="passing-stdvector">Passing <code>std::vector</code></h2>
<p>An object of type <code>std::vector</code> can be passed to a function just like any other object. That means if we pass it by value, an expensive copy will be made, hence we should typically pass <code>std::vector</code> by (const) reference to avoid such copies. While doing so, we may use CTAD to omit the template parameter for better compatibility in function definition.</p>
<h2 id="returning-stdvector-and-an-introduction-to-move-semantics">Returning <code>std::vector</code>, and an introduction to move semantics</h2>
<p>Check the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector arr1 {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector arr2 { arr1 };  <span style="color:#998;font-style:italic">// copy of arr1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    arr1[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span> <span style="color:#099">6</span>;
</span></span><span style="display:flex;"><span>    arr2[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span> <span style="color:#099">7</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> arr1[<span style="color:#099">0</span>] <span style="font-weight:bold">&lt;&lt;</span> arr2[<span style="color:#099">0</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above prints 6 and 7 because we know <code>arr2</code> is nothing but a copy of <code>arr1</code>. The term <strong>copy semantics</strong> refers t othe rules that determine how copies of objects are made. When we say a type supports copy semantics, we mean that objects of that type are copyable, because the rules for making such copies have been defined. When we say copy semantics are being invoked, that means we&rsquo;ve done something that will make a copy of an object.</p>
<p>For class types, copy semantics are tytically implemented via the copy constructor (and copy assigment operator).</p>
<p>Let&rsquo;s now check another example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> generate() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector arr1 {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> arr1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector arr2 { generate() };  <span style="color:#998;font-style:italic">// the return value of generate() dies after this line
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    arr2[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span> <span style="color:#099">7</span>;  <span style="color:#998;font-style:italic">// nothing to do with arr1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> arr2[<span style="color:#099">0</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When <code>arr2</code> is initialized this time, it is being initialized using a temporary object returned from function <code>generate()</code> and unlike the prior case, here the rvalue is destroyed right after and copying is very pointlessly costly. That is why we need to introduce the <strong>move semantics</strong>, which refers to the rules that determine how the data from one object is moved to another object. When the move semantics is invoked, any data member that can be moved is moved, and any data member that can&rsquo;t be moved is copied. Normally, when an object is being initialized with or assigned an object of the same type, copy semantics will be used (assuming copy isn&rsquo;t elided by user). However when <strong>all of the following conditions</strong> are true, the move semantics will be invoked instead:</p>
<ul>
<li>The type of the object supports move semantics</li>
<li>The initializer or object being assigned from is an rvalue (temporary) object</li>
<li>The move isn&rsquo;t elided</li>
</ul>
<p>The sad news is that not many types support move semantics &ndash; however, <code>std::vector</code> and <code>std::string</code> both do. That means we can return move-capable types like <code>std__vector</code> by value just fine. That being said, we should still pass these move-capable objects by const references because move semantics won&rsquo;t be invoked when we pass these by values, as they&rsquo;ll be lvalues at the time. So in short: pass by const references, return by values.</p>
<h2 id="arrays-and-loops">Arrays and loops</h2>
<p>Arrays provide a way to store multiple objects without having to name each element. Loops provide a way to traverse an array without having to explicitly list each element. Templates provide a way to parameterize the element type. Together, they allow us to write code that can operate on a container of elements, regardless of the element type or number of elements in the container.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>T calculateAverages(<span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;&amp;</span> arr) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>size_t length {arr.size()};
</span></span><span style="display:flex;"><span>    T average{<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (std<span style="font-weight:bold">::</span>size_t i{<span style="color:#099">0</span>}; i <span style="font-weight:bold">&lt;</span> length; <span style="font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        average <span style="font-weight:bold">+=</span> arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    average <span style="font-weight:bold">/=</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(length);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> average;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s good to remember (yes) how the simple for loop is written: initialized zero, and terminate when <code>i &lt; length</code>.</p>
<h2 id="arrays-loops-and-sign-challenge-solutions">Arrays, loops and sign challenge solutions</h2>
<p>We can use <code>int</code> as the type of loop index (and it&rsquo;s preferred, in fact). If you&rsquo;re lazy, you can use <code>auto</code> which will deduce the type for you. In C++23, you can even att the <code>Z</code> suffix to define a literal to be signed:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i{<span style="color:#099">0</span>Z}; i <span style="font-weight:bold">&lt;</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>ptrdiff_t<span style="font-weight:bold">&gt;</span>(arr.size()); <span style="font-weight:bold">++</span>i)
</span></span></code></pre></div><p>or utilizing <code>std::ssize()</code> introduced in C++20:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i{<span style="color:#099">0</span>Z}; i <span style="font-weight:bold">&lt;</span> std<span style="font-weight:bold">::</span>ssize(arr); <span style="font-weight:bold">++</span>i)
</span></span></code></pre></div><p>Notice that when we use these index variables, since they&rsquo;re now signed, they will throw warnings when being narrowing converted to unsigned inside <code>operator[]</code>. We can use a number of ways to avoid such warnings (and no, we&rsquo;re not gonna introduce all of them here cuz they&rsquo;re annoyingly ugly imo) but the preferred solution is actually surprisingly simple: we don&rsquo;t index arrays altogether. In fact, C++ provides several other methods for traversing through arrays that do not use indices at all, and if we don&rsquo;t have indices, we don&rsquo;t worry about these signed/unsigned issues. Two most common methods are range-based for loops, and interators.</p>
<h2 id="range-based-for-loops">Range-based for loops</h2>
<p>The range-based for statement has the following syntax:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (element_declaration : array_object)
</span></span><span style="display:flex;"><span>    statement;
</span></span></code></pre></div><p>For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector fibonacci { <span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">8</span>, <span style="color:#099">13</span>, <span style="color:#099">21</span>, <span style="color:#099">34</span>, <span style="color:#099">55</span>, <span style="color:#099">89</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> num : fibonacci)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> num <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can even use <code>auto</code> for type deduction:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> num: fibonacci)
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> num <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span></code></pre></div><p>For classes with expensive copying e.g. strings, we may also want to avoid copying altogether in the range-based loops by using const references:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> <span style="font-weight:bold">namespace</span> std<span style="font-weight:bold">::</span>literals;  <span style="color:#998;font-style:italic">// for s suffix as string literals
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>vector words {<span style="color:#b84">&#34;peter&#34;</span>s, <span style="color:#b84">&#34;likes&#34;</span>s, <span style="color:#b84">&#34;frozen&#34;</span>s, <span style="color:#b84">&#34;yogurt&#34;</span>s};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> word : words)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> word <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s important to notice that range-based loop doesn&rsquo;t give you the index automatically, so you might want to keep your own index counter variable if needed (or just use the classic for loop).</p>
<p>Last but not least, if you want to do range-based loop in reverse:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;ranges&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// C++20
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> <span style="font-weight:bold">namespace</span> std<span style="font-weight:bold">::</span>literals;  <span style="color:#998;font-style:italic">// for sv suffix as string_view
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>vector words {<span style="color:#b84">&#34;alex&#34;</span>sv, <span style="color:#b84">&#34;bobby&#34;</span>sv, <span style="color:#b84">&#34;chad&#34;</span>sv, <span style="color:#b84">&#34;dave&#34;</span>sv};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> word : std<span style="font-weight:bold">::</span>views<span style="font-weight:bold">::</span>reverse(words)) <span style="color:#998;font-style:italic">// from &lt;ranges&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> word <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="array-indexing-and-length-using-enumerators">Array indexing and length using enumerators</h2>
<p>One of the bigger documentation problems with arrays is that their indices don&rsquo;t normally provide any real information. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector testScores {<span style="color:#099">78</span>, <span style="color:#099">79</span>, <span style="color:#099">71</span>, <span style="color:#099">56</span>, <span style="color:#099">55</span>};
</span></span><span style="display:flex;"><span>    testScores[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> <span style="color:#099">77</span>;  <span style="color:#998;font-style:italic">// whose score is it?
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can use unscoped enumerators instead:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Students {
</span></span><span style="display:flex;"><span>    eunm Names {
</span></span><span style="display:flex;"><span>        Sam,
</span></span><span style="display:flex;"><span>        Allen,
</span></span><span style="display:flex;"><span>        Billy,
</span></span><span style="display:flex;"><span>        Wonka,
</span></span><span style="display:flex;"><span>        Zoe
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector testScores {<span style="color:#099">78</span>, <span style="color:#099">79</span>, <span style="color:#099">71</span>, <span style="color:#099">56</span>, <span style="color:#099">55</span>};
</span></span><span style="display:flex;"><span>    testScores[Students<span style="font-weight:bold">::</span>Allen] <span style="font-weight:bold">=</span> <span style="color:#099">78</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Because enumerators are implicitly converted to <code>std::size_t</code>, we don&rsquo;t need to worry about them being used indices. Meanwhile, as they&rsquo;re constexpr, we don&rsquo;t need to worry about signed/unsigned indexing problem either. Cool.</p>
<p>When we define a non-constexpr variable of the enumeration type, that would break the last statement above, thus causing a sign conversion warning. We can be more explicit if we really need that variable:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Students {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Names</span> <span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>        Sam,
</span></span><span style="display:flex;"><span>        Allen,
</span></span><span style="display:flex;"><span>        Billy,
</span></span><span style="display:flex;"><span>        Wonka,
</span></span><span style="display:flex;"><span>        Zoe
</span></span><span style="display:flex;"><span>   };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To avoid the size of the array being shorter than the enumeration, we can add an extra enumerator in the end for array initialization:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">namespace</span> Students {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">enum</span> <span style="color:#458;font-weight:bold">Names</span> {
</span></span><span style="display:flex;"><span>        Sam,
</span></span><span style="display:flex;"><span>        Allen,
</span></span><span style="display:flex;"><span>        Billy,
</span></span><span style="display:flex;"><span>        Wonka,
</span></span><span style="display:flex;"><span>        Zoe,
</span></span><span style="display:flex;"><span>        num_students
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> testScores(Students<span style="font-weight:bold">::</span>num_students);  <span style="color:#998;font-style:italic">// properly initialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>or assert using this extra enumerator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector testScores { <span style="color:#099">78</span>, <span style="color:#099">79</span>, <span style="color:#099">71</span>, <span style="color:#099">56</span>, <span style="color:#099">55</span> };
</span></span><span style="display:flex;"><span>    assert(std<span style="font-weight:bold">::</span>size(testScores) <span style="font-weight:bold">==</span> Students<span style="font-weight:bold">::</span>num_students);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stdvector-resize-and-capacity"><code>std::vector</code> resize and capacity</h2>
<p>You can resize a <code>std::vector</code> at runtime:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector v{<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the length of v is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> v.size() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    v.resize(<span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;the length of v is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> v.size() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : v)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This prints:</p>
<pre tabindex="0"><code>The length is: 3
The length is: 5
0 1 2 0 0
</code></pre><p>Another important concept is the capacity of <code>std::vector</code>. This is the actual units of memory allocated to the array. When we resize an array down to some smaller value, the memory does not get reallocated right away and thus making capacity lagging behind the size. The indexing is based on the size instead of capacity. In order to force the reallocation, we have <code>shrink_to_fit()</code> member function.</p>
<h2 id="stdvector-and-stack-behavior"><code>std::vector</code> and stack behavior</h2>
<p>In programming, a <strong>stack</strong> is a container data type where the insertion and removal of elements occurs in a LIFO (last-in-first-out) manner. This is commonly implemented via two operations named <strong>push</strong> and <strong>pop</strong>.</p>
<p>In C++, stack-like operations were added (as member functions) to the existing standard library container classes that support efficient insertion and removal of elements at one end (<code>std::vector</code>, <code>std::deque</code> and <code>std::list</code>). This allows any of these containers to be used as stacks in addition to their native capabilities.</p>
<p>For <code>std::vector</code>, we have the following member functions to support stack-like behavior:</p>
<ul>
<li><code>push_back()</code>: insert new element on top of stack</li>
<li><code>pop_back()</code>: remove the top element from stack</li>
<li><code>back()</code>: get the top element on the stack</li>
<li><code>emplace_back()</code>: alternate form of <code>push_back()</code> that is more efficient</li>
</ul>
<p>Here <code>emplace_back</code> is mostly the same as <code>push_back</code> except when we&rsquo;re creating a temporary variable to be pushed into a stack, <code>emplace_back</code> skips the potentially expensive copying and just passes the bare arguments to the constructor:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_a{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_b{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Foo(std<span style="font-weight:bold">::</span>string_view a, <span style="color:#458;font-weight:bold">int</span> b)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_a{a}, m_b{b} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">explicit</span> <span style="color:#900;font-weight:bold">Foo</span>(<span style="color:#458;font-weight:bold">int</span> b)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_a {}, m_b {b} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>Foo<span style="font-weight:bold">&gt;</span> stack{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Foo f{<span style="color:#b84">&#34;a&#34;</span>, <span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    stack.push_back(f);          <span style="color:#998;font-style:italic">// preferred 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.emplace_back(f);       <span style="color:#998;font-style:italic">// works too
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    stack.push_back({<span style="color:#b84">&#34;a&#34;</span>, <span style="color:#099">2</span>});   <span style="color:#998;font-style:italic">// create and then copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.emplace_back(<span style="color:#b84">&#34;a&#34;</span>, <span style="color:#099">2</span>);  <span style="color:#998;font-style:italic">// create, no copy
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    stack.push_back({ <span style="color:#099">2</span> });      <span style="color:#998;font-style:italic">// compile error: Foo(int) is explicit
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.emplace_back(<span style="color:#099">2</span>);       <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>Unlike the subscript operator (<code>operator[]</code> and <code>at()</code>), here <code>push_back</code> and <code>pop_back</code> (and <code>emplace_back</code>) will actively change the size of the array (but <code>pop_back</code> is still lazy on capacity).</p>
<p>In order to limit the activeness in reallocating capacities, we can use the <code>reserve()</code> member function, which reallocates a <code>std::vector</code> <strong>without</strong> changing its current size.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> stack{};
</span></span><span style="display:flex;"><span>    stack.reserve(<span style="color:#099">6</span>);      <span style="color:#998;font-style:italic">// size: 0, capacity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.push_back(<span style="color:#099">2</span>);    <span style="color:#998;font-style:italic">// size: 1, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.push_back(<span style="color:#099">1</span>);    <span style="color:#998;font-style:italic">// size: 2, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.push_back(<span style="color:#099">4</span>);    <span style="color:#998;font-style:italic">// size: 3, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.push_back(<span style="color:#099">7</span>);    <span style="color:#998;font-style:italic">// size: 4, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.push_back(<span style="color:#099">8</span>);    <span style="color:#998;font-style:italic">// size: 5, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.push_back(<span style="color:#099">9</span>);    <span style="color:#998;font-style:italic">// size: 6, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    stack.pop_back();      <span style="color:#998;font-style:italic">// size: 5, capccity: 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stdvectorbool-vs-stdbitset"><code>std::vector&lt;bool&gt;</code> vs <code>std::bitset</code></h2>
<p><code>std::vector&lt;bool&gt;</code> works similarly to <code>std::bitset</code> with maybe better space efficiency. However, the <code>sizeof(std::vector&lt;bool&gt;)</code> has a 40-byte overhead so the saved memory won&rsquo;t mean much unles we&rsquo;re allocating more than 40 boolean values. Meanwhile, the space optimization depends on the implementation a lot and thus is not always trustworthy. Lastly, we should note that <code>std::vector&lt;bool&gt;</code> is actually <strong>not a vector</strong> (not contiguous in memory) nor does it hold real boolean values, nor does it meet the C++ standard of containers. In short, we should maybe just avoid using <code>std::vector&lt;bool&gt;</code> altogether.</p>
<p>Instead, three alternative containers are recommended:</p>
<ul>
<li>Use (constexpr) <code>std::bitset</code> when the number of bits needed is known at compile-time</li>
<li>Use <code>std::vector&lt;char&gt;</code> when a resizable container is needed</li>
<li>Use third-party implementations for dynamic bitsets e.g. <code>boost:dynamic_bitset</code> when bit operations are needed</li>
</ul>
<h1 id="fixed-size-arrays-stdarray-and-c-style-arrays">Fixed-size Arrays: <code>std::array</code> and C-style Arrays</h1>
<h2 id="introduction-to-stdarray">Introduction to <code>std::array</code></h2>
<p>There are two reasons why we still need <code>std::array</code> when we&rsquo;ve already got <code>std::vector</code>:</p>
<ul>
<li><code>std::vector</code> is slightly less performance than the fixed-sized <code>std::array</code></li>
<li><code>std::vector</code> only supports constexpr in very limited contexts</li>
</ul>
<p>and the second reason makes the majority of the it. In short, whenever we need constexpr arrays, we should use <code>std::array</code> over <code>std::vector</code>.</p>
<p>In order to declare a <code>std::array</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> a{};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The size of a <code>std::array</code> must be a constexpr upon declaration, e.g. a integer literal, a constexpr variable or an unscoped enumerator.</p>
<p>The initialization of a <code>std::array</code> does <strong>not</strong> involve a constructor, because it&rsquo;s not a class but an aggregate. It means if a <code>std::array</code> is defined without an initializer, the elements will be default initialized.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> a{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};       <span style="color:#998;font-style:italic">// list initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> b <span style="font-weight:bold">=</span> {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};    <span style="color:#998;font-style:italic">// copy initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> c;                  <span style="color:#998;font-style:italic">// uninitialized!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> d{};                <span style="color:#998;font-style:italic">// zero initialized; ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> v(<span style="color:#099">5</span>);                 <span style="color:#998;font-style:italic">// vector can be value initialized
</span></span></span></code></pre></div><p>We can define a <code>std::array</code> as const or constexpr (latter preferred all the time, otherwise ask yourself if you really need a <code>std::array</code> rather than a <code>std::vector</code>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> a{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">5</span><span style="font-weight:bold">&gt;</span> b{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span></code></pre></div><p>Starting from C++17, we can use CTAD for type deduction (and are recommended to use it as much as possible):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array a {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};     <span style="color:#998;font-style:italic">// &lt;int, 5&gt; deducted
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> b{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>}; <span style="color:#998;font-style:italic">// error: cannot partially omit template parameter!
</span></span></span></code></pre></div><p>The most common way to access the elements of a <code>std::array</code> is through subscripts/indices (via <code>operator[]</code>). There is also an <code>at()</code> member function that unfortunately doesn&rsquo;t do bound checking at compile time (it does at runtime) either, and thus is not recommended.</p>
<h2 id="stdarray-length-and-indexing"><code>std::array</code> length and indexing</h2>
<p>There are three common ways to ge the length of a <code>std::array</code>:</p>
<ul>
<li>using the <code>size()</code> member function</li>
<li>using the <code>std::size()</code> function for unsigned length (since C++17)</li>
<li>using the <code>std::ssize()</code> function for signed length (since C++20)</li>
</ul>
<p>All above methods returns the length in constexpr even when the <code>std::array</code> itself is not constexpr.</p>
<p>In addition to <code>operator[]</code> (does not bound checking) and <code>at()</code> (runtime bound checking), <code>std::array</code> also supports <code>std::get()</code> non-member function that does compile time bound checking:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array prime{<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>get<span style="font-weight:bold">&lt;</span><span style="color:#099">3</span><span style="font-weight:bold">&gt;</span>(prime);  <span style="color:#998;font-style:italic">// prints 7
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>get<span style="font-weight:bold">&lt;</span><span style="color:#099">9</span><span style="font-weight:bold">&gt;</span>(prime);  <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="passing-and-returning-stdarray">Passing and returning <code>std::array</code></h2>
<p>CTAD doesn&rsquo;t work for function parameters, so when passing <code>std::array</code> to a function, we need to explicitly specify the element type and array length. If we really want the function to be able to accept general array type, we can create a function template that parameterizes both the element type and array length on the function level.</p>
<p>Before indexing the array inside the function, we need to statically assert the length versus the indices of interest, there are two ways:</p>
<ul>
<li>use <code>std::get&lt;i&gt;(array)</code> to potentially raise a compile error</li>
<li>use <code>static_assert(N &gt; i)</code> to expllicitly validate the precondition</li>
</ul>
<p>In terms of returning the <code>std::array</code>, there are three options:</p>
<ul>
<li>returning by value, if:
<ul>
<li>the array isn&rsquo;t huge</li>
<li>the element type is cheap to copy or move</li>
<li>the code isn&rsquo;t being used in a performance-sensitive context</li>
</ul>
</li>
<li>returning via an out parameter, if above doesn&rsquo;t satisfy</li>
<li>returning a <code>std::vector</code> since it&rsquo;s less expensive if copying is involved</li>
</ul>
<h2 id="stdarray-of-class-types-and-brace-elision"><code>std::array</code> of class types, and brace elision</h2>
<p>We can define a <code>std::array</code> of class types and assign elements like follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">House</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> number {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> stories {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> roomsPerStory {}; 
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>House, <span style="color:#099">3</span><span style="font-weight:bold">&gt;</span> houses {};
</span></span><span style="display:flex;"><span>    houses[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span> {<span style="color:#099">12</span>, <span style="color:#099">1</span>, <span style="color:#099">7</span>};
</span></span><span style="display:flex;"><span>    houses[<span style="color:#099">1</span>] <span style="font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">2</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    houses[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> {<span style="color:#099">10</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> house : houses) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;House number &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> house.number
</span></span><span style="display:flex;"><span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; has &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> (house.stories <span style="font-weight:bold">*</span> house.roomsPerStory)
</span></span><span style="display:flex;"><span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; rooms.</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Alternatively, we can also explicitly initialize a <code>std::array</code> of structs:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array houses {
</span></span><span style="display:flex;"><span>    House{<span style="color:#099">12</span>, <span style="color:#099">1</span>, <span style="color:#099">7</span>},
</span></span><span style="display:flex;"><span>    House{<span style="color:#099">11</span>, <span style="color:#099">2</span>, <span style="color:#099">5</span>},
</span></span><span style="display:flex;"><span>    House{<span style="color:#099">10</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>}  
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>However, do remember that the following way of initialization <strong>does not work</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>House, <span style="color:#099">3</span><span style="font-weight:bold">&gt;</span> houses {
</span></span><span style="display:flex;"><span>    {<span style="color:#099">12</span>, <span style="color:#099">1</span>, <span style="color:#099">7</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">11</span>, <span style="color:#099">2</span>, <span style="color:#099">5</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">10</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>}  
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Instead, a compile error will be thrown because the <code>std::array</code> implementation is nothing but a struct with a C-style array as its first member, thus the second and third pair of braces are not recognized. To remedy this problem, we can add an additional set of braces:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>House, <span style="color:#099">3</span><span style="font-weight:bold">&gt;</span> houses {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        {<span style="color:#099">12</span>, <span style="color:#099">1</span>, <span style="color:#099">7</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#099">11</span>, <span style="color:#099">2</span>, <span style="color:#099">5</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#099">10</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>}        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>In fact, you can always add this extra set of braces in the initialization of <code>std::array</code>, and that is totally legal in C++. Truth is aggregates in C++ supports a concept called <strong>brace elision</strong> that basically says if it&rsquo;s not totally necessary, you can elide the outer pair of braces just fine.</p>
<h2 id="arrays-of-references-via-stdreference_wrapper">Arrays of references via <code>std::reference_wrapper</code></h2>
<p>Because references are not objects, <strong>you cannot make an array of references</strong>. The elements of an array must be assignable, and references simply can&rsquo;t be reseated.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span><span style="color:#008080">[[maybe_unused]]</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span>, <span style="color:#099">2</span><span style="font-weight:bold">&gt;</span> refarr{ x, y };  <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> rx{x};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> ry{y};
</span></span><span style="display:flex;"><span><span style="color:#008080">[[maybe_unused]]</span> std<span style="font-weight:bold">::</span>array valarr{rx, ry};  <span style="color:#998;font-style:italic">// ok, but this is just &lt;int, 2&gt;
</span></span></span></code></pre></div><p>If we do want an array of references, there is a workaround by using <code>std::reference_wrapper</code> which lives in the <code>&lt;functional&gt;</code> header and takes a type template parameter <code>T</code> and then behaves like a modifiable lvalue reference to <code>T</code>. Several things to pay attention:</p>
<ul>
<li><code>operator=</code> reseats a <code>std::reference</code></li>
<li><code>std::reference_wrapper&lt;T&gt;</code> will implicitly convert to <code>T&amp;</code></li>
<li>the <code>get()</code> member function can be used to get a <code>T&amp;</code> which we can then use to update the value of the object being referenced</li>
</ul>
<p>Here&rsquo;s a simple example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;functional&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y{<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> z{<span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>reference_wrapper<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>, <span style="color:#099">3</span><span style="font-weight:bold">&gt;</span> arr{x, y, z};
</span></span><span style="display:flex;"><span>    arr[<span style="color:#099">1</span>].get() <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;  <span style="color:#998;font-style:italic">// you can modify the object being referenced 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> arr[<span style="color:#099">1</span>] <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 55 because y has been modified 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Prior to C++17, CTAD didn&rsquo;t exist, so explicit type must be specified. Therefore, in order to make things easier, introduced were <code>std::ref()</code> and <code>std::cref()</code> functions that basically served as shorthands for <code>std::reference_wrapper</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>reference_wrapper<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> rx{x};        <span style="color:#998;font-style:italic">// C++11 explicit 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> rx2{std<span style="font-weight:bold">::</span>reference_wrapper<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>{x}}  <span style="color:#998;font-style:italic">// C++11 explicit
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> ref{std<span style="font-weight:bold">::</span>ref(x)};                    <span style="color:#998;font-style:italic">// C++11 shorthand for std::reference_wrapper&lt;int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> cref{std<span style="font-weight:bold">::</span>cref(x)};                  <span style="color:#998;font-style:italic">// C++11 shorthand for std::reference_wrapper&lt;const int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>reference_wrapper rx3{x};            <span style="color:#998;font-style:italic">// C++17 with CTAD
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> rx4{std<span style="font-weight:bold">::</span>reference_wrapper{x}};      <span style="color:#998;font-style:italic">// C++17 with CTAD
</span></span></span></code></pre></div><h2 id="introduction-to-c-style-arrays">Introduction to C-style arrays</h2>
<p>Being part of the core language, C-style arrays have their own special declaration syntax. In an C-style array declaration, we use square brackets <code>[]</code> to tell the compiler that a declared object is a C-style array. Inside the brackets, we can optionally provide the length of the array, which is an integer value of type <code>std::size_t</code> that tells the compiler how many elements are in the array.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> testScores[<span style="color:#099">30</span>] {};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The length of a C-style array must be at least 1, or the compiler will throw an error. The length of the array must be a constexpr. Also, in contrast to e.g. <code>std::vector</code>, the indices here doesn&rsquo;t need to be unsigned.</p>
<p>There are several different ways to initialize a C-style array:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> fibonacci[<span style="color:#099">5</span>] <span style="font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>};  <span style="color:#998;font-style:italic">// copy-list initialization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> prime[<span style="color:#099">5</span>] {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};       <span style="color:#998;font-style:italic">// list initialized (preferred)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> prime[<span style="color:#099">5</span>] {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>, <span style="color:#099">13</span>};   <span style="color:#998;font-style:italic">// compile for too many initializers
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> prime[<span style="color:#099">5</span>] {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};      <span style="color:#998;font-style:italic">// compile error for CTAD doesn&#39;t work for C-style arrays
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> prime[] {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};        <span style="color:#998;font-style:italic">// length deduced (preferred)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> prime[] {};                      <span style="color:#998;font-style:italic">// compile error for zero-lengthed array
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">5</span>];                          <span style="color:#998;font-style:italic">// default initialized with elements uninitialized
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">5</span>] {};                       <span style="color:#998;font-style:italic">// value initialized with elements zero initialized (preferred)
</span></span></span></code></pre></div><p>As for getting the size of a C-style array, we can use the <code>sizeof()</code> operator or <code>std::size()</code> and <code>std::ssize()</code> non-member functions :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> prime[] { <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span> };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">sizeof</span>(prime);     <span style="color:#998;font-style:italic">// returns 20 (assuming 4 bytes each int)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>size(prime);  <span style="color:#998;font-style:italic">// C++17, returns unsigned int 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>ssize(prime); <span style="color:#998;font-style:italic">// C++20, returns signed int 5
</span></span></span></code></pre></div><p>For C++14 or older versions, we can also use the following custom function to get the length of an array:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, std<span style="font-weight:bold">::</span>size_t N<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>size_t length(<span style="font-weight:bold">const</span> T(<span style="font-weight:bold">&amp;</span>)[N]) <span style="font-weight:bold">noexcept</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> N;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> prime[<span style="color:#099">5</span>] {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">11</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;length: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> length(prime) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="c-style-array-decay">C-style array decay</h2>
<p>In most cases, when a C-style array is used in an expression, the array will be implicitly converted into a pointer to the element type, initialized with the address of the first element (with index 0). Colloquially, this is called <strong>array decay</strong>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iomanip&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::boolalpha 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">5</span>] {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr {arr};  <span style="color:#998;font-style:italic">// ptr is of type int*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>boolalpha <span style="font-weight:bold">&lt;&lt;</span> (<span style="font-weight:bold">typeid</span>(ptr) <span style="font-weight:bold">==</span> <span style="font-weight:bold">typeid</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span>)) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>boolalpha <span style="font-weight:bold">&lt;&lt;</span> (<span style="font-weight:bold">&amp;</span>arr[<span style="color:#099">0</span>] <span style="font-weight:bold">==</span> ptr) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;               <span style="color:#998;font-style:italic">// prints true 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are only a few cases in C++ where a C-style array <strong>doesn&rsquo;t</strong> decay:</p>
<ul>
<li>when used as an argument to <code>sizeof()</code> or <code>typeid()</code></li>
<li>when taking the address of the array using <code>operator&amp;</code></li>
<li>when passed as a memer of a class type</li>
<li>when passed by reference</li>
</ul>
<p>A decayed array pointer does not know the length of itself and thus the term &ldquo;decay&rdquo;. This decay behavior actually solves the problem of passing a huge array as argument &ndash; when passed as decayed array, it&rsquo;s actually the pointer that holds the address of the first element of the array that gets passed. Therefore, no copy is made in the process.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printElementZero</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> arr) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> arr[<span style="color:#099">0</span>];
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// same as below 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printElementZero</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> arr[]) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> arr[<span style="color:#099">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The problem with array decay is, as the length information is lost during the process, the following function won&rsquo;t work correctly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printArraySize</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> arr[]) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">sizeof</span>(arr) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 4 no matter what
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>Fortunately, C++17&rsquo;s better replacement <code>std::size()</code> (and C++20&rsquo;s <code>std::ssize()</code>) won&rsquo;t compile in this case:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printArraySize</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> arr[]) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>ssize(arr) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// compile error: std::size() doesn&#39;t work on pointers
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>In general, we can just avoid using the good O&rsquo; C-style arrays nowadays.</p>
<h2 id="pointer-arithmetic-and-subscripting">Pointer arithmetic and subscripting</h2>
<p><strong>Pointer arithmetic</strong> is a feature that allows us to apply certain integer arithmetic operators (addition, subtraction, increment, or decrement) to a pointer to produce a new memory address.</p>
<p>We can subscript a pointer holding the address of an array&rsquo;s first element to get other elements of the array:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> arr[] {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr{arr};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ptr[<span style="color:#099">2</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;      <span style="color:#998;font-style:italic">// prints 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>(ptr <span style="font-weight:bold">+</span> <span style="color:#099">2</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Following this trick we can traverse through an array using pointers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> arr[] <span style="font-weight:bold">=</span> {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> begin{arr};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> end{arr <span style="font-weight:bold">+</span> std<span style="font-weight:bold">::</span>size(arr)};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> i{begin}; i <span style="font-weight:bold">!=</span> end; <span style="font-weight:bold">++</span>i) { <span style="color:#998;font-style:italic">// terminate when i == end
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Not surprisingly, the range-based for loops over C-style arrays are exactly implemented using pointer arithmetic:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : arr) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><h2 id="c-style-strings">C-style strings</h2>
<p>Although C-style strings have fallen out of favor in modern C++ for being hard to use and dangerous comparing with <code>std::string</code> and <code>std::string_view</code>, we&rsquo;re going through the basics of them here. To define a classic C-style string vairable, we simply declare a C-style array variable of <code>char</code> (or <code>const char</code> / <code>constexpr char</code>) type:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str[<span style="color:#099">8</span>]{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span> str[]{<span style="color:#b84">&#34;this is a string&#34;</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">char</span> str[]{<span style="color:#b84">&#34;hello world&#34;</span>};
</span></span></code></pre></div><p>Remember that there is an extra character for the <strong>implicit null terminator</strong>. For this particular reason, it&rsquo;s highly recommended to omit the length upon declaration and the let the compiler calculate the length for you.</p>
<p>To print a C-style string, we can simply <code>std::cout</code> it because the output streams (e.g. <code>std::cout</code>) make some assumptions about your intent (address for non-cahr pointer, whole string for char pointers):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">char</span> ptr[]) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ptr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> str[] {<span style="color:#b84">&#34;this is fucked up&#34;</span>};
</span></span><span style="display:flex;"><span>    print(str);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since the output streams always prints the whole string when the underlying is a <code>char*</code>, weird things like the following can happen:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> c{<span style="color:#b84">&#39;Q&#39;</span>};                                        <span style="color:#998;font-style:italic">// just regular char 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">&amp;</span>c <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;                            <span style="color:#998;font-style:italic">// trying to print the address of a char
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">void</span><span style="font-weight:bold">*&gt;</span>(<span style="font-weight:bold">&amp;</span>c) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// this would work as expected 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output is</p>
<pre tabindex="0"><code>Q
0x16d64b08b
</code></pre><p>but the first line can be literally anything, like <code>Q╠╠╠╠╜╡4;¿■A</code> &ndash; that&rsquo;s what undefined behavior means.</p>
<p>To read a C-style string:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iterator&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> str[<span style="color:#099">255</span>]{};  <span style="color:#998;font-style:italic">// an array large enough to hold 254 characters + null terminator 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter your string: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin.getline(str, std<span style="font-weight:bold">::</span>size(str));
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;You entered: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> str <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To modify a C-style string, you can only assign values to each elements one by one:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str[]{<span style="color:#b84">&#34;what?&#34;</span>};
</span></span><span style="display:flex;"><span>str[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;o&#34;</span>;
</span></span></code></pre></div><p>To get the length of a C-style string, the previously mentioned functions don&rsquo;t work:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str[<span style="color:#099">255</span>]{<span style="color:#b84">&#34;string&#34;</span>};  <span style="color:#998;font-style:italic">// 254 available characters + null terminator; using 6+1 only
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>size(str);  <span style="color:#998;font-style:italic">// returns 255 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> ptr{str};  <span style="color:#998;font-style:italic">// decayed C-style string 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>size(ptr);  <span style="color:#998;font-style:italic">// compile error 
</span></span></span></code></pre></div><p>Luckily, we can use the <code>strlen()</code> function in the <code>&lt;cstring&gt;</code> header:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstring&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> str[<span style="color:#099">255</span>] {<span style="color:#b84">&#34;string&#34;</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>strlen(str) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> ptr {str};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>strlen(ptr) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Some other C-style string manipulating functions:</p>
<ul>
<li><code>strcpy</code>, <code>strncpy</code>, <code>strcpy_s</code>: overwrites one C-style string with another</li>
<li><code>strcat</code>, <code>strncat</code>: append one C-style string to the end of another</li>
<li><code>strcmp</code>, <code>strncmp</code>: compare two C-style strings (returns 0 if equal)</li>
</ul>
<h2 id="c-style-string-symbolic-constants">C-style string symbolic constants</h2>
<p>Although seemingly producing the same strings, C++ deals with the memory allocation differently in the following two ways to define a string symbolic constant:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span> name[] {<span style="color:#b84">&#34;Allen&#34;</span>};  <span style="color:#998;font-style:italic">// one copy in global memory, one for `name`
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> name{<span style="color:#b84">&#34;Allen&#34;</span>};    <span style="color:#998;font-style:italic">// only one copy and a pointer; more efficient 
</span></span></span></code></pre></div><p>Type deduction for a C-style string is fairly straightforward:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> s1{<span style="color:#b84">&#34;Allen&#34;</span>};   <span style="color:#998;font-style:italic">// const char* 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> s2{<span style="color:#b84">&#34;Allen&#34;</span>};  <span style="color:#998;font-style:italic">// const char*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> s3{<span style="color:#b84">&#34;Allen&#34;</span>};  <span style="color:#998;font-style:italic">// const char(&amp;)[5]
</span></span></span></code></pre></div><h2 id="multidimensional-c-style-arrays">Multidimensional C-style arrays</h2>
<p>We can define a two-dimensional C-style array as:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">3</span>];
</span></span></code></pre></div><p>C++ uses <strong>row-major order</strong> (there are languages e.g. Fortran that use column-major order), meaning that elements in an array are sequentially placed in memer row-by-row, ordered from left to right, top to bottom. For example, the elements inside the above array are placed sequentially in the following order:</p>
<pre tabindex="0"><code>[0][0] [0][1] [0][2] [1][0] [1][1] [1][2]
</code></pre><p>Initializing a two-dimentional array is as easy as</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">3</span>] {
</span></span><span style="display:flex;"><span>    {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The missing initializers will be value-initialized:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">3</span>] {
</span></span><span style="display:flex;"><span>    {<span style="color:#099">1</span>,<span style="color:#099">2</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">4</span>},
</span></span><span style="display:flex;"><span>};  <span style="color:#998;font-style:italic">// result in {{1,2,0},{4,0,0}}
</span></span></span></code></pre></div><p>You can also omit (only the leftmost) length in the declaration:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[][<span style="color:#099">3</span>] {
</span></span><span style="display:flex;"><span>    {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">4</span>}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Lastly, just like regular one-dimensional arrays, you can value-initialize the whole array to zeros:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>,<span style="color:#099">3</span>]{};
</span></span></code></pre></div><h2 id="multidimensional-stdarray">Multidimensional <code>std::array</code></h2>
<p>Is there a standard library class for multidimensional arrays? Sadly, the answer is no. However, we can still define one like follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">3</span><span style="font-weight:bold">&gt;</span>, <span style="color:#099">2</span><span style="font-weight:bold">&gt;</span> a {{
</span></span><span style="display:flex;"><span>    {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>}
</span></span><span style="display:flex;"><span>}};  <span style="color:#998;font-style:italic">// notice the double braces! 
</span></span></span></code></pre></div><p>This syntax is verbose and hard to read and requires double braces (for reasons mentioned in previous sections) and swaps the row- and column-number awkwardly. To make it easier to use, we can create an alias template like the following:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, std<span style="font-weight:bold">::</span>size_t Row, std<span style="font-weight:bold">::</span>size_t Col<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">using</span> Array2d <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>T, Col<span style="font-weight:bold">&gt;</span>, Row<span style="font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Array2d<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span><span style="font-weight:bold">&gt;</span> a {{
</span></span><span style="display:flex;"><span>    {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>}
</span></span><span style="display:flex;"><span>}};
</span></span></code></pre></div><p>In C++23 we have a new <code>std::mdspan</code> which provides a simple way to reshape a one-dimensional array to a multidimensional one:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">6</span><span style="font-weight:bold">&gt;</span> a{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>mdspan mdView { a.data(), <span style="color:#099">2</span>, <span style="color:#099">3</span> };  <span style="color:#998;font-style:italic">// first arg is a pointer to the array data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>size_t row {mdView.extents().extent(<span style="color:#099">0</span>)};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>size_t col {mdView.extents().extent(<span style="color:#099">1</span>)};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// print in 1d
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">for</span> (std<span style="font-weight:bold">::</span>size_t i<span style="font-weight:bold">=</span><span style="color:#099">0</span>; i <span style="font-weight:bold">&lt;</span> mdView.size(); <span style="font-weight:bold">++</span>i)
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> mdView.data_handle()[i] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// print in 2d
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">for</span> (std<span style="font-weight:bold">::</span>size_t r<span style="font-weight:bold">=</span><span style="color:#099">0</span>; r <span style="font-weight:bold">&lt;</span> row; <span style="font-weight:bold">++</span>r) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (std<span style="font-weight:bold">::</span>size_t c<span style="font-weight:bold">=</span><span style="color:#099">0</span>; c <span style="font-weight:bold">&lt;</span> col; <span style="font-weight:bold">++</span>c)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> mdView[r, c] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;  <span style="color:#998;font-style:italic">// operator[] accepts multiple indices since C++23
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>In C++26, we&rsquo;ll have <code>std::mdarray</code> which officially combines <code>std::array</code> with <code>std::mdview</code>. Hooray!</p>
<h1 id="iterators-and-algorithms">Iterators and Algorithms</h1>
<h2 id="sorting-an-array-using-selection-sort">Sorting an array using selection sort</h2>
<p>Selection sort performs the following steps to sort an array from smallest to largest:</p>
<ul>
<li>Starting at array index 0, search the entire array to find the smallest value</li>
<li>Swap the smallest value found in the array with the value at index 0</li>
<li>Repeat steps 1 &amp; 2 starting from the next index</li>
</ul>
<p>Here is how this algorithm is implemented in C++:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iterator&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;utility&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> array[] {<span style="color:#099">3</span>,<span style="color:#099">5</span>,<span style="color:#099">2</span>,<span style="color:#099">1</span>,<span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> length{<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(std<span style="font-weight:bold">::</span>size(array))};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i{}; i <span style="font-weight:bold">&lt;</span> length <span style="font-weight:bold">-</span> <span style="color:#099">1</span>; <span style="font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> i_min {i};
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> j{i <span style="font-weight:bold">+</span> <span style="color:#099">1</span>}; j <span style="font-weight:bold">&lt;</span> length; <span style="font-weight:bold">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span> (array[j] <span style="font-weight:bold">&lt;</span> array[i_min]) i_min <span style="font-weight:bold">=</span> j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>swap(array[i], array[i_min]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i{}; i <span style="font-weight:bold">&lt;</span> length; <span style="font-weight:bold">++</span>i) std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> array[i] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Provided in the <code>&lt;algorithm&gt;</code> header we have <code>std::sort</code> that does the tedius work for us:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iterator&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> array[] {<span style="color:#099">3</span>,<span style="color:#099">5</span>,<span style="color:#099">2</span>,<span style="color:#099">1</span>,<span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>sort(std<span style="font-weight:bold">::</span>begin(array), std<span style="font-weight:bold">::</span>end(array));
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : array) std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="introduction-to-iterators">Introduction to iterators</h2>
<p>An <strong>iterator</strong> is an object designed to traverse through a container (e.g. the values in an array, or the characters in a string), providing access to each element along the way. A container may provide different kinds of iterators. For example, an array container might offer a forwards iterator that walks through the array in forward order, and a reverse iterator that walks through the array in reverse order.</p>
<p>We can use a pointer as an iterator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array data{<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> begin{<span style="font-weight:bold">&amp;</span>data[<span style="color:#099">0</span>]};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> end{begin <span style="font-weight:bold">+</span> std<span style="font-weight:bold">::</span>size(data)};  <span style="color:#998;font-style:italic">// this is one after the last element 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> ptr{begin}; ptr <span style="font-weight:bold">!=</span> end; <span style="font-weight:bold">++</span>ptr)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also use standard library iterators:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array data{<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> begin{data.begin()};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> end{data.end()};  <span style="color:#998;font-style:italic">// also one after the last element 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> ptr{begin}; ptr <span style="font-weight:bold">!=</span> end; <span style="font-weight:bold">++</span>ptr)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>&lt;iterator&gt;</code> header also provides <code>std::begin</code> and <code>std::end</code> similarly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// this includes &lt;iterator&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array data{<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> begin{std<span style="font-weight:bold">::</span>begin(data)};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> end{std<span style="font-weight:bold">::</span>end(data)};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> ptr{begin}; ptr <span style="font-weight:bold">!=</span> end; <span style="font-weight:bold">++</span>ptr)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>ptr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice we&rsquo;re not using <code>operator&lt;</code> in the for loop above, because some iterator types are not relationally comparable and <code>operator!=</code> works with those types.</p>
<p>All types that have both <code>begin()</code> and <code>end()</code> member functions, or that can be used with <code>std::begin()</code> and <code>std::end()</code>, are usable in range-based for loops:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array data{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : data)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There is a concept called <strong>iterator invalidation</strong> which basically refers to an iterator becoming a dangling pointer. This happens when you modify the container while using the iterator. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector v {<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : v) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (i <span style="font-weight:bold">%</span> <span style="color:#099">2</span> <span style="font-weight:bold">==</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>            v.push_back(i <span style="font-weight:bold">+</span> <span style="color:#099">1</span>);  <span style="color:#998;font-style:italic">// modifying the container here 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program will generate undefined behavior for the iterator has been invalidated when we push the new elements into the container. Another example is</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector v{<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> i {v.begin};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">++</span>i;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// ok: prints 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    v.erase(i);  <span style="color:#998;font-style:italic">// modifying the container, iterator invalidated 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">++</span>i;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// undefined behavior!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To fix the above program, we can use the fact vector&rsquo;s <code>erase()</code> member function returns the iterator to the next element (or <code>end()</code> when the last element is erased):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector v{<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> i{v.begin()};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">++</span>i;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// ok: prints 1 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    i <span style="font-weight:bold">=</span> v.erase(i);   <span style="color:#998;font-style:italic">// i is overridden to the next position
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// ok: prints 2 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="introduction-to-standard-library-algorithms">Introduction to standard library algorithms</h2>
<p>The functionality provided in the algorithms library generally fall into one of three categories:</p>
<ul>
<li><strong>Inspectors</strong>: used to view (but not modify) data in a container, e.g. searching and counting</li>
<li><strong>Mutators</strong>: used to modify data in a container, e.g. sorting and shuffling</li>
<li><strong>Facilitators</strong>: used to generate a result based on values of the data members, e.g. multiplier or determining what order pairs of elements should be sorted in</li>
</ul>
<p>Using <code>std::find</code> to find an element by value:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array data{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter a value to search for and replace with: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> search{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> replace{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> search <span style="font-weight:bold">&gt;&gt;</span> replace;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> found{std<span style="font-weight:bold">::</span>find(data.begin(), data.end(), search)};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (found <span style="font-weight:bold">==</span> data.end())
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Could not find &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> search <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">*</span>found <span style="font-weight:bold">=</span> replace;  <span style="color:#998;font-style:italic">// yes it&#39;s that easy 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i : data)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using <code>std::find_if</code> to find an element that matches some condition:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">contains_nut</span>(std<span style="font-weight:bold">::</span>string_view str) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// std::string_view::find returns std::string_view::npos if not found 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> (str.find(<span style="color:#b84">&#34;nut&#34;</span>) <span style="font-weight:bold">!=</span> std<span style="font-weight:bold">::</span>string_view<span style="font-weight:bold">::</span>npos);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string_view, <span style="color:#099">4</span><span style="font-weight:bold">&gt;</span> arr{<span style="color:#b84">&#34;apple&#34;</span>, <span style="color:#b84">&#34;banana&#34;</span>, <span style="color:#b84">&#34;walnut&#34;</span>, <span style="color:#b84">&#34;lemon&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> found{std<span style="font-weight:bold">::</span>find_if(arr.begin(), arr.end(), contains_nut)};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (found <span style="font-weight:bold">==</span> arr.end())
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;no nuts</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;found &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>found <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using <code>std::count</code> and <code>std::count_if</code> to count how many occurrences there are in an array:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">contains_nut</span>(std<span style="font-weight:bold">::</span>string_view str) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// std::string_view::find returns std::string_view::npos if not found 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> (str.find(<span style="color:#b84">&#34;nut&#34;</span>) <span style="font-weight:bold">!=</span> std<span style="font-weight:bold">::</span>string_view<span style="font-weight:bold">::</span>npos);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string_view, <span style="color:#099">4</span><span style="font-weight:bold">&gt;</span> arr{<span style="color:#b84">&#34;apple&#34;</span>, <span style="color:#b84">&#34;banana&#34;</span>, <span style="color:#b84">&#34;walnut&#34;</span>, <span style="color:#b84">&#34;lemon&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> nuts {std<span style="font-weight:bold">::</span>count_if(arr.begin(), arr.end(), contains_nut)};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;there are &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> nuts <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; nut(s)</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using <code>std::sort</code> to do (custom) sort:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">greater</span>(<span style="color:#458;font-weight:bold">int</span> a, <span style="color:#458;font-weight:bold">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (a <span style="font-weight:bold">&gt;</span> b);  <span style="color:#998;font-style:italic">// true means first!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array arr{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">5</span>,<span style="color:#099">3</span>,<span style="color:#099">2</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>sot(arr.begin(), arr.end(), greater);  <span style="color:#998;font-style:italic">// this is gives DESCENDING order in result!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : arr)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice we can replace our <code>greater()</code> by the one provided by the C++:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>sort(arr.begin(), arr.end(), std<span style="font-weight:bold">::</span>greater{});  <span style="color:#998;font-style:italic">// greater is a type and thus need {} instantiation
</span></span></span></code></pre></div><p>Using <code>std::for_each</code> to do something to all elements of a container:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">double_number</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> i) {
</span></span><span style="display:flex;"><span>    i <span style="font-weight:bold">*=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>array arr{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">4</span>,<span style="color:#099">2</span>,<span style="color:#099">1</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>for_each(arr.begin(), arr.end(), double_number);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> i : arr)
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> i <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Having to explicitly pass <code>arr.begin()</code> and <code>arr.end()</code> in the above algorithms is a bit annoying, but luckily in C++20 we have added <em>ranges</em>, which allows us to simply pass <code>arr</code>. This will make our code even shorter and more readable.</p>
<h2 id="timing-your-code">Timing your code</h2>
<p>C++11 comes with some functionality in the <code>&lt;chrono&gt;</code> library to do some simple timing. We can encapsulate the timing inside a class to be used easily:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;chrono&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::chrono 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Timer</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> Clock <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>chrono<span style="font-weight:bold">::</span>steady_clock;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> Second <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>chrono<span style="font-weight:bold">::</span>duration<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span>, std<span style="font-weight:bold">::</span>ratio<span style="font-weight:bold">&lt;</span><span style="color:#099">1</span><span style="font-weight:bold">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>chrono<span style="font-weight:bold">::</span>time_point<span style="font-weight:bold">&lt;</span>Clock<span style="font-weight:bold">&gt;</span> m_beg {Clock<span style="font-weight:bold">::</span>now()};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> reset() {
</span></span><span style="display:flex;"><span>        m_beg <span style="font-weight:bold">=</span> Clock<span style="font-weight:bold">::</span>now();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">elapsed</span>() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>chrono<span style="font-weight:bold">::</span>duration_cast<span style="font-weight:bold">&lt;</span>Second<span style="font-weight:bold">&gt;</span>(Clock<span style="font-weight:bold">::</span>now() <span style="font-weight:bold">-</span> m_beg).count();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Then we can easily use it as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Timer t;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Time has elapsed &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> t.elapsed() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; seconds</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are three things that may impact timing:</p>
<ul>
<li>Make sure you&rsquo;re using a release build target instead of debug build target, which typically turn optimizatino off</li>
<li>Make sure other system activities are not impacting your program performance</li>
<li>If the program uses a random number generator, the particular random number used may impact timing, which a lot people overlook</li>
</ul>
<h1 id="dynamic-allocation">Dynamic Allocation</h1>
<h2 id="dynamic-memory-allocation-with-new-and-delete">Dynamic memory allocation with new and delete</h2>
<p>C++ supports three basic types of memory allocation, of which you&rsquo;ve already seen two:</p>
<ul>
<li>Static memory allocation</li>
<li>Automatic memory allocation</li>
<li>Dynamic memory allocation</li>
</ul>
<p>Both static and automatic allocation have two things in common:</p>
<ul>
<li>The size of the variable/array must be known at compile time</li>
<li>Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed)</li>
</ul>
<p>While we can use static/automatic allocation with a considerably large size at compile time that gauges on the maximum size of the variable, there are severa drawbacks:</p>
<ul>
<li>Wasted memory</li>
<li>Hard to tell which bits are actually used while others wasted</li>
<li>Stack overflow: variables are stored on <strong>stack</strong> which has generally quite small size e.g. 1MB for Visual Studio, which means you can overflow it with <code>int array[1000000]</code></li>
<li>It can leads to artificial limitations and/or array overflows when the user tries to read in more records than allocated</li>
</ul>
<p>Fortunately, we can address these problems by using <strong>dynamic memory allocation</strong>, which requests memory when needed from a much larger pool of memory called <strong>heap</strong>.</p>
<p>We can allocate a single variable dynamically using the <code>new</code> operator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>; <span style="color:#998;font-style:italic">// returns a pointer 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span> };  <span style="color:#998;font-style:italic">// dynamically allocate an integer and address it to a pointer
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">new</span> <span style="color:#900;font-weight:bold">int</span>(<span style="color:#099">5</span>) };  <span style="color:#998;font-style:italic">// direct initialization 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">5</span>} };  <span style="color:#998;font-style:italic">// uniform initialization
</span></span></span></code></pre></div><p>Note that accessing heap-allocated objects is generally slower than accessing stack-allocated objects because the compiler knows the address of stack-allocated objects and can go directly to the address. For heap-allocated ones, there are two steps: to get the address of the object (from the pointer) and to get the value at that address.</p>
<p>To delete a single variable from memory:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">delete</span> ptr;     <span style="color:#998;font-style:italic">// free the memory used by the object that ptr refers to 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;  <span style="color:#998;font-style:italic">// set ptr back to a null pointer
</span></span></span></code></pre></div><p>When operator <code>new</code> fails, a <code>bad_alloc</code> exception is thrown, which may cause a program termination if it&rsquo;s not handled properly. We can use the following method to solve this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">new</span>(std<span style="font-weight:bold">::</span>nothrow) <span style="color:#458;font-weight:bold">int</span> };  <span style="color:#998;font-style:italic">// don&#39;t throw error if new fails; instead, assign ptr to nullptr 
</span></span></span></code></pre></div><p>which is kinda shady and thus not recommended. Alternatively we can explicitly &ldquo;handle&rdquo; the issue (we&rsquo;ll cover actual exception handling later):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">new</span>(std<span style="font-weight:bold">::</span>nothrow) <span style="color:#458;font-weight:bold">int</span>{} };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>value) {  <span style="color:#998;font-style:italic">// if value is nullptr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Could not allocate memory</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To free the memory referred by a pointer (even when it&rsquo;s null already), we can simply</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">delete</span> ptr;
</span></span></code></pre></div><p>Dynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends, assuming your operating system does regular cleanup. This means we can sometimes accidentally cause memory leak by writing functions like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">do_something_stupid</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span> };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>By constantly calling this function, we&rsquo;re accumulating the memory allocated while deleting <code>ptr</code> as it&rsquo;s out of scope once out of the function, hence the unreferencable memory will increase until the program ends.</p>
<p>Another situation when we cause memory leak is to re-assign a pointer, and to fix these problems we can always just delete the pointer before leaving.</p>
<h2 id="dynamically-allocating-arrays">Dynamically allocating arrays</h2>
<p>We can dynamically allocate a C-style array too (for a dynamic <code>std::array</code>, you might as well just consider <code>std::vector</code> which is non-dynamically allocated). To allocate an array, we can</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstddef&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter a positive integer: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>size_t len{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> arr{ <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[len]{} };  <span style="color:#998;font-style:italic">// notice that length here doesn&#39;t need to be const!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;I just allocated an array of integers of length &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> len <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    arr[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">delete</span>[] arr;  <span style="color:#998;font-style:italic">// delete the whole array
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the above example, since we&rsquo;re dynamically allocating a C-style array, there are several differences than our previously covered arrays:</p>
<ul>
<li>The length/size doesn&rsquo;t need to be const any more</li>
<li>The size of the array can be very large, since it&rsquo;s now on heap rather than stack</li>
<li>There is a small performance regression</li>
</ul>
<p>Notice we&rsquo;re writing <code>int</code> twice in the above example. In practice, we can also avoid that by</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> arr { <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[len]{} };
</span></span></code></pre></div><p>When it comes to resizing the dynamic array &ndash; it&rsquo;s typically recommended to just go for <code>std::vector</code> as C++ doesn&rsquo;t have a built-in way to resize an array that&rsquo;s been allocated.</p>
<h2 id="destructors">Destructors</h2>
<p>A <strong>destructor</strong> is another special kind of class member function that is executed when an object of that class is destroyed. Whereas constructors are designed to initialize a class, destructors are designed to help clean up. When your class is holding any resources (e.g. dynamic memory or a file or database handle), or if you need to do any kind of maintenance before the object is destroyed, the destructor is the perfect place to do so.</p>
<p>Like constructors, destructors have specific naming rules:</p>
<ul>
<li>The destructor must have the same name as the class, preceded by a tilde <code>~</code></li>
<li>The destructor can not take arguments</li>
<li>The destructor has no return type</li>
</ul>
<p>Below is a simple example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstddef&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">IntArray</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> m_array{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_len{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    IntArray(<span style="color:#458;font-weight:bold">int</span> len) {
</span></span><span style="display:flex;"><span>        assert(len <span style="font-weight:bold">&gt;</span> <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>        m_array <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>size_t<span style="font-weight:bold">&gt;</span>(len)]{};
</span></span><span style="display:flex;"><span>        m_len <span style="font-weight:bold">=</span> len;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>IntArray() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_array;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// other public member functions 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>The above examle adopts a concept called RAII (Resource Acquisition Is Initialization) which states the resource (e.g. memory, file and database handles) acquisition should happen in constructors and resource releasing in destructors. This helps prevent resource leaks.</p>
<p>Lastly, take special note about <code>std::exit()</code> because no destructors will be called when you use <code>std::exit()</code> to terminate the program.</p>
<h2 id="pointers-to-pointers-and-dynamic-multidimensional-arrays">Pointers to pointers and dynamic multidimensional arrays</h2>
<p>Since pointers are also objects, it&rsquo;s natural to think that we can define a pointer that points to another pointer (though a bit tongue-twistery):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> val { <span style="color:#099">5</span> };           <span style="color:#998;font-style:italic">// just an int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> ptr { <span style="font-weight:bold">&amp;</span>value };     <span style="color:#998;font-style:italic">// ptr is pointing at the address of val
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">**</span> ptrptr { <span style="font-weight:bold">&amp;</span>ptr};    <span style="color:#998;font-style:italic">// ptrptr is pointing at the address of ptr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">**</span>ptrptr;   <span style="color:#998;font-style:italic">// prints 5
</span></span></span></code></pre></div><p>With pointers to pointers, we can define dynamic multidimensional arrays:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> rows { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> cols { <span style="color:#099">10</span> };
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">**</span> arr { <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span>[rows] };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i{}; i <span style="font-weight:bold">&lt;</span> cols; <span style="font-weight:bold">++</span>i)
</span></span><span style="display:flex;"><span>    arr[i] <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[cols];
</span></span></code></pre></div><p>Note that we can also make the array non-rectangular e.g. triangular, since we&rsquo;re just iteratively allocating row arrays.</p>
<h2 id="void-pointers">Void pointers</h2>
<p>The <strong>void pointer</strong>, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type. A void pointer is declared like any normal pointer with its type being <code>void*</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span> y{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">S</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">float</span> f;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>S s{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="font-weight:bold">*</span> ptr{};
</span></span><span style="display:flex;"><span>ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>x;  <span style="color:#998;font-style:italic">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>y;  <span style="color:#998;font-style:italic">// ok 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>s;  <span style="color:#998;font-style:italic">// ok!
</span></span></span></code></pre></div><p>However, since a void pointer doesn&rsquo;t know the actual underlying type it&rsquo;s pointing to, dereferencing a void pointer is illegal. Instead, it must be first cast to a specific pointer type before being dereferenced:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="font-weight:bold">*</span> ptr{};
</span></span><span style="display:flex;"><span>ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> iptr{<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*&gt;</span>(ptr)};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>iptr;
</span></span></code></pre></div><p>For the same reason, deleting a void poitner will result in undefined behavior and should be avoided unless you cast it to a specific typed pointer first. Also, pointer arithmetic is not allowed on void pointers as it doesn&rsquo;t know what size the underlying object has.</p>
<p>There is no such thing as void reference, as a reference always has an underlying instance/object and thus knows the type.</p>
<h1 id="functions">Functions</h1>
<h2 id="function-pointers">Function pointers</h2>
<p>Idenifier is a function&rsquo;s name, but what type is the function? Functions have their own lvalue function types: the return type together with arguments make the type. Much like variables, functions live at an assigned address in memory. When we print the function itself via <code>operator&lt;&lt;</code>, the function pointer is implicitly converted to a <code>bool</code> and always prints <code>1</code>. In some other cases, te compiler has an extension to prints the actual address of the function pointer. If it&rsquo;s not done automatically, you can cast the function pointer to a void pointer to let the compiler know it&rsquo;s the address you want to print:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">foo</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">reinterpret_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">void</span><span style="font-weight:bold">*&gt;</span>(foo) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To define a function pointer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> (<span style="font-weight:bold">*</span>fcnPtr) ();  <span style="color:#998;font-style:italic">// notice the difference between this and below 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">fcn</span> ();    <span style="color:#998;font-style:italic">// this is just a function taking no args and returning int*
</span></span></span></code></pre></div><p>Only the first line defines <code>fcnPtr</code> as a function pointer. The second line is just a function.</p>
<p>To define a const function pointer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> (<span style="font-weight:bold">*</span><span style="font-weight:bold">const</span> fcnPtr) ();  <span style="color:#998;font-style:italic">// correct 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">const</span> <span style="color:#900;font-weight:bold">int</span> (<span style="font-weight:bold">*</span>fcnPtr) ();  <span style="color:#998;font-style:italic">// wrong 
</span></span></span></code></pre></div><p>The first line defines a const function pointer. The second is a function pointer on a function returning const int.</p>
<p>To assign a function pointer to a function, it&rsquo;s pretty much what we&rsquo;ve been doing with pointers all the time:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>fcnPtr <span style="font-weight:bold">=</span> <span style="font-weight:bold">&amp;</span>foo;  <span style="color:#998;font-style:italic">// no parentheses!!
</span></span></span></code></pre></div><p>Same with calling a function via it&rsquo;s pointer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>(<span style="font-weight:bold">*</span>fcnPtr)(<span style="color:#099">5</span>);  <span style="color:#998;font-style:italic">// assuming function foo takes a single arg in int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>fcnPtr(<span style="color:#099">5</span>);     <span style="color:#998;font-style:italic">// implicit dereference! works like magic
</span></span></span></code></pre></div><p>We can also pass a function pointer to other functions as arguments:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">selection_sort</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> array, <span style="color:#458;font-weight:bold">int</span> size, <span style="color:#458;font-weight:bold">bool</span> (<span style="font-weight:bold">*</span>compare)(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">selection_sort</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> array, <span style="color:#458;font-weight:bold">int</span> size, <span style="color:#458;font-weight:bold">bool</span> compare(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>));  <span style="color:#998;font-style:italic">// implicit conversion again!
</span></span></span></code></pre></div><p>Notice how on the second line above the <code>compare</code> function pointer gets implicitly converted for more succinct code. This only works when it&rsquo;s a function argument inside another function. To make everything more neat, we can define type aliases for function pointers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">using</span> CompareFunction <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">bool</span>(<span style="font-weight:bold">*</span>)(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">selection_sort</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> array, <span style="color:#458;font-weight:bold">int</span> size, CompareFunction compare);
</span></span></code></pre></div><p>Alternatively, we can also use the <code>std::function</code> class provided by the standard library in <code>&lt;functional&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;functional&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">selection_sort</span>(<span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> array, <span style="color:#458;font-weight:bold">int</span> size, std<span style="font-weight:bold">::</span>function<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">bool</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)<span style="font-weight:bold">&gt;</span> compare);
</span></span></code></pre></div><h2 id="the-stack-and-the-heap">The stack and the heap</h2>
<p>The memory that a program uses is typically divided into a few different areas called segments:</p>
<ul>
<li>The <strong>code</strong> segment (also known as the text segment), where the compiled program sits in memory and is read-only</li>
<li>The <strong>bss</strong> segment (also known as the uninitialized data segment), where zero-initialized global and static variables are stored</li>
<li>The <strong>data</strong> segment (also known as the initialied data segment), where initialied global and static variables are stored</li>
<li>The <strong>heap</strong> segment (also known as the free store), where dynamically allocated variables are allocated from</li>
<li>The <strong>call stack</strong>, where function parameters, local variables and other function related information are stored</li>
</ul>
<p>Advantages and disadvantages of the heap:</p>
<ul>
<li>Allocating memory on the heap is comparatively slow.</li>
<li>Allocated memory stays allocated until it is specifically deallocated (beware memory leaks) or the application ends (at which point the OS should clean it up).</li>
<li>Dynamically allocated memory must be accessed through a pointer. Dereferencing a pointer is slower than accessing a variable directly.</li>
<li>Because the heap is a big pool of memory, large arrays, structures, or classes can be allocated here.</li>
</ul>
<p>Advantages and disadvantages of the stack:</p>
<ul>
<li>Allocating memory on the stack is comparatively fast.</li>
<li>Memory allocated on the stack stays in scope as long as it is on the stack. It is destroyed when it is popped off the stack.</li>
<li>All memory allocated on the stack is known at compile time. Consequently, this memory can be accessed directly through a variable.</li>
<li>Because the stack is relatively small, it is generally not a good idea to do anything that eats up lots of stack space. This includes allocating or copying large arrays or other memory-intensive structures.</li>
</ul>
<h2 id="recursion">Recursion</h2>
<p>A recursive function is a function that calls itself. Check the following (poorly written) function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">count_down</span>(<span style="color:#458;font-weight:bold">int</span> count) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;push &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> count <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    count_down(count <span style="font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The function calls itself indefinitely and thus likely will cause a stack overflow. When <strong>tail call</strong> (recursive calling itself at the end only) optimization happens in compiler, however, the proram will run forever instead of throwing a stack overflow error.</p>
<p>To remedy this problem, we can write the termination condition for the recursion:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">count_down</span>(<span style="color:#458;font-weight:bold">int</span> count) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>count) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;push &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> count <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    count_down(count <span style="font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="command-line-arguments">Command line arguments</h2>
<p>When we want to utilize the command line arguments of a program, we can explicitly write <code>main()</code> in the following form:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> argv[]);  <span style="color:#998;font-style:italic">// or 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">**</span> argv);
</span></span></code></pre></div><p>Where <code>argc</code> is the count of command line arguments, and <code>argv</code> is the array of actual arguments passed.</p>
<p>When we want to convert the element in <code>argv</code> to numeric (since they&rsquo;re always read as strings), we can</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;sstream&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::stringstream 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> num {};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>stringstream convert { argv[<span style="color:#099">1</span>] };
</span></span><span style="display:flex;"><span>convert <span style="font-weight:bold">&gt;&gt;</span> num;
</span></span></code></pre></div><h2 id="ellipsis-and-why-to-avoid-them">Ellipsis (and why to avoid them)</h2>
<p>There are certain cases where it can be useful to be able to pass a variable number of parameters to a function, and C++ provides a special specifier known as <strong>ellipsis</strong> that allows us to do precisely that. Functions that use ellipsis take the form as below:</p>
<pre tabindex="0"><code>return_type function_name(argument_list, ...)
</code></pre><p>To use ellipsis, we need <code>&lt;cstdarg&gt;</code> header and use <code>std::va_list</code> to hold the values, <code>std::va_start()</code> to initialize it, and <code>std::va_arg()</code> to extract values from the <code>std::va_list</code>. For example, the following function calculates the average of variable count of numbers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cstdarg&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// needed for ellipsis 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">calc_average</span>(<span style="color:#458;font-weight:bold">int</span> count, ...) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> sum{<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>va_list list;           <span style="color:#998;font-style:italic">// to get values in ellipsis 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>va_start(list, count);  <span style="color:#998;font-style:italic">// the first is the target list to initialize, the second is the last non-ellipsis arg
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> arg{}; arg <span style="font-weight:bold">&lt;</span> count; <span style="font-weight:bold">++</span>arg)
</span></span><span style="display:flex;"><span>        sum <span style="font-weight:bold">+=</span> std<span style="font-weight:bold">::</span>va_arg(list, <span style="color:#458;font-weight:bold">int</span>);  <span style="color:#998;font-style:italic">// the first is the target list, the second is element type 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>va_end(list);           <span style="color:#998;font-style:italic">// clean up the va_list
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span>(sum) <span style="font-weight:bold">/</span> count;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> calc_average(<span style="color:#099">5</span>, <span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> calc_average(<span style="color:#099">3</span>, <span style="color:#099">5</span>,<span style="color:#099">3</span>,<span style="color:#099">1</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The ellipsis is dangerous as it doesn&rsquo;t do type checking at all when you extract the values using <code>va_arg</code>. For example, using the <code>calc_average</code> function above:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> calc_average(<span style="color:#099">6</span>, <span style="color:#099">1.0</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>, <span style="color:#099">6</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>The output would be surprising:</p>
<pre tabindex="0"><code>1.78782e+008
</code></pre><p>This result epitomizes the phrase &ldquo;garbage in, garbage out&rdquo; which means a computer, unlike humans, will unquestioningly process whatever you want it to and potentially produce nonsentical output.</p>
<p>Another reason why ellipsis is dangerous, is that it doesn&rsquo;t know the length of the input. To properly use it we much pass a count argument (like above) or use a sentinel value to terminate.</p>
<p>As a conclusion, it&rsquo;s generally suggested to avoid using ellipsis altogether.</p>
<h2 id="introduction-to-lambdas-anonymous-functions">Introduction to lambdas (anonymous functions)</h2>
<p>A <strong>lambda expression</strong> (also known as a <strong>lambda</strong> or <strong>closure</strong>) allows us to define an anonymous function inside another function. This nesting is important as it allows us to avoid namespace pollution and to define the function as close to where it is used as possible.</p>
<p>The syntax for lambdas in C++ is</p>
<pre tabindex="0"><code>[captureClause] (parameters) -&gt; returnType { statements; }
</code></pre><p>The capture clause can be left empty if not needed. The paremeters can be left empty or even ommited entirely with brackets. The return type is optional and assumed auto if omitted. Therefore, the simplest lambda is just <code>[]{}</code>.</p>
<p>Below is another example that passes a lambda to <code>std::find_if</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string_view, <span style="color:#099">4</span><span style="font-weight:bold">&gt;</span> arr{<span style="color:#b84">&#34;apple&#34;</span>, <span style="color:#b84">&#34;banana&#34;</span>, <span style="color:#b84">&#34;walnut&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> found{ std<span style="font-weight:bold">::</span>find_if(
</span></span><span style="display:flex;"><span>        arr.begin(),
</span></span><span style="display:flex;"><span>        arr.end(),
</span></span><span style="display:flex;"><span>        [](std<span style="font-weight:bold">::</span>string_view str){ <span style="font-weight:bold">return</span> str.find(<span style="color:#b84">&#34;nut&#34;</span>) <span style="font-weight:bold">!=</span> std<span style="font-weight:bold">::</span>string_view<span style="font-weight:bold">::</span>npos; }
</span></span><span style="display:flex;"><span>    ) };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (found <span style="font-weight:bold">==</span> arr.end())
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;No nuts</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Found &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>found <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For advanced readers: a lambda is not a function, but instead a special kind of object in compiler called a <strong>functor</strong> that contain an overloaded <code>operator()</code> that make them callable like a function.</p>
<p>If for some reason we want to &ldquo;name&rdquo; a lambda and save it to a variable, there are three ways:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;functional&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> (<span style="font-weight:bold">*</span>add_numbers)(<span style="color:#458;font-weight:bold">double</span>, <span style="color:#458;font-weight:bold">double</span>) {
</span></span><span style="display:flex;"><span>        [](<span style="color:#458;font-weight:bold">double</span> a, <span style="color:#458;font-weight:bold">double</span> b) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> a <span style="font-weight:bold">+</span> b;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }; <span style="color:#998;font-style:italic">// to a function pointer 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>function add_number {  <span style="color:#998;font-style:italic">// note we can omit &lt;double(double, double)&gt; here since C++17
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        [](<span style="color:#458;font-weight:bold">double</span> a, <span style="color:#458;font-weight:bold">double</span> b) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> a <span style="font-weight:bold">+</span> b;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };  <span style="color:#998;font-style:italic">// to a std::function 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> add_number {
</span></span><span style="display:flex;"><span>        [](<span style="color:#458;font-weight:bold">double</span> a, <span style="color:#458;font-weight:bold">double</span> b) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> a <span style="font-weight:bold">+</span> b;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can use <code>auto</code> for the parameters in a lambda to make our code simpler:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;array&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">constexpr</span> std<span style="font-weight:bold">::</span>array months {
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;January&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;February&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;March&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;April&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;May&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;June&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;July&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;August&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;September&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;October&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;November&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#b84">&#34;December&#34;</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> start_with_same_letter { std<span style="font-weight:bold">::</span>adjacent_find(
</span></span><span style="display:flex;"><span>        months.begin(),
</span></span><span style="display:flex;"><span>        months.end(),
</span></span><span style="display:flex;"><span>        [](<span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> a, <span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;</span> b) { <span style="font-weight:bold">return</span> a[<span style="color:#099">0</span>] <span style="font-weight:bold">==</span> b[<span style="color:#099">0</span>]; }
</span></span><span style="display:flex;"><span>    ) };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (start_with_same_letter <span style="font-weight:bold">!=</span> months.end()) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>start_with_same_letter <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and &#34;</span>
</span></span><span style="display:flex;"><span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>std<span style="font-weight:bold">::</span>next(start_with_same_letter)
</span></span><span style="display:flex;"><span>                  <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; start with the same letter</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, using <code>auto</code> can be dangerous as well in some cases, say</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> five_letter_months { std<span style="font-weight:bold">::</span>count_if(
</span></span><span style="display:flex;"><span>    months.begin(),
</span></span><span style="display:flex;"><span>    months.end(),
</span></span><span style="display:flex;"><span>    [](std<span style="font-weight:bold">::</span>string_view str) { <span style="font-weight:bold">return</span> str.length() <span style="font-weight:bold">==</span> <span style="color:#099">5</span>; }
</span></span><span style="display:flex;"><span>) };
</span></span></code></pre></div><p>If we use <code>auto</code> instead of <code>str:string_view</code> in the lambda, the inferred type would be <code>const char*</code> and thus a lot of functionalities would be lost.</p>
<p>In terms of constexpr lambdas: all lambdas are implicitly constexpr as of C++17 if the lambda has no captures (or all captures are constexpr) and calls no other functions (or all functions it calls are constexpr). Considering a lot of functions in standard library are made constexpr only since C++20, these conditions are likely <strong>not true</strong> until C++20.</p>
<p>One thing to be aware is that each generic lambda corresponds to a different type, meaning that we can define one lambda for different independent tasks:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> count_print {
</span></span><span style="display:flex;"><span>        [](<span style="font-weight:bold">auto</span> value) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> count{};
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> count <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#b84">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    print(<span style="color:#b84">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>    print(<span style="color:#b84">&#34;bye&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the output for above program is</p>
<pre tabindex="0"><code>0: hello
1: world 
0: 1
1: 2
2: bye
</code></pre><p>In terms of return type deduction: we need to make sure all possible return values are of the same type when we don&rsquo;t specify the return type for a lambda, otherwise there will be a compile error:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> divide {
</span></span><span style="display:flex;"><span>    [](<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y, <span style="color:#458;font-weight:bold">bool</span> integer_division) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (integer_division)
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> x <span style="font-weight:bold">/</span> y;  <span style="color:#998;font-style:italic">// return type is int 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">else</span> 
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span>(x) <span style="font-weight:bold">/</span> y;  <span style="color:#998;font-style:italic">// error: return type doesn&#39;t match 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>To fix this problem, we need to either explicitly convert and make sure types match, or explicitly specify the return type and let the compiler implicitly convert types for us:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> divide {
</span></span><span style="display:flex;"><span>    [](<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y, <span style="color:#458;font-weight:bold">bool</span> integer_division) <span style="font-weight:bold">-&gt;</span> <span style="color:#458;font-weight:bold">double</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (integer_division)
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> x <span style="font-weight:bold">/</span> y;  <span style="color:#998;font-style:italic">// compiler would implicitly convert int to double for us 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span>(x) <span style="font-weight:bold">/</span> y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Lastly, we don&rsquo;t need to define many simple functions as lambdas because we have a bunch of them defined in <code>&lt;functional&gt;</code> provided by standard library. What differentiates them from lambdas is that they need to instantiated e.g. <code>std::greater{}</code> before being used like a function.</p>
<h2 id="lambda-captures">Lambda captures</h2>
<p>Lambdas can only access global identifiers, entities that are known at compile time, and entities with static storage duration. That means local variables are not accessible by lambdas and thus we cannot &ldquo;partially&rdquo; pass values to a lambda. This brings up the concept of captures. The <strong>captuer clause</strong> is used to indirectly give a lambda access to variables available in the surrounding scope that it normally would not have access to. All we need to do is list the entities we want to access from within the lambda as part of the capture clause. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>string search{};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> search;  <span style="color:#998;font-style:italic">// search is not available at compile time
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">auto</span> found { std<span style="font-weight:bold">::</span>find_if(
</span></span><span style="display:flex;"><span>    arr.begin();
</span></span><span style="display:flex;"><span>    arr.end();
</span></span><span style="display:flex;"><span>    [search](std<span style="font-weight:bold">::</span>string_view str) { <span style="font-weight:bold">return</span> str.find(search) <span style="font-weight:bold">!=</span> std<span style="font-weight:bold">::</span>string_view<span style="font-weight:bold">::</span>npos; }  <span style="color:#998;font-style:italic">// check capture clause!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>) };
</span></span></code></pre></div><p>Captures are essentially const copies of the original variables (instead of actual references, for example). While we can mark the lambda with specifier <code>mutable</code> so that the captures becomes non-const, they&rsquo;re still just copies and thus won&rsquo;t affect the original variables:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> ammo{<span style="color:#099">10</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> shoot {
</span></span><span style="display:flex;"><span>        [ammo]() <span style="font-weight:bold">mutable</span> {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">--</span>ammo;
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Pew! &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ammo <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; shot(s) left</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    shoot();
</span></span><span style="display:flex;"><span>    shoot();
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ammo <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; shot(s) left</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What the above prints is</p>
<pre tabindex="0"><code>Pew! 9 shot(s) left 
Pew! 8 shot(s) left 
10 shot(s) left
</code></pre><p>To actually capture a variable by reference, we can prepend the variable name with an ampersand <code>&amp;</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> ammo{<span style="color:#099">10</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> shoot {
</span></span><span style="display:flex;"><span>        [<span style="font-weight:bold">&amp;</span>ammo]() { <span style="color:#998;font-style:italic">// no need for mutable any more 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="font-weight:bold">--</span>ammo;
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Pew! &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ammo <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; shot(s) left</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    shoot();
</span></span><span style="display:flex;"><span>    shoot();
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ammo <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; shot(s) left</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the above prints</p>
<pre tabindex="0"><code>Pew! 9 shot(s) left
Pew! 8 shot(s) left 
8 shot(s) left
</code></pre><p>Multiple variables can be captured by suing commas to separate them. This can include a mix of captures by value and by reference. In the extreme case, a <strong>default capture</strong> (also known as a capture-default) captures all variables that are mentioned in the lambda. To capture all used variables by value, use <code>=</code>. To capture all used variables by reference, use <code>&amp;</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> width{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> height{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> width <span style="font-weight:bold">&gt;&gt;</span> height;  <span style="color:#998;font-style:italic">// width and height are not known at compile time 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">auto</span> found { std<span style="font-weight:bold">::</span>find_if(
</span></span><span style="display:flex;"><span>        arr.begin(),
</span></span><span style="display:flex;"><span>        arr.end(),
</span></span><span style="display:flex;"><span>        [<span style="font-weight:bold">=</span>](<span style="color:#458;font-weight:bold">int</span> area) { <span style="font-weight:bold">return</span> width <span style="font-weight:bold">*</span> height <span style="font-weight:bold">==</span> area; }
</span></span><span style="display:flex;"><span>    ) };  <span style="color:#998;font-style:italic">// width and height are captured by value to lambda
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>We can even define new variables inside capture:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">auto</span> found { std<span style="font-weight:bold">::</span>find_if(
</span></span><span style="display:flex;"><span>    arr.begin(),
</span></span><span style="display:flex;"><span>    arr.end(),
</span></span><span style="display:flex;"><span>    [specified_area{width <span style="font-weight:bold">*</span> height}](<span style="color:#458;font-weight:bold">int</span> area) { <span style="font-weight:bold">return</span> specified_area <span style="font-weight:bold">==</span> area; };
</span></span><span style="display:flex;"><span>) };
</span></span></code></pre></div><h1 id="operator-overloading">Operator Overloading</h1>
<h2 id="introduction-to-operator-overloading">Introduction to operator overloading</h2>
<p>In C++, operators are implemented as functions. By using function overloading on the operator functions, we can define our own version of the operators that work with different data types.</p>
<p>There are some limitations on operator overloading:</p>
<ul>
<li>Almost all C++ operators can be overloaded. The exceptions are: <code>?:</code> (conditional), <code>sizeof</code>, <code>::</code> (scope), <code>.</code> (member selector), <code>.*</code> (pointer member selector), <code>typeid</code> and the casting operators.</li>
<li>You can only overload existing operators and cannot create e.g. <code>operator**</code> to do exponents.</li>
<li>At least one of the operands must be a user-defined type, e.g. you cannot overload <code>operator+</code> on <code>int</code> and <code>double</code>, as both are native types. However, since standard library classes are also considered user-defined, overloading on <code>int</code> and <code>std::string</code> is allowed (but not recommended).</li>
<li>It&rsquo;s not possible to change the number of operands an operator supports</li>
<li>All operators keep their default precedence and associativity regardless of what they&rsquo;re used for and this doesn&rsquo;t change with overloading. For example, while some beginners might want to overload the XOR operator <code>^</code> to do exponentiation, since <code>^</code> has a lower precedence than the basic arithmetic operators, the expressions in the end might get evaluated incorrectly.</li>
</ul>
<h2 id="overloading-the-arithmetic-operators-using-friend-functions">Overloading the arithmetic operators using friend functions</h2>
<p>There are three different ways to overload operators:</p>
<ul>
<li>The member function way</li>
<li>The friend function way</li>
<li>The normal function way</li>
</ul>
<p>In this lesson we focus on the friend function way because it&rsquo;s the most intuitive for binary operators.</p>
<p>Say we have a custom class storing how many cents of money we have and we&rsquo;d like to overload <code>operator+</code> for multiple cents instances:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Cents</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_cents{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Cents(<span style="color:#458;font-weight:bold">int</span> cents) <span style="font-weight:bold">:</span> m_cents { cents } {}
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> Cents <span style="font-weight:bold">operator</span><span style="font-weight:bold">+</span>(<span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> c2);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getCents</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_cents; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Cents <span style="font-weight:bold">operator</span><span style="font-weight:bold">+</span>(<span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> c2) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> c1.m_cents <span style="font-weight:bold">+</span> c2.m_cents;
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// we can also define the friend function inside the class
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Cents c1{<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    Cents c2{<span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span>    Cents csum{c1 <span style="font-weight:bold">+</span> c2};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;I have &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> csum.getCents() <span style="color:#b84">&#34; cents in total</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also overload other arithmetic operators and even for mixed types. Also, we can call overloaded operators when defining another friend function, e.g. overload <code>operator-</code> using <code>operator+</code>.</p>
<h2 id="overloading-operators-using-normal-functions">Overloading operators using normal functions</h2>
<p>When we don&rsquo;t need the access to private members, we can just define the overloaded operator as a normal member function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Cents <span style="font-weight:bold">operator</span><span style="font-weight:bold">+</span>(<span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> c2) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> Cents{ c1.getCents() <span style="font-weight:bold">+</span> c2.getCents() };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The one difference between a friend function versus a normal function in this case, besides the accessibility, is that when we declare the class, we declare the friend functions in the header file as well, and that serves as a prototype inherently. For a normal function, we need to provide this prototype/declaration inside the header ourselves to make it explicit that this overload exists for the users of the header file.</p>
<h2 id="overloading-the-io-operators">Overloading the I/O operators</h2>
<p>Overloading <code>operator&lt;&lt;</code> is similar to overloading <code>operator+</code> since they&rsquo;re both binary operators, except that the parameter types are a bit different:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// std::ostream is the type of std::cout 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> out, <span style="font-weight:bold">const</span> Type<span style="font-weight:bold">&amp;</span> obj);
</span></span></code></pre></div><p>Overloading <code>operator&gt;&gt;</code> is done in a manner analogous to overloading <code>operator&gt;&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// std::istream is the type of std::cin
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>istream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&gt;&gt;</span>(std<span style="font-weight:bold">::</span>istream<span style="font-weight:bold">&amp;</span> in, Type<span style="font-weight:bold">&amp;</span> obj);
</span></span></code></pre></div><h2 id="overloading-operators-using-member-functions">Overloading operators using member functions</h2>
<p>Overloading operators using a member function is very similar to overloading operators using a friend function. When overloading an operator using a member function:</p>
<ul>
<li>The overloaded operator must be added as a member function of the left operator</li>
<li>The left operator becomes the implicit <code>*this</code> object</li>
<li>All other operands become function parameters</li>
</ul>
<p>Re-using the previous example where we implemented using friend functions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Cents</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_cents{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Cents(<span style="color:#458;font-weight:bold">int</span> cents) <span style="font-weight:bold">:</span> m_cents {cents } {};
</span></span><span style="display:flex;"><span>    Cents <span style="font-weight:bold">operator</span><span style="font-weight:bold">+</span>(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getCents</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_cents;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Cents Cents<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">+</span>(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> Cents{m_cents <span style="font-weight:bold">+</span> value};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since they&rsquo;re just so similar, how on earth should we decide whether we&rsquo;re doing the friend function or member function way? Well, there are a few more things to note:</p>
<ul>
<li>Not everything can be overloaded as a friend function: <code>operator=</code>, <code>operator[]</code>, <code>operator()</code> and <code>operator-&gt;</code> can only be overloaded as member functions</li>
<li>Not everything can be overloaded as a member function: we cannot add a member function to a left operand who&rsquo;s not a class (e.g. <code>int</code>) or who&rsquo;s not modifiable (e.g. <code>std::ostream</code>)</li>
</ul>
<p>Typically, the following are some rules of thumb to decide which overloading we should define:</p>
<ul>
<li>When dealing with binary operators that <strong>don&rsquo;t modify the left operand</strong> (e.g. <code>operator+</code>) it&rsquo;s recommended to use the normal or friend function overload</li>
<li>When dealing with binary operators that <strong>do modify the left operand</strong> (e.g. <code>operator+=</code>) it&rsquo;s preferred to do it via member functions &ndash; if you can modify the class of the left operand, otherwise use normal functions</li>
<li>Unary operators are usually overloaded as member functions since they don&rsquo;t have parameters in that case</li>
<li>These operators can only be overloaded as member functions: <code>operator=</code>, <code>operator[]</code>, <code>operator()</code> and <code>operator-&gt;</code></li>
</ul>
<h2 id="overloading-unary-operators----and-">Overloading unary operators <code>+</code>, <code>-</code> and <code>!</code></h2>
<p>A simple example of how we might define <code>operator-</code> on the <code>Cents</code> class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Cents Cents<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">-</span>() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> Cents{<span style="font-weight:bold">-</span>m_cents};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="overloading-the-comparison-operators">Overloading the comparison operators</h2>
<p>Because comparison operators are all binary and not modifying the left operands, we can define them as friend functions (or normal if possible):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Car</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_make;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_model;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Car(std<span style="font-weight:bold">::</span>string_view make, std<span style="font-weight:bold">::</span>string_view model)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_make{make}, m_model{model} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="color:#458;font-weight:bold">bool</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">==</span>(<span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c2);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="color:#458;font-weight:bold">bool</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">!=</span>(<span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c2);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">==</span>(<span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c2) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> (c1.m_make <span style="font-weight:bold">==</span> c2.m_make) <span style="font-weight:bold">&amp;&amp;</span>   <span style="color:#998;font-style:italic">// &amp; is bitwise/logical; &amp;&amp; is logical only
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>           (c1.m_model <span style="font-weight:bold">==</span> c2.m_model);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">!=</span>(<span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c1, <span style="font-weight:bold">const</span> Car<span style="font-weight:bold">&amp;</span> c2) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">!</span>(c1 <span style="font-weight:bold">==</span> c2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As suggested above, we can minimize the comparative redundancy by</p>
<ul>
<li>Implement <code>operator!=</code> as <code>!(operator==)</code></li>
<li>Implement <code>opertor&gt;</code> as <code>operator&lt;</code> with parameters flipped</li>
<li>Implement <code>operator&gt;=</code> as <code>!(operator&lt;)</code></li>
<li>Implement <code>operator&lt;=</code> as <code>!(operator&gt;)</code></li>
</ul>
<p>C++20 introduces the spaceship operator <code>operator&lt;=&gt;</code> which allows us to reduce the number of comparison functions to implement to just 2 or even 1:</p>
<ul>
<li><code>(A &lt;=&gt; B) &lt; 0</code> if <code>A &lt; B</code></li>
<li><code>(A &lt;=&gt; B) &gt; 0</code> if <code>A &gt; B</code></li>
<li><code>(A &lt;=&gt; B) == 0</code> if <code>A == B</code></li>
</ul>
<h2 id="overloading-the-increment-and-decrement-operators">Overloading the increment and decrement operators</h2>
<p>Since increment and decrement are urary and modifying the operand, they&rsquo;re best implemented as member functions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Digit</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_digit{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Digit(<span style="color:#458;font-weight:bold">int</span> digit) <span style="font-weight:bold">:</span> m_digit {digit} {}
</span></span><span style="display:flex;"><span>    Digit<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">++</span>();     <span style="color:#998;font-style:italic">// prefix
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Digit<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">--</span>();     <span style="color:#998;font-style:italic">// prefix
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Digit<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">++</span>(<span style="color:#458;font-weight:bold">int</span>);  <span style="color:#998;font-style:italic">// postfix
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Digit<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">--</span>(<span style="color:#458;font-weight:bold">int</span>);  <span style="color:#998;font-style:italic">// postfix
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Digit<span style="font-weight:bold">&amp;</span> Digit<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">++</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (m_digit <span style="font-weight:bold">==</span> <span style="color:#099">9</span>)
</span></span><span style="display:flex;"><span>        m_digit <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">++</span>m_digit;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Digit<span style="font-weight:bold">&amp;</span> Digit<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">--</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (m_digit <span style="font-weight:bold">==</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        m_digit <span style="font-weight:bold">=</span> <span style="color:#099">9</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span> 
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">--</span>m_digit;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Digit<span style="font-weight:bold">&amp;</span> Digit<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">++</span>(<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    Digit temp{<span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">++</span>(<span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Digit<span style="font-weight:bold">&amp;</span> Digit<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">--</span>(<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    Digit temp{<span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">--</span>(<span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice how we differentiate the prefix and postfix versions with the parameter <code>int</code>: when there&rsquo;s an <code>int</code> parameter, C++ will deem the function to be a postfix instead of prefix.</p>
<h2 id="overloading-the-subscript-operator">Overloading the subscript operator</h2>
<p>We can overload the subscript operator <code>[]</code> in C++ to allow intuitive access to elements in the private member list:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">IntList</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_list[<span style="color:#099">10</span>]{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span>[] (<span style="color:#458;font-weight:bold">int</span> index) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_list[index];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    IntList list{};
</span></span><span style="display:flex;"><span>    list[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> list[<span style="color:#099">2</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice <code>operator[]</code> need to return by (const, if needed) reference cuz otherwise when we run <code>list[2] = 3</code>, we are essentially evaluating <code>6 = 3</code> and will cause a compile error. When we need functionality for const list subscription, we can define a const version of the overload.</p>
<p>When we need to implement the logics for both const and non-const versions of the overload function, what we can do to save the amount of duplicate coding is to put majority of the function body into another function that gets called by both versions.</p>
<p>In C++23, we have an even simpler solution utilizing several new features:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">IntList</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_list{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;&amp;</span> <span style="font-weight:bold">operator</span>[](<span style="font-weight:bold">this</span> <span style="font-weight:bold">auto</span><span style="font-weight:bold">&amp;&amp;</span> self, <span style="color:#458;font-weight:bold">int</span> index) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> self.m_list[index];
</span></span><span style="display:flex;"><span>    }  <span style="color:#998;font-style:italic">// &amp;&amp; and self to differentiate const vs non-const
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    IntList list{};
</span></span><span style="display:flex;"><span>    list[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;    <span style="color:#998;font-style:italic">// ok 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">const</span> IntList clist{};
</span></span><span style="display:flex;"><span>    clist[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;   <span style="color:#998;font-style:italic">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> clist[<span style="color:#099">2</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that we don&rsquo;t mix pointers and overloaded subscriptions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IntList<span style="font-weight:bold">*</span> list { <span style="font-weight:bold">new</span> IntList{} };
</span></span><span style="display:flex;"><span>list[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;   <span style="color:#998;font-style:italic">// compile error
</span></span></span></code></pre></div><h2 id="overloading-the-parenthesis-operator">Overloading the parenthesis operator</h2>
<p>The parenthesis operator must be implemented as a member function. Taking the following as an example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Matrix</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> data[<span style="color:#099">4</span>][<span style="color:#099">4</span>]{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> row, <span style="color:#458;font-weight:bold">int</span> col);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> row, <span style="color:#458;font-weight:bold">int</span> col) <span style="font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&amp;</span> Matrix<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> row, <span style="color:#458;font-weight:bold">int</span> col) {
</span></span><span style="display:flex;"><span>    assert(row <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> row <span style="font-weight:bold">&lt;</span> <span style="color:#099">4</span>);
</span></span><span style="display:flex;"><span>    assert(col <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> col <span style="font-weight:bold">&lt;</span> <span style="color:#099">4</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m_data[row][col];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> Matrix<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> row, <span style="color:#458;font-weight:bold">int</span> col) <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>    assert(row <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> row <span style="font-weight:bold">&lt;</span> <span style="color:#099">4</span>);
</span></span><span style="display:flex;"><span>    assert(col <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> col <span style="font-weight:bold">&lt;</span> <span style="color:#099">4</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m_data[row][col];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Marix matrix;
</span></span><span style="display:flex;"><span>    matrix(<span style="color:#099">1</span>, <span style="color:#099">2</span>) <span style="font-weight:bold">=</span> <span style="color:#099">4.5</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The reason why we didn&rsquo;t implement something like <code>matrix[1][2]</code> is because the second subscript operator is harder to implement than just using the parenthesis.</p>
<p>The <code>operator()</code> is often overloaded to implement <strong>functors</strong> (also known as <strong>function objects</strong>), which are classes that behave like functions except that they store data in member variables:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Accumulator</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_counter {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> i) { <span style="font-weight:bold">return</span> (m_counter <span style="font-weight:bold">+=</span> i); }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">reset</span>() { m_counter <span style="font-weight:bold">=</span> <span style="color:#099">0</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Accumulator acc{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> acc(<span style="color:#099">1</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// prints 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> acc(<span style="color:#099">3</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;    <span style="color:#998;font-style:italic">// prints 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Accumulator acc2{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> acc2(<span style="color:#099">10</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 10
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> acc2(<span style="color:#099">20</span>) <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints 30
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="overloading-typecasts">Overloading typecasts</h2>
<p>C++ inherently converts an <code>int</code> variable into a <code>Cents</code> object as shown above, we can also &ldquo;explicitly&rdquo; define the behavior of typecasting from a <code>Cents</code> into an <code>int</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Cents</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_cents {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Cents (<span style="color:#458;font-weight:bold">int</span> cents <span style="font-weight:bold">=</span> <span style="color:#099">0</span>) <span style="font-weight:bold">:</span> m_cents {cents} {};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_cents;}
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>Note we used the word &ldquo;explicit&rdquo; in quotes above, because the behavior we defined would guide C++ how to implicitly convert a <code>Cents</code> object into an <code>int</code>. We can also force users to actually &ldquo;explicitly&rdquo; perform this typecast:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">explicit</span> <span style="font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>() <span style="font-weight:bold">const</span> {<span style="font-weight:bold">return</span> m_cents; }
</span></span></code></pre></div><p>and by specifying <code>explicit</code> like this, users can only convert using <code>static_cast&lt;int&gt;(cents)</code> if needed.</p>
<h2 id="overloading-the-assignment-operator">Overloading the assignment operator</h2>
<p>The purpose of the copy constructor and the copy assignment operator are almost equivalent &ndash; both copy one object to another. However, the copy constructor initialiezs new objects, whereas the assignment operator replaces the contents of existing objects. In sum:</p>
<ul>
<li>If a new object is to be created before copying, the copy constructor is used</li>
<li>If a new object doesn&rsquo;t have to be created before copying, the assignment operator is used</li>
</ul>
<p>We can overload the assignment operator as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Cents<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> cents);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Cents<span style="font-weight:bold">&amp;</span> Cents<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> cents) {
</span></span><span style="display:flex;"><span>    m_cents <span style="font-weight:bold">=</span> cents.m_cents;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For simple cases, this implementation works. For cases where dynamic memory allocation is expected, we might want to handle self-assignment explicitly. Say we have a custom <code>MyString</code> class that does dynamic memory allocation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>MyString<span style="font-weight:bold">&amp;</span> MyString<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> MyString<span style="font-weight:bold">&amp;</span> str) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">this</span> <span style="font-weight:bold">==</span> <span style="font-weight:bold">&amp;</span>str)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;  <span style="color:#998;font-style:italic">// important: avoid self-assignment
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">if</span> (m_data)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_data;  <span style="color:#998;font-style:italic">// important: delete existing variable and free its memory 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    m_length <span style="font-weight:bold">=</span> str.m_length;
</span></span><span style="display:flex;"><span>    m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (m_length) 
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">char</span>[<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>size_t<span style="font-weight:bold">&gt;</span>(str.m_length)];
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>copy_n(str.m_data, m_length, m_data);  <span style="color:#998;font-style:italic">// copy m_length of str.m_data into m_data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler provides an implicit copy assignment operator by default and you can optionally avoid this behavior by making it <code>private</code> or using the <code>delete</code> keyword:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Cents<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> Cents<span style="font-weight:bold">&amp;</span> cents) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span></code></pre></div><h2 id="shallow-vs-deep-copying">Shallow vs deep copying</h2>
<p>Because C++ doesn&rsquo;t know much about your class, the default copy constructor and default assignment operator use a copying method known as memberwise copy (also known as <strong>shallow copy</strong>). This means C++ copies each member of the class individually (using the assignment operator for overloaded <code>operator=</code>; using direct initialization for the copy constructor).</p>
<p>This works until it doesn&rsquo;t &ndash; when designing classes that handle dynamically allocated memory, memberwise/shallow copying can get us in a lot of troubles. This is because shallow copies of a pointer is just a copy of the pointer itself without actually allocating any memory or copying the content.</p>
<p>We can solve this by doing a <strong>deep copy</strong>, which allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> MyString<span style="font-weight:bold">::</span>deep_copy(<span style="font-weight:bold">const</span> MyString<span style="font-weight:bold">&amp;</span> str) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">delete</span>[] m_data;  <span style="color:#998;font-style:italic">// delete existing variable and free its memory 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    m_length <span style="font-weight:bold">=</span> str.m_length;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (str.m_data) {
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">char</span>[m_length];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i{}; i <span style="font-weight:bold">&lt;</span> m_length; <span style="font-weight:bold">++</span>i)
</span></span><span style="display:flex;"><span>            m_data[i] <span style="font-weight:bold">=</span> str.m_data[i];
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyString<span style="font-weight:bold">::</span>MyString(<span style="font-weight:bold">const</span> MyString<span style="font-weight:bold">&amp;</span> str) {
</span></span><span style="display:flex;"><span>    deep_copy(str);
</span></span><span style="display:flex;"><span>}  <span style="color:#998;font-style:italic">// copy constructor 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>MyString<span style="font-weight:bold">&amp;</span> MyString<span style="font-weight:bold">::</span><span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> MyString<span style="font-weight:bold">&amp;</span> str) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">this</span> <span style="font-weight:bold">!=</span> <span style="font-weight:bold">&amp;</span>source)
</span></span><span style="display:flex;"><span>        deep_copy(str);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}  <span style="color:#998;font-style:italic">// copy assignment operator
</span></span></span></code></pre></div><p>This is exactly the reason why we have <strong>the rule of three</strong>, namely whenever you need to define a destructor, a copy constructor or a copy assignment operator, you will eventually realize that you need to define all three of them, since very likely you&rsquo;re handling dynamic memory allocation.</p>
<h1 id="move-semantics-and-smart-pointers">Move Semantics and Smart Pointers</h1>
<h2 id="introduction-to-smart-pointers-and-move-semantics">Introduction to smart pointers and move semantics</h2>
<p>There are a myriad of ways where a pointer gets allocated but not properly deleted/deallocated, say we return early or throw an exception before deleting a pointer. To avoid this kind of situation for good, there we have <strong>smart pointers</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">AutoPtr</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">*</span> m_ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    AutoPtr(T<span style="font-weight:bold">*</span> ptr<span style="font-weight:bold">=</span><span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">:</span> m_ptr(ptr) {};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>AutoPtr() { <span style="font-weight:bold">delete</span> m_ptr; }
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">*</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span>m_ptr; }
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">*</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">-&gt;</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_ptr; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Resource</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Resource() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Resource constructed</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>Resource() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Resource destructed</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    AutoPtr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> res(<span style="font-weight:bold">new</span> Resource());
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program prints</p>
<pre tabindex="0"><code>Resource constructed 
Resource destructed 
</code></pre><p>As long as the <code>AutoPtr</code> is defined locally, it will be properly deleting the internal pointer and memory. Relatively, the default built-in pointers are sometimes called &ldquo;dumb pointers&rdquo; because they can&rsquo;t clean up after themselves.</p>
<p>One problem of the above implementation is that it has no properly defined copy constructor and copy assignment operator. That means when we pass an <code>AutoPtr</code> to another <code>AutoPtr</code> in copy construction, the original pointer would be deleted without notice:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AutoPtr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> ptr1(<span style="font-weight:bold">new</span> Resource());
</span></span><span style="display:flex;"><span>AutoPtr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> ptr2(ptr1);
</span></span></code></pre></div><p>We will see one constructed notice and two destructed notices &ndash; on the same resource object. To fix this problem, we can define explicity the copy constructor and copy assignment operator to both use references and thereby avoid the copies altogether, but how about returning an <code>AutoPtr</code> from a function?</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">???</span> get_auto_ptr() {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> AutoPtr(res);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We cannot return by copy as it will trigger the same problem as in the copy constructor (multiple pointers to the same resource and destructing the same memory multiple times), neither can we return by reference because the <code>AutoPtr</code> object will be destructred once leaving the local function scope and the user will be left with a dangling reference, same reason for not returning by a pointer to <code>AutoPtr</code>.</p>
<p>This is why we need the <strong>move semantics</strong>, which is basically transfering the ownership between objects rather than making copies:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AutoPtr(AutoPtr<span style="font-weight:bold">&amp;</span> ap) {
</span></span><span style="display:flex;"><span>    m_ptr <span style="font-weight:bold">=</span> ap.m_ptr;
</span></span><span style="display:flex;"><span>    ap.m_ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AutoPtr<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(AutoPtr<span style="font-weight:bold">&amp;</span> ap) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">&amp;</span>ap <span style="font-weight:bold">!=</span> <span style="font-weight:bold">this</span>) { <span style="color:#998;font-style:italic">// avoid self assignment 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">delete</span> m_ptr;
</span></span><span style="display:flex;"><span>        m_ptr <span style="font-weight:bold">=</span> ap.m_ptr;
</span></span><span style="display:flex;"><span>        ap.m_ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In C++98 there introduced <code>std::auto_ptr</code> which was later removed in C++17 for a few reasons:</p>
<ul>
<li>It implements move semantics through the copy constructor and assignment operator (like above), so when you pass it by value to a function, the original pointer loses its ownership automatically and you might deference a null pointer by accident.</li>
<li>It always deletes its contents using non-array destructors and thus won&rsquo;t work properly with dynamically allocated objects</li>
<li>It doesn&rsquo;t work well with a lot of other classes in STL including most of the containers and algorithms, because those STL classes assumes copy instead move when we explicitly copy an object.</li>
</ul>
<p>We should use <code>std::unique_ptr</code> and <code>std::shared_ptr</code> moving forward, which are introduced in C++11.</p>
<h2 id="r-value-references">R-value references</h2>
<p>Let&rsquo;s go over some recap on the value categories. Prior to C++11, only one type of reference existed in C++, and so it was just called a <strong>reference</strong>. Starting from C++11, it is instead called l-value reference which can only be initialized with modifiable l-values:</p>
<table>
<thead>
<tr>
<th>l-value reference</th>
<th>can be initialized with</th>
<th>can modify</th>
</tr>
</thead>
<tbody>
<tr>
<td>modifiable l-values</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>non-modifiable l-values</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>r-values</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>L-value references to const objects can be initialized with modifiable and non-modifiable l-values and r-values alike. However, those values can&rsquo;t be modified:</p>
<table>
<thead>
<tr>
<th>l-value reference to const</th>
<th>can be initialized with</th>
<th>can modify</th>
</tr>
</thead>
<tbody>
<tr>
<td>modifiable l-values</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>non-modifiable l-values</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>r-values</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>C++11 adds a new type of reference called an r-value reference. An r-value reference is a reference that is designed to be initialized with an r-value (only). While an l-value reference is created using a single ampersand, an r-value reference is created using a double ampersand:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};       <span style="color:#998;font-style:italic">// l-value 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> lref{x};   <span style="color:#998;font-style:italic">// l-value ref on a l-value 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;&amp;</span> rref{<span style="color:#099">5</span>};  <span style="color:#998;font-style:italic">// r-value ref on an r-value 
</span></span></span></code></pre></div><p><strong>R-value references cannot be initialized with l-values</strong>.</p>
<table>
<thead>
<tr>
<th>r-value reference</th>
<th>can be initialized with</th>
<th>can modify</th>
</tr>
</thead>
<tbody>
<tr>
<td>modifable l-values</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>non-modifiable l-values</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>r-values</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>And for r-value reference to const:</p>
<table>
<thead>
<tr>
<th>r-value reference to const</th>
<th>can be initialized with</th>
<th>can modify</th>
</tr>
</thead>
<tbody>
<tr>
<td>modifiable l-values</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>non-modifiable l-values</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>r-values</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>These r-value references have two properties that are quite useful:</p>
<ul>
<li>They extend the lifespan of the object they are initialized with to the lifespan of the r-value reference (though l-value references to const objects can achieve this as well)</li>
<li>Non-const r-value references allow you to modify the r-values!</li>
</ul>
<p>When we want to differentiate the behavior of an l-value vs r-value parameter of a function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">fun</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> lref) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">fun</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;&amp;</span> rref) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// do something 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    fun(x);      <span style="color:#998;font-style:italic">// x passed as lref  
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    fun(<span style="color:#099">5</span>);      <span style="color:#998;font-style:italic">// 5 passed as rref
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="move-constructors-and-move-assignments">Move constructors and move assignments</h2>
<p>We can define move constructor and move assignment like below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// not const cuz we need to move the ownership from the original ptr to current
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>AutoPtr(AutoPtr<span style="font-weight:bold">&amp;&amp;</span> a) <span style="font-weight:bold">noexcept</span> <span style="font-weight:bold">:</span> m_ptr(a.m_ptr) { a.m_ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>; }
</span></span><span style="display:flex;"><span>AutoPtr<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(AutoPtr<span style="font-weight:bold">&amp;&amp;</span> a) <span style="font-weight:bold">noexcept</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">&amp;</span>a <span style="font-weight:bold">!=</span> <span style="font-weight:bold">this</span>) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span> m_ptr;
</span></span><span style="display:flex;"><span>        m_ptr <span style="font-weight:bold">=</span> a.m_ptr;
</span></span><span style="display:flex;"><span>        a.m_ptr <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler will create an implicit move constructor and move assignment operator if all of the following are true:</p>
<ul>
<li>There are no user-declared copy constructors or copy assignment operators.</li>
<li>There are no user-declared move constructors or move assignment operators.</li>
<li>There is no user-declared destructor.</li>
</ul>
<p>For the above reasons we&rsquo;re better off to delete the definitions of default copy constructor and assignment operator using <code>=delete</code>. Also it&rsquo;s worth noting that the compiler will not generate an implicit move constructor when we delete the copy constructor, and thus it&rsquo;s better to be very explicit what behavior we need from the compiler about the move constructor and move assignment operators, using either <code>=delete</code> or <code>=default</code> (or our own definition).</p>
<h2 id="stdmove"><code>std::move</code></h2>
<p>There are cases where we want to invoke the move semantics but the compiler does copying for us because the object is an l-value instead of r-value, and thus the double ampersand r-value reference isn&rsquo;t matched. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span><span style="font-weight:bold">&lt;</span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">T</span><span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> my_swap_function(T<span style="font-weight:bold">&amp;</span> a, T<span style="font-weight:bold">&amp;</span> b) {
</span></span><span style="display:flex;"><span>    T tmp{a};
</span></span><span style="display:flex;"><span>    a <span style="font-weight:bold">=</span> b;
</span></span><span style="display:flex;"><span>    b <span style="font-weight:bold">=</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string x{<span style="color:#b84">&#34;abc&#34;</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string y{<span style="color:#b84">&#34;de&#34;</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;x: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;y: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    my_swap_function(x, y);
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;x: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;y: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> y <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>x: abc 
y: de 
x: de 
y: abc
</code></pre><p>So this program works as expected except that a bunch of copies are made. Apparently it isn&rsquo;t necessary now that we know about move semantics. The problem is that both <code>a</code> and <code>b</code> are l-values and thus we cannot explicitly invoke move instead of copy. To solve this problem, we have <code>std::move</code> from <code>&lt;utility&gt;</code> library:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;utility&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">T</span><span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> my_swap_function(T<span style="font-weight:bold">&amp;</span>a, T<span style="font-weight:bold">&amp;</span>b) {
</span></span><span style="display:flex;"><span>    T tmp{ std<span style="font-weight:bold">::</span>move(a) };
</span></span><span style="display:flex;"><span>    a <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>move(b);
</span></span><span style="display:flex;"><span>    b <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>move(tmp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// same as previous program 
</span></span></span></code></pre></div><p>Instead of making a copy of <code>a</code>, <code>b</code> and <code>tmp</code>, we use <code>std::move</code> to convert l-value variables into r-values, and since the parameter is an r-value, the move semantics are invoked to avoid expensive copying.</p>
<p>Another example when filling elements of a container:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;utility&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// for std::move
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&gt;</span> v;
</span></span><span style="display:flex;"><span> <span style="color:#998;font-style:italic">// We use std::string because it is movable (std::string_view is not)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> std<span style="font-weight:bold">::</span>string str { <span style="color:#b84">&#34;Knock&#34;</span> };
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Copying str</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span> v.push_back(str); <span style="color:#998;font-style:italic">// calls l-value version of push_back, which copies str into the array element
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;str: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> str <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;vector: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> v[<span style="color:#099">0</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;</span><span style="color:#b84">\n</span><span style="color:#b84">Moving str</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span> v.push_back(std<span style="font-weight:bold">::</span>move(str)); <span style="color:#998;font-style:italic">// calls r-value version of push_back, which moves str into the array element
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;str: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> str <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// The result of this is indeterminate
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;vector:&#34;</span> <span style="font-weight:bold">&lt;&lt;</span> v[<span style="color:#099">0</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> v[<span style="color:#099">1</span>] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program prints:</p>
<pre tabindex="0"><code>Copying str
str: Knock
vector: Knock

Moving str
str:
vector: Knock Knock
</code></pre><p><code>std::move</code> is also useful when sorting an array of elements and moving contents managed by one smart pointer to another.</p>
<h2 id="stdunique_ptr"><code>std::unique_ptr</code></h2>
<p>C++11 standard library ships with 4 smart pointer classes: <code>std::auto_ptr</code> (removed in C++17 for reason mentioned before), <code>std::unique_ptr</code>, <code>std::shared_ptr</code> and <code>std::weak_ptr</code>. Among these, <code>std::unique_ptr</code> is by far the most commonly used smart pointer class and we&rsquo;ll cover that one in this section.</p>
<p><code>std::unique_ptr</code> (provided in <code>&lt;memory&gt;</code>) can be seen as a replacement for <code>std::auto_ptr</code>. It should be used to manage any dynamically allocated object that is not shared by multiple objects. That is, it can and should completely own the object it manages and cannot share the ownership with other classes.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;memory&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Resource</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Resource() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Acquired</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>Resource() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Destroyed</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>unique_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> res{ <span style="font-weight:bold">new</span> Resource() };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program prints</p>
<pre tabindex="0"><code>Acquired 
Destroyed 
</code></pre><p>Since <code>std::unique_ptr</code>, just like other smart pointers, is allocated on the stack here, whenever it exits its scope, it properly destroys the resource it&rsquo;s managing. Better than <code>std::auto_ptr</code>, it also implements move semantics by default:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// same definition of Resource 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>unique_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> res1 { <span style="font-weight:bold">new</span> Resource() };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>unique_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> res2 {};  <span style="color:#998;font-style:italic">// initialized as nullptr 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;res1 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> (res1 <span style="font-weight:bold">?</span> <span style="color:#b84">&#34;not null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span> <span style="font-weight:bold">:</span> <span style="color:#b84">&#34;null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>);
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;res2 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> (res2 <span style="font-weight:bold">?</span> <span style="color:#b84">&#34;not null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span> <span style="font-weight:bold">:</span> <span style="color:#b84">&#34;null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// res2 = res1;         // Won&#39;t compile: copy assignment is disabled
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    res2 <span style="font-weight:bold">=</span> std<span style="font-weight:bold">::</span>move(res1); <span style="color:#998;font-style:italic">// res2 assumes ownership, res1 is set to null
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Ownership transferred</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;res1 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> (res1 <span style="font-weight:bold">?</span> <span style="color:#b84">&#34;not null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span> <span style="font-weight:bold">:</span> <span style="color:#b84">&#34;null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>);
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;res2 is &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> (res2 <span style="font-weight:bold">?</span> <span style="color:#b84">&#34;not null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span> <span style="font-weight:bold">:</span> <span style="color:#b84">&#34;null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above prints</p>
<pre tabindex="0"><code>Acquired
res1 is not null
res2 is null
Ownership transferred
res1 is null
res2 is not null
Destroyed
</code></pre><p><code>std::unique_ptr</code> has <code>*</code> and <code>-&gt;</code> overloaded, and has a cast to bool that returns true if the pointer is managing a resource:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">if</span> (res) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">*</span>res <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Another improvement from <code>std:auto_ptr</code> is that <code>std::unique_ptr</code> knows when to use scalar vs array delete, and hence it&rsquo;s ok to use <code>std::unique_ptr</code> with array objects. However, it&rsquo;s almost always better to just use <code>std::array</code> or <code>std::vector</code> than using <code>std::unique_ptr</code> with a fixed, dynamic or C-style array.</p>
<p>Additionally, in C++14 we have a new function named <code>std::make_unique</code> which constructs an object of the template type and initialize it with the arguments passed into the function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>unique_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> create_resource() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>make_unique<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>std::make_unique</code> distinguishes <code>T</code> from <code>T[]</code> and <code>T[N]</code>, and avoids the using of <code>new</code> altogether, so it&rsquo;s pretty much always preferred than <code>std::unique_ptr</code> explicitly. Also, it&rsquo;s just more succinct:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>f(std<span style="font-weight:bold">::</span>unique_ptr<span style="font-weight:bold">&lt;</span>MyClass<span style="font-weight:bold">&gt;</span>(<span style="font-weight:bold">new</span> MyClass(param)), g());
</span></span><span style="display:flex;"><span>f(std<span style="font-weight:bold">::</span>make_unique<span style="font-weight:bold">&lt;</span>MyClass<span style="font-weight:bold">&gt;</span>(param), g());
</span></span></code></pre></div><p>Notice we <em>don&rsquo;t</em> return <code>std::unique_ptr</code> by pointer or reference in most cases. Also, don&rsquo;t let multiple <code>std::unique_ptr</code> manager the same resource (apparently). Don&rsquo;t delete the resourse for your <code>std::unique_ptr</code>.</p>
<h2 id="stdshared_ptr"><code>std::shared_ptr</code></h2>
<p>Unlike <code>std::unique_ptr</code>, which is designed to singly own and manage a resource, <code>std::shared_ptr</code> is meant to solve the case where you need multiple smart pointers co-owning a resource. <code>std::shared_ptr</code> keeps track of how many of them are sharing ownership on the same resource and won&rsquo;t deallocate the memory until the last <code>std::shared_ptr</code> goes out of scope.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// assuming same definition of Resource 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Resource<span style="font-weight:bold">*</span> res{ <span style="font-weight:bold">new</span> Resource };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> ptr1{ res };
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> ptr2{ ptr1 };  <span style="color:#998;font-style:italic">// share ownership from ptr1 to ptr2 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Killing one shared pointer</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Killing another shared pointer</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This prints:</p>
<pre tabindex="0"><code>Acquired 
Killing one shared pointer  
Killing another shared pointer 
Destroyed 
</code></pre><p>Notice we&rsquo;re sharing the ownership using a copy constructor instead of below</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Resource<span style="font-weight:bold">*</span> res{ <span style="font-weight:bold">new</span> Resource };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> ptr1{ res };
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> ptr2{ res };  <span style="color:#998;font-style:italic">// set ownership independently 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Killing one shared pointer</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Killing another shared pointer</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>Acquired 
Killing one shared pointer  
Destroyed 
Killing another shared pointer 
Destroyed 
</code></pre><p>and the program will crash after the second <code>Destroyed</code>, as the same resource has now been deallocated twice.</p>
<p>Similar to <code>std::make_unique</code>, we have <code>std::make_shared</code> for more succinct coding:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr1 { std<span style="font-weight:bold">::</span>make_shared<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span>() };
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">auto</span> ptr2 { ptr1 };
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Killing one pointer</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Killing another pointer</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Simpler, and more importantly safer, as there&rsquo;s now no way to independently create <code>ptr2</code> based on <code>res</code>.</p>
<p>It&rsquo;s worth knowing that a <code>std::unique_ptr</code> can be converted to a <code>std::shared_ptr</code> using a special constructor but not vice versa.</p>
<h2 id="stdweak_ptr"><code>std::weak_ptr</code></h2>
<p>Check the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;memory&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Person</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;</span> m_partner{};  <span style="color:#998;font-style:italic">// default to nullptr 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Person(<span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> name) <span style="font-weight:bold">:</span> m_name(name) { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is born</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>Person() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is dead</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">marry</span>(std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;&amp;</span> p1, std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;&amp;</span> p2) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>p1 <span style="font-weight:bold">||</span> <span style="font-weight:bold">!</span>p2) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="color:#999">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        p1<span style="font-weight:bold">-&gt;</span>m_partner <span style="font-weight:bold">=</span> p2;
</span></span><span style="display:flex;"><span>        p2<span style="font-weight:bold">-&gt;</span>m_partner <span style="font-weight:bold">=</span> p1;
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> p1<span style="font-weight:bold">-&gt;</span>m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; marries &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> p2<span style="font-weight:bold">-&gt;</span>m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#999">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> allen { std<span style="font-weight:bold">::</span>make_shared<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;</span>(<span style="color:#b84">&#34;Allen&#34;</span>) };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> christine { std<span style="font-weight:bold">::</span>make_shared<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;</span>(<span style="color:#b84">&#34;Christine&#34;</span>) };
</span></span><span style="display:flex;"><span>    marry(allen, christine);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program will print</p>
<pre tabindex="0"><code>Allen is born
Christine is born 
Allen marries Christine 
</code></pre><p>But that&rsquo;s it! No follow-up deallocations will happen because when the destructor tries to destroy <code>allen-&gt;m_partner</code>, it realizes that <code>chris</code> is still owning the underlying resource and thus skips. Same happens when <code>chris-&gt;m_partner</code> skips to deallocate the memory for the resource co-owned by <code>allen</code>. As a result, this circular reference causes buggy deallocation despite the using of <code>std::shared_ptr</code>.</p>
<p><code>std::weak_ptr</code> was designed to solve this problem and the only thing we need to change was to declare the <code>m_partner</code> member variable as a <code>std::weak_ptr</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>weak_ptr<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;</span> m_partner{};  <span style="color:#998;font-style:italic">// default to nullptr 
</span></span></span></code></pre></div><p>and the same program will now print</p>
<pre tabindex="0"><code>Allen is born
Christine is born
Allen marries Christine
Christine is dead
Allen is dead
</code></pre><p>One drawback of <code>std::weak_ptr</code> is that it&rsquo;s just an observer and has no <code>-&gt;</code> overload. In order to access its resource, we need to convert a <code>std::weak_ptr</code> into a <code>std::shared_ptr</code> using <code>lock</code> member function. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>shared_ptr<span style="font-weight:bold">&lt;</span>Person<span style="font-weight:bold">&gt;</span> get_partner() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m_partner.lock();  <span style="color:#998;font-style:italic">// otherwise it&#39;s not a shared_ptr
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>Unlike <code>std::shared_ptr</code> which will keep the underlying resource alive, a <code>std::weak_ptr</code> won&rsquo;t and might become a dangling pointer. Luckily, it still got something that&rsquo;s better than a dumb pointer, namely the boolean <code>expire</code> member function which tells whether the reference count to an object has become zero:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>weak_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span> getWeakPtr() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr{ std<span style="font-weight:bold">::</span>make_shared<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span>() };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>weak_ptr<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span>{ ptr };
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// ptr goes out of scope, Resource destroyed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>Resource<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">getDumbPtr</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> ptr{ std<span style="font-weight:bold">::</span>make_unique<span style="font-weight:bold">&lt;</span>Resource<span style="font-weight:bold">&gt;</span>() };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> ptr.get();
</span></span><span style="display:flex;"><span>} <span style="color:#998;font-style:italic">// ptr goes out of scope, Resource destroyed
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> dumb{ getDumbPtr() };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Our dumb ptr is: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ((dumb <span style="font-weight:bold">==</span> <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">?</span> <span style="color:#b84">&#34;nullptr</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span> <span style="font-weight:bold">:</span> <span style="color:#b84">&#34;non-null</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">auto</span> weak{ getWeakPtr() };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Our weak ptr is: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ((weak.expired()) <span style="font-weight:bold">?</span> <span style="color:#b84">&#34;expired</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span> <span style="font-weight:bold">:</span> <span style="color:#b84">&#34;valid</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and it prints</p>
<pre tabindex="0"><code>Resource acquired
Resource destroyed
Our dumb ptr is: non-null
Resource acquired
Resource destroyed
Our weak ptr is: expired
</code></pre><h1 id="object-relationships">Object Relationships</h1>
<h2 id="composition-and-aggregation">Composition and Aggregation</h2>
<p>The process of building complex objects from simpler ones is called <strong>composition</strong>. There are two basic subtypes of object composition: composition and aggregation.</p>
<p>To qualify a composition, an object and a part must have the following relationship:</p>
<ul>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can only belong to one object (class) at a time *</li>
<li>The part (member) has its existence managed by the object (class) *</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ul>
<p>A real-world example of composition would be the relationship between a person&rsquo;s body and a heart.</p>
<p>An aggregation must satisfy the following relationships:</p>
<ul>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can (if desired) belong to more than one object (class) at a time *</li>
<li>The part (member) does not have its existence managed by the object (class) *</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ul>
<p>A good example would be a person versus their address. Since multiple people can share the same address without the address being managed by the homeowners/leasers, it&rsquo;s an aggregation.</p>
<p>A further summary:</p>
<p>Compositions:</p>
<ul>
<li>Typically use normal member variables</li>
<li>Can use pointer members if the class handles object allocation/deallocated itself</li>
<li>Responsible for creation/destruction of parts</li>
</ul>
<p>Aggregations:</p>
<ul>
<li>Typically use pointer or reference members that point to or reference objects that live outside the scope of the aggregation class</li>
<li>Not responsible for creating/destroying parts</li>
</ul>
<p>Notice that we cannot initialize a list/array of references (because list elements must be assignable while references can&rsquo;t)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span><span style="font-weight:bold">const</span> Teacher<span style="font-weight:bold">&amp;&gt;</span> m_teachers{};  <span style="color:#998;font-style:italic">// illegal
</span></span></span></code></pre></div><p>What we can do is to use <code>std::reference_wrapper</code> provided in the <code>&lt;functional&gt;</code> header which has a <code>get</code> member function to unwrap and get the underlying reference:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;functional&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string tom{<span style="color:#b84">&#34;Tom&#34;</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string berta{<span style="color:#b84">&#34;Berta&#34;</span>};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>reference_wrapper<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&gt;&gt;</span> names {tom, berta};  <span style="color:#998;font-style:italic">// list of refs 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string jim{<span style="color:#b84">&#34;Jim&#34;</span>};
</span></span><span style="display:flex;"><span>    names.emplace_back(jim);  <span style="color:#998;font-style:italic">// convert to ref wrapper and push to the end 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> name: names) {
</span></span><span style="display:flex;"><span>        name.get() <span style="font-weight:bold">+=</span> <span style="color:#b84">&#34; Beam&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> jim <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// prints Jim Beam 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="association">Association</h2>
<p>To qualify an association, an object and another object must have the following relationship:</p>
<ul>
<li>The associated object (member) is otherwise unrelated to the object (class)</li>
<li>The associated object (member) can belong to more than one object (class) at a time</li>
<li>The associated object (member) does not have its existence managed by the object (class)</li>
<li>The associated object (member) may or may not know about the existence of the object (class)</li>
</ul>
<p>The relationship between doctors and patients is a great example of an association. The doctor clearly has a relationship with his patients, but conceptually it&rsquo;s not a part/whole relationship and thus is not considered object composition. A doctor can see multiple patients and vice versa. There is naturally a circular dependency here and we need to take care how we implement this kind of relationships:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;functional&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;vector&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Patient</span>;  <span style="color:#998;font-style:italic">// forward declaration
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Doctor</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>reference_wrapper<span style="font-weight:bold">&lt;</span><span style="font-weight:bold">const</span> Patient<span style="font-weight:bold">&gt;&gt;</span> m_patients{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">explicit</span> Doctor(std<span style="font-weight:bold">::</span>string_view name) <span style="font-weight:bold">:</span> m_name(name) {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">add_patient</span>(Patient<span style="font-weight:bold">&amp;</span> patient);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Doctor<span style="font-weight:bold">&amp;</span> doctor);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008080">[[nodiscard]]</span> <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_name() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Patient</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>vector<span style="font-weight:bold">&lt;</span>std<span style="font-weight:bold">::</span>reference_wrapper<span style="font-weight:bold">&lt;</span><span style="font-weight:bold">const</span> Doctor<span style="font-weight:bold">&gt;&gt;</span> m_doctors{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">add_doctor</span>(<span style="font-weight:bold">const</span> Doctor<span style="font-weight:bold">&amp;</span> doctor) {
</span></span><span style="display:flex;"><span>        m_doctors.emplace_back(doctor);
</span></span><span style="display:flex;"><span>    }  <span style="color:#998;font-style:italic">// this needs to be private because we always prefer Doctor.add_patient
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">explicit</span> Patient(std<span style="font-weight:bold">::</span>string_view name) <span style="font-weight:bold">:</span> m_name(name) {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Patient<span style="font-weight:bold">&amp;</span> patient);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008080">[[nodiscard]]</span> <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_name() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> <span style="color:#458;font-weight:bold">void</span> Doctor<span style="font-weight:bold">::</span>add_patient(Patient<span style="font-weight:bold">&amp;</span> patient);  <span style="color:#998;font-style:italic">// so that it can access Patient.add_doctor
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> Doctor<span style="font-weight:bold">::</span>add_patient(Patient<span style="font-weight:bold">&amp;</span> patient) {
</span></span><span style="display:flex;"><span>    m_patients.emplace_back(patient);
</span></span><span style="display:flex;"><span>    patient.add_doctor(<span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Doctor<span style="font-weight:bold">&amp;</span> doctor) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (doctor.m_patients.empty()) {
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> doctor.m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; has no patients right now</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> os;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    os <span style="font-weight:bold">&lt;&lt;</span> doctor.m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is seeing these patients:</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> patient : doctor.m_patients) {
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;- &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> patient.get().get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> os;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Patient<span style="font-weight:bold">&amp;</span> patient) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (patient.m_doctors.empty()) {
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> patient.m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; has no doctors right now</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> os;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    os <span style="font-weight:bold">&lt;&lt;</span> patient.m_name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; is seeing these doctors:</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="font-weight:bold">const</span> <span style="font-weight:bold">auto</span> doctor : patient.m_doctors) {
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;- &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> doctor.get().get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> os;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Patient dave{<span style="color:#b84">&#34;Dave&#34;</span>};
</span></span><span style="display:flex;"><span>    Patient frank{<span style="color:#b84">&#34;Frank&#34;</span>};
</span></span><span style="display:flex;"><span>    Patient betsy{<span style="color:#b84">&#34;Besty&#34;</span>};
</span></span><span style="display:flex;"><span>    Doctor james{<span style="color:#b84">&#34;James&#34;</span>};
</span></span><span style="display:flex;"><span>    Doctor scott{<span style="color:#b84">&#34;Scott&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    james.add_patient(dave);
</span></span><span style="display:flex;"><span>    james.add_patient(frank);
</span></span><span style="display:flex;"><span>    scott.add_patient(betsy);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> james <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> scott <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Below is a summary table of the three kinds of relationships we&rsquo;ve talked about by far:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Composition</th>
<th>Aggregation</th>
<th>Association</th>
</tr>
</thead>
<tbody>
<tr>
<td>relationship type</td>
<td>whole/part</td>
<td>whole/part</td>
<td>otherwise unrelated</td>
</tr>
<tr>
<td>members can belong to multiple classes</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>members&rsquo; existence managed by class</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>directionality</td>
<td>undirectional</td>
<td>undirectional</td>
<td>undirectional or bidirectional</td>
</tr>
<tr>
<td>relationship verb</td>
<td>part of</td>
<td>has-a</td>
<td>uses-a</td>
</tr>
</tbody>
</table>
<h2 id="dependencies">Dependencies</h2>
<p>A <strong>dependency</strong> occurs when one object invokes another object&rsquo;s functionality in order to accomplish some specific task. This is a weaker relationship than an association, but still, any change to object being depended upon may break functionality in the (dependent) caller. A dependency is always an undirectional relationship.</p>
<p>In C++, associations are a relationship where one class always directly or indirectly &ldquo;links&rdquo; to the associated class as a member, namely one class knows its members. Dependencies, on the other hand, are not memberships and they are typically instantiated as needed only.</p>
<h2 id="container-classes">Container classes</h2>
<p>A <strong>container class</strong> is a class designed to hold and organize multiple instances of another type (either another class, or a fundamental type). There are many different kinds of container classes, each of which has various advantages, disadvantages and restrictions in their use. By far the most commonly used container in programming is the array, which you have already seen in many examples. Although C++ has built-in array functionality, programmers will often use an array container class (<code>std::array</code> or <code>std::vector</code>) instead because of the additional benefits they provide. Unlike built-in arrays, array container classes generally provide dynamic resizing (when elements are added or removed), remember their size when they are passed to functions, and do bounds-checking. This not only mankes array container classes more convenient than normal arrays, but safer too.</p>
<p>Most well-defined containers provide these functionalities:</p>
<ul>
<li>Create an empty container via constructor</li>
<li>Insert a new object into the container</li>
<li>Remove an object from the container</li>
<li>Report the number of objects currently in the container</li>
<li>Empty the container of all objects</li>
<li>Provide access to the stored objects</li>
<li>Sort the elements (optional)</li>
</ul>
<p>Sometimes certain classes omit some of these functionalities: for example, arrays often omit insert and remove functionalities because they are slow and not encouraged. Below is an example of an <code>IntArray</code> container class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// IntArray.h
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#ifndef INTARRAY_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define INTARRAY_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::copy_n
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold">    </span><span style="color:#998;font-style:italic">// for assert()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">IntArray</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_length{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> m_data{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    IntArray() <span style="font-weight:bold">=</span> <span style="font-weight:bold">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IntArray(IntArray<span style="font-weight:bold">&amp;&amp;</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>    IntArray<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(IntArray<span style="font-weight:bold">&amp;&amp;</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">explicit</span> <span style="color:#900;font-weight:bold">IntArray</span>(<span style="color:#458;font-weight:bold">int</span> length) <span style="font-weight:bold">:</span> m_length{length} {
</span></span><span style="display:flex;"><span>        assert(length <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (length <span style="font-weight:bold">&gt;</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>            m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[length]{};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>IntArray() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// we don&#39;t need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// after this function anyway
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IntArray(<span style="font-weight:bold">const</span> IntArray<span style="font-weight:bold">&amp;</span> a) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Set the size of the new array appropriately
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        reallocate(a.get_length());
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>copy_n(a.m_data, m_length, m_data);  <span style="color:#998;font-style:italic">// copy the elements
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IntArray<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> IntArray<span style="font-weight:bold">&amp;</span> a) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Self-assignment check
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> (<span style="font-weight:bold">&amp;</span>a <span style="font-weight:bold">==</span> <span style="font-weight:bold">this</span>) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Set the size of the new array appropriately
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        reallocate(a.get_length());
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>copy_n(a.m_data, m_length, m_data);  <span style="color:#998;font-style:italic">// copy the elements
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">*</span><span style="font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">erase</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// We need to make sure we set m_data to nullptr here, otherwise it will
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// be left pointing at deallocated memory!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        m_length <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span>[](<span style="color:#458;font-weight:bold">int</span> index) {
</span></span><span style="display:flex;"><span>        assert(index <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> index <span style="font-weight:bold">&lt;</span> m_length);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_data[index];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// reallocate resizes the array.  Any existing elements will be destroyed.  This function operates quickly.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">reallocate</span>(<span style="color:#458;font-weight:bold">int</span> newLength) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// First we delete any existing elements
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        erase();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If our array is going to be empty now, return here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> (newLength <span style="font-weight:bold">&lt;=</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Then we have to allocate new elements
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[newLength];
</span></span><span style="display:flex;"><span>        m_length <span style="font-weight:bold">=</span> newLength;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// resize resizes the array.  Any existing elements will be kept.  This function operates slowly.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">resize</span>(<span style="color:#458;font-weight:bold">int</span> newLength) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// if the array is already the right length, we&#39;re done
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> (newLength <span style="font-weight:bold">==</span> m_length) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If we are resizing to an empty array, do that and return
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> (newLength <span style="font-weight:bold">&lt;=</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>            erase();
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Now we can assume newLength is at least 1 element.  This algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// works as follows: First we are going to allocate a new array.  Then we
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// are going to copy elements from the existing array to the new array.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// Once that is done, we can destroy the old array, and make m_data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// point to the new array.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// First we have to allocate a new array
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> data{<span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[newLength]};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Then we have to figure out how many elements to copy from the existing
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// array to the new array.  We want to copy as many elements as there are
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// in the smaller of the two arrays.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> (m_length <span style="font-weight:bold">&gt;</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> elements_to_copy{(newLength <span style="font-weight:bold">&gt;</span> m_length) <span style="font-weight:bold">?</span> m_length : newLength};
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>copy_n(m_data, elements_to_copy, data);  <span style="color:#998;font-style:italic">// copy the elements
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Now we can delete the old array because we don&#39;t need it any more
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// And use the new array instead!  Note that this simply makes m_data point
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// to the same address as the new array we dynamically allocated.  Because
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// data was dynamically allocated, it won&#39;t be destroyed when it goes out of scope.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        m_data <span style="font-weight:bold">=</span> data;
</span></span><span style="display:flex;"><span>        m_length <span style="font-weight:bold">=</span> newLength;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">insert_before</span>(<span style="color:#458;font-weight:bold">int</span> value, <span style="color:#458;font-weight:bold">int</span> index) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Sanity check our index value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        assert(index <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> index <span style="font-weight:bold">&lt;=</span> m_length);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// First create a new array one element larger than the old array
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> data{<span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[m_length <span style="font-weight:bold">+</span> <span style="color:#099">1</span>]};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Copy all of the elements up to the index
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>copy_n(m_data, index, data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Insert our new element into the new array
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        data[index] <span style="font-weight:bold">=</span> value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Copy all of the values after the inserted element
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>copy_n(m_data <span style="font-weight:bold">+</span> index, m_length <span style="font-weight:bold">-</span> index, data <span style="font-weight:bold">+</span> index <span style="font-weight:bold">+</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Finally, delete the old array, and use the new array instead
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> data;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">++</span>m_length;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">remove</span>(<span style="color:#458;font-weight:bold">int</span> index) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Sanity check our index value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        assert(index <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> index <span style="font-weight:bold">&lt;</span> m_length);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If this is the last remaining element in the array, set the array to empty and bail out
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> (m_length <span style="font-weight:bold">==</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>            erase();
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// First create a new array one element smaller than the old array
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> data{<span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[m_length <span style="font-weight:bold">-</span> <span style="color:#099">1</span>]};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Copy all of the elements up to the index
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>copy_n(m_data, index, data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Copy all of the values after the removed element
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>copy_n(m_data <span style="font-weight:bold">+</span> index <span style="font-weight:bold">+</span> <span style="color:#099">1</span>, m_length <span style="font-weight:bold">-</span> index <span style="font-weight:bold">-</span> <span style="color:#099">1</span>, data <span style="font-weight:bold">+</span> index);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Finally, delete the old array, and use the new array instead
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> data;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">--</span>m_length;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// A couple of additional functions just for convenience
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">insert_at_beginning</span>(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        insert_before(value, <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">insert_at_end</span>(<span style="color:#458;font-weight:bold">int</span> value) {
</span></span><span style="display:flex;"><span>        insert_before(value, m_length);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008080">[[nodiscard]]</span> <span style="color:#458;font-weight:bold">int</span> get_length() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_length;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><h2 id="stdinitializer_list"><code>std::initializer_list</code></h2>
<p>We have seen the following examples using initializer lists:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[] { <span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">auto</span><span style="font-weight:bold">*</span> array{<span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[<span style="color:#099">5</span>]{ <span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span> }};
</span></span></code></pre></div><p>However, we cannot use initializer list to instantiate our <code>IntArray</code> out of box:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IntArray array{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>};  <span style="color:#998;font-style:italic">// won&#39;t compile
</span></span></span></code></pre></div><p>and this is because we need to explicitly define a constructor that takes initializer lists:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// for assert 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;initializer_list&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::initializer_list 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// etc 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">IntArray</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// etc 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    IntArray(std<span style="font-weight:bold">::</span>initializer_list<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> list)  <span style="color:#998;font-style:italic">// constructor for initializer list 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">:</span> IntArray(<span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>(list.size())) {  <span style="color:#998;font-style:italic">// delegation constructor 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span> count {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> (<span style="font-weight:bold">auto</span> element : list) {
</span></span><span style="display:flex;"><span>            m_data[count] <span style="font-weight:bold">=</span> element;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">++</span>count;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that list initialization prefers list constructors over non-list constructors:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IntArray <span style="color:#900;font-weight:bold">a1</span>(<span style="color:#099">5</span>);  <span style="color:#998;font-style:italic">// using IntArray(int) and has length 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>IntArray a2{<span style="color:#099">5</span>};  <span style="color:#998;font-style:italic">// using IntArray(std::initializer_list&lt;int&gt;) and has length 1
</span></span></span></code></pre></div><p>For the very reason it&rsquo;s wise to remember that adding a list constructor to an existing class that did not have one may break existing programs, and hence should overall be avoided unless you know what you&rsquo;re doing. In the case we really need to implement/add a constructor that takes a <code>std::initializer_list</code>, we need to ensure that we do at least one of the following:</p>
<ul>
<li>Provide an overloaded list assignment operator</li>
<li>Provide a proper deep-copying copy assignment operator</li>
<li>Delete the copy assignment operator</li>
</ul>
<h1 id="inheritance">Inheritance</h1>
<h2 id="basic-inheritance-in-c">Basic inheritance in C++</h2>
<p>Inheritance in C++ takes place between classes. In an inheritance relationship, the class being inherited from is called the parent class, base class or superclass. The class doing the inheriting is called the child class, derived class or subclass. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Person</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>  <span style="color:#998;font-style:italic">// making our members public just in this example 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string m_name{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_age{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Person(std<span style="font-weight:bold">::</span>string_view name <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;&#34;</span>, <span style="color:#458;font-weight:bold">int</span> age <span style="font-weight:bold">=</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_name(name), m_age(age) {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_name() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_name; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_age() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_age; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">BaseballPlayer</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Person {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> m_batting_average{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_homeruns{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BaseballPlayer(<span style="color:#458;font-weight:bold">double</span> batting_average <span style="font-weight:bold">=</span> <span style="color:#099">0</span>, <span style="color:#458;font-weight:bold">int</span> homeruns <span style="font-weight:bold">=</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_batting_average(batting_average), m_homeruns(homeruns) {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>In the example above we&rsquo;re declaring <code>BaseballPlayer</code> as a public inheritance of <code>Person</code>. We&rsquo;ll talk more about this in a future lesson.</p>
<h2 id="order-of-construction-of-derived-classes">Order of construction of derived classes</h2>
<p>C++ constructs derived classes in phases, starting with the most-base class and finishing with the most-child class. As each class is constructed, the appropriate constructor from that class is called to initialize that part of the class.</p>
<h2 id="constructors-and-initialization-of-derived-classes">Constructors and initialization of derived classes</h2>
<p>Here is what happens when a base class is instantiated:</p>
<ul>
<li>Memory for base is set aside</li>
<li>The appropriate base constructor is called</li>
<li>The mmeber initializer list initializes variables</li>
<li>The body of the constructor executes</li>
<li>Control is returned to the caller</li>
</ul>
<p>And here is what happens when a derived class is instantiated:</p>
<ul>
<li>Memory for derived is set aside (for both base and derived portions)</li>
<li>The appropriate derived constructor is called</li>
<li>The base object is constructed first using the appropriate base constructor</li>
<li>The member initializer list initializes variables</li>
<li>The body of the constructor executes</li>
<li>Control is returned to the caller</li>
</ul>
<p>However, it&rsquo;s important to realize that we <strong>cannot</strong> initialize the members defined in the base class. Consider what would happen if the member variable of the base class were const. Since const variables must be initialized with a value at the time of creation, the base class constructor must set its value when the variable is created and the derived class constructor can no longer modify it. Even if the member variable was not const, we would have to double-initialize the same variable and that&rsquo;s not allowed (or at least, recommended). That means the following won&rsquo;t work</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {  <span style="color:#998;font-style:italic">// assume m_id was declared in Base class
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> m_cost{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">double</span> cost<span style="font-weight:bold">=</span><span style="color:#099">0.</span>, <span style="color:#458;font-weight:bold">int</span> id<span style="font-weight:bold">=</span><span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_cost{cost}, m_id{id} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The following would work but only when <code>m_id</code> was not declared const, and again it&rsquo;s not optimal with double assignment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> m_cost{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">double</span> cost<span style="font-weight:bold">=</span><span style="color:#099">0.</span>, <span style="color:#458;font-weight:bold">int</span> id<span style="font-weight:bold">=</span><span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_cost{cost} {
</span></span><span style="display:flex;"><span>        m_id <span style="font-weight:bold">=</span> id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The correct way is to delegate the construction to the base class constructor directly:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> m_cost{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">double</span> cost<span style="font-weight:bold">=</span><span style="color:#099">0.</span>, <span style="color:#458;font-weight:bold">int</span> id<span style="font-weight:bold">=</span><span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> Base{id}, m_cost{cost} {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Here is what happened above:</p>
<ul>
<li>Memory for derived is allocated</li>
<li>The derived constructor is called</li>
<li>The compiler looks to see if we&rsquo;ve asked for a particular base class constructor &ndash; we have</li>
<li>The base class constructor is explicitly called</li>
<li>The base class constructor body executes</li>
<li>The base class constructor returns</li>
<li>The derived class constructor is called</li>
<li>The derived class constructor body executes</li>
<li>The derived class constructor returns</li>
</ul>
<h2 id="inheritance-and-access-specifiers">Inheritance and access specifiers</h2>
<p>We&rsquo;ve seen <code>public</code> and <code>private</code> access specifiers. There is one more access specifier called <code>protected</code> which brings a lit bit of complexity to the discussion. The <code>protected</code> access specifier allows to the class the member belongs to, friends and drvied class to access the member. However, protected members are not accessbible from outside the class. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_private{};       <span style="color:#998;font-style:italic">// can only be accessed by Base members and friends 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">protected</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_protected{};     <span style="color:#998;font-style:italic">// can be accessed by Base members, friends and derived classes 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_public{};        <span style="color:#998;font-style:italic">// can be accessed anybody 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>correspondingly, there are three types of inheritance in C++:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">PrivateDerived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">private</span> Base {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// m_private becomes inaccessible *
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// m_protected becomes private *
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// m_public becomes private *
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">ProtectedDerived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">protected</span> Base {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// m_private becomes inaccessible * 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// m_protected becomes protected * 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// m_public becomes protected * 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">PublicDerived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// m_private becomes inaccessible *
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// m_protected remains protected 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// m_public remains public 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><h2 id="adding-new-functionality-to-a-derived-class">Adding new functionality to a derived class</h2>
<p>One of the biggest benefits of inheritance is the ability to reuse already written code. We can inherit the base class functionality and then add new functionality, modify existing functionality or hide functionality you don&rsquo;t want. Assume we have the following setup:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">protected</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Base(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> m_value{value} {}
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">identity</span>() <span style="font-weight:bold">const</span> { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;I am a Base</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> Base{value} {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Now, say we want to &ldquo;modify&rdquo; the base class so that <code>m_value</code> is accessible from the public. We can add this new functionality though the derived class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// same as above
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> get_value() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_value; } 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="calling-inherited-functions-and-overriding-behavior">Calling inherited functions and overriding behavior</h2>
<p>In the example from the previous sector, we can observe this strange behavior:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Base base {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    base.identify();
</span></span><span style="display:flex;"><span>    Derived deri{<span style="color:#099">8</span>};
</span></span><span style="display:flex;"><span>    deri.identify();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output is</p>
<pre tabindex="0"><code>I am a Base 
I am a Base 
</code></pre><p>How can we correct this? We can modify the function inherited from the base class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// same as default 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> identify() <span style="font-weight:bold">const</span> { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;I am a Derived</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>We can also add to existing functionality, instead of overriding the member function altogether:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// same as default 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> identify() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        Base<span style="font-weight:bold">::</span>identify();  <span style="color:#998;font-style:italic">// calling the inherited function
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;...and I am a Derived</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Notice the scope <code>Base::</code> is necessary to avoid infinite recursion.</p>
<p>It becomes trickier when we want to call the friend function of the base class, as the scope won&rsquo;t apply in this case. To do that, we can use <code>static_cast</code> to make our derived class temporarily &ldquo;look like&rdquo; a base:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Base<span style="font-weight:bold">&amp;</span> b) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Drvied</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Derived<span style="font-weight:bold">&amp;</span> d) {
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Inside Derived we print:</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> <span style="font-weight:bold">static_cast</span><span style="font-weight:bold">&lt;</span><span style="font-weight:bold">const</span> Base<span style="font-weight:bold">&amp;&gt;</span>(d);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> os;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="hiding-inherited-functionality">Hiding inherited functionality</h2>
<p>We can expose an inherited function to public:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">protected</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> print() <span style="font-weight:bold">const</span> { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;yo!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Base(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> m_value{value} {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> Base{value} {}
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> Base<span style="font-weight:bold">::</span>print;  <span style="color:#998;font-style:italic">// no parentheses here!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>We can also hide an inherited functionality:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">using</span> Base<span style="font-weight:bold">::</span>print;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>However, the <code>print</code> function is still public to <code>Base</code> and we can still access it from <code>Derived</code> by <code>static_cast</code> the derived class instance to a <code>Base</code>. Also, given a set of overloaded functions in the base class, there is no way to change the access specifier for a single overload. You can only change them all if wanted.</p>
<p>We can also outright delete a function inherited from base class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> oublic Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> print() <span style="font-weight:bold">const</span> <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="multiple-inheritance">Multiple inheritance</h2>
<p>Multiple inheritance enables a derived class to inherit members from multiple parents. To use multiple inheritance, simply specify each base class separated by a comma:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Person</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_age{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Person(std<span style="font-weight:bold">::</span>string_view name, <span style="color:#458;font-weight:bold">int</span> age)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_name{ name }, m_age{ age } {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> getName() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_name; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getAge</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_age; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Employee</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_employer{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> m_wage{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Employee(std<span style="font-weight:bold">::</span>string_view employer, <span style="color:#458;font-weight:bold">double</span> wage)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> m_employer{ employer }, m_wage{ wage } {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> getEmployer() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_employer; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">getWage</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_wage; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Teacher</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Person, <span style="font-weight:bold">public</span> Employee {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_teachesGrade{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Teacher(std<span style="font-weight:bold">::</span>string_view name, <span style="color:#458;font-weight:bold">int</span> age, std<span style="font-weight:bold">::</span>string_view employer, <span style="color:#458;font-weight:bold">double</span> wage, <span style="color:#458;font-weight:bold">int</span> teachesGrade)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">:</span> Person{ name, age }, Employee{ employer, wage }, m_teachesGrade{ teachesGrade } {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Teacher t{ <span style="color:#b84">&#34;Mary&#34;</span>, <span style="color:#099">45</span>, <span style="color:#b84">&#34;Boo&#34;</span>, <span style="color:#099">14.3</span>, <span style="color:#099">8</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A <strong>mixin</strong> (also spelled as &ldquo;mix-in&rdquo;) is a small class that can be inherited from in order to add properties to a clas. The name mixin indicates that the class is intended to be mixed into other classes, not instantiated on its own. In the following example, the <code>BoxMixin</code> and <code>LabelMixin</code> classes are mixins that we can inherit from in order to create a <code>Button</code> class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">Point2D</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> x{};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y{};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">BoxMixin</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Point2D m_top_left{};
</span></span><span style="display:flex;"><span>    Point2D m_bottom_right{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> set_top_left(Point2D point) { m_top_left <span style="font-weight:bold">=</span> point; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">set_bottom_right</span>(Point2D point) { m_bottom_right <span style="font-weight:bold">=</span> point; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">LabelMixin</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_text{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> set_text(std<span style="font-weight:bold">::</span>string_view text) { m_text <span style="font-weight:bold">=</span> text; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Button</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> BoxMixin, <span style="font-weight:bold">public</span> LabelMixin {};
</span></span></code></pre></div><p>It&rsquo;s common to see mixins defined using templates:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">T</span><span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Mixin</span> {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Mixin<span style="font-weight:bold">&lt;</span>Derived<span style="font-weight:bold">&gt;</span> {};
</span></span></code></pre></div><p>Such inheritance is called <strong>Curiously Recurring Template Pattern</strong> (CRTP).</p>
<p>There are several problems with multiple inheritance:</p>
<ul>
<li>Ambiguity from same identifiers from multiple parents (can be resolved with explicit scope)</li>
<li>The <strong>diamond problem</strong>, namely inheriting from multiple parents who are thereafter children to the same grandparent class, which may cause a ton of problems e.g. how many copies of the grandparent class should the derived class hold</li>
</ul>
<h1 id="virtual-functions">Virtual Functions</h1>
<h2 id="pointers-and-references-to-the-base-class-of-derived-objects">Pointers and references to the base class of derived objects</h2>
<p>Check the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">protected</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_value {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Base(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> m_value{value} {}
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view get_name() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Base&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">get_value</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_value; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">int</span> value) <span style="font-weight:bold">:</span> Base { value } {}
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view get_name() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Derived&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">get_value_doubled</span>() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_value <span style="font-weight:bold">*</span> <span style="color:#099">2</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Derived derived { <span style="color:#099">5</span> };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;derived is a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> derived.get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and has value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> derived.get_value() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    Derived<span style="font-weight:bold">&amp;</span> ref_derived { derived };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;ref_derived is a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ref_derived.get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and has value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ref_derived.get_value() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    Derived<span style="font-weight:bold">*</span> ptr_derived { <span style="font-weight:bold">&amp;</span>derived };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;ptr_derived is a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ptr_derived<span style="font-weight:bold">-&gt;</span>get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and has value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ptr_derived<span style="font-weight:bold">-&gt;</span>get_value() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    Base<span style="font-weight:bold">&amp;</span> ref_base { derived };   <span style="color:#998;font-style:italic">// Base type ref to derived obj
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;ref_base is a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ref_base.get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and has value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ref_base.get_value() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    Base<span style="font-weight:bold">*</span> ptr_base { <span style="font-weight:bold">&amp;</span>derived };  <span style="color:#998;font-style:italic">// Base type ptr to derived obj
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;derived is a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ptr_base<span style="font-weight:bold">-&gt;</span>get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; and has value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ptr_base<span style="font-weight:bold">-&gt;</span>get_value() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Surprisingly (maybe) we will get the following output:</p>
<pre tabindex="0"><code>derived is a Derived and has value 5
ref_derived is a Derived and has value 5
ptr_derived is a Derived and has value 5
ref_base is a Base and has value 5
derived is a Base and has value 5
</code></pre><p>Notice how only the base part of the <code>derived</code> instance got referenced/pointed. It also means we cannot access anything under the derived part e.g. <code>get_value_doubled</code>. This is relevant (and not silly at all) when we want to write one function that takes the base class instead of multiple functions corresponding to the overload of each derived class.</p>
<h2 id="virtual-functions-and-polymorphism">Virtual functions and polymorphism</h2>
<p>A <strong>virtual function</strong> is a special type of member function that, when called, resolves to the most-derived version of the function for the actual type of the object being referenced or pointed to. A derived function is considered a match if it has the same signature (name, parameter types and whether it&rsquo;s const) and return type as the base version of the function. Such functions are called <strong>overrides</strong>. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view get_name() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Base&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view get_name() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Derived&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Derived derived {};
</span></span><span style="display:flex;"><span>    Base<span style="font-weight:bold">&amp;</span> ref_base { derived };   <span style="color:#998;font-style:italic">// Base type ref to derived obj 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;ref_base is a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> ref_base.get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since <code>ref_base</code> only references to the base part of the object, by default the <code>get_name</code> resolves to the version under the base class. However, with the <code>virtual</code> specifier we let the compiler know that the function should instead resolve to the most-derived version, which in this case suits our need.</p>
<p>Notice that the virtual function resolution only works when it&rsquo;s called through a pointer or refernce to the class object. It&rsquo;s natural that the compiler will call the exact member function when we call the virtual function from the object directly.</p>
<p>In programming, <strong>polymorphism</strong> refers to the ability of an entity to have multiple forms. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> add(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> add(<span style="color:#458;font-weight:bold">double</span>, <span style="color:#458;font-weight:bold">double</span>)
</span></span></code></pre></div><p>There are two types of polymorphism:</p>
<ul>
<li>Compile-time polymorphism refers to forms of polymorphism that are resolved by the compiler, which includes function overloads and template resolution</li>
<li>Runtime polymorphism refers to forms of polymorphism that are resolved at runtime, which includes virtual functions etc</li>
</ul>
<p>Last notes:</p>
<ul>
<li>If a base function is virtual, all matching overrides are implicitly virtual even without the <code>virtual</code> specifier.</li>
<li>Virtual functions take longer time to resolve</li>
<li>Don&rsquo;t call virtual functions inside constructors or destructors, as only the base version would exist at that time</li>
</ul>
<h2 id="the-overrides-and-final-specifiers-and-covariant-return-types">The overrides and final specifiers and covariant return types</h2>
<p>To address some common challenges with inheritance, C++ has two inheritance-related identifiers: <code>override</code> and <code>final</code>. Note that they identifiers are not keywords, they are normal words that have special meaning only when used in certain contexts. The C++ standard calls them &ldquo;identifiers with special meaning&rdquo;, but they&rsquo;re often just referred to as &ldquo;specifiers&rdquo;.</p>
<p>A derived class virtual function is only considered an override if its signature and return types match exactly. To help address the issue of functions that are meant to be overrides but aren&rsquo;t, the override specifier can be applied to any virtual function by placing the <code>override</code> specifier after the function signature (the same place a function-level const specifier goes). If the function is not an override to a base class function (or is applied to a non-virtual function), the compiler will flag the function as an error:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">A</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view getName1(<span style="color:#458;font-weight:bold">int</span> x) { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;A&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view getName2(<span style="color:#458;font-weight:bold">int</span> x) { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;A&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view getName3(<span style="color:#458;font-weight:bold">int</span> x) { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;A&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">B</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> A {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view getName1(<span style="color:#458;font-weight:bold">short</span> <span style="color:#458;font-weight:bold">int</span> x) <span style="font-weight:bold">override</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;B&#34;</span>; } <span style="color:#998;font-style:italic">// compile error, function is not an override
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string_view getName2(<span style="color:#458;font-weight:bold">int</span> x) <span style="font-weight:bold">const</span> <span style="font-weight:bold">override</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;B&#34;</span>; } <span style="color:#998;font-style:italic">// compile error, function is not an override
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string_view getName3(<span style="color:#458;font-weight:bold">int</span> x) <span style="font-weight:bold">override</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;B&#34;</span>; } <span style="color:#998;font-style:italic">// okay, function is an override of A::getName3(int)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are cases where you don&rsquo;t want someone to be able to override a virtual function, or inherit from a class. The final specifier can be used in that case to enforce.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">A</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view getName() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;A&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">B</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> A {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// note use of final specifier on following line -- that makes this function not able to be overridden in derived classes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    std<span style="font-weight:bold">::</span>string_view getName() <span style="font-weight:bold">const</span> <span style="font-weight:bold">override</span> <span style="font-weight:bold">final</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;B&#34;</span>; } <span style="color:#998;font-style:italic">// okay, overrides A::getName()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">C</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> B {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view getName() <span style="font-weight:bold">const</span> <span style="font-weight:bold">override</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;C&#34;</span>; } <span style="color:#998;font-style:italic">// compile error: overrides B::getName(), which is final
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>In the case where we want to prevent inheriting from a class, the final specifier is applied after the class name:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">A</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view getName() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;A&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">B</span> <span style="font-weight:bold">final</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> A { <span style="color:#998;font-style:italic">// note use of final specifier here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view getName() <span style="font-weight:bold">const</span> <span style="font-weight:bold">override</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;B&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">C</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> B { <span style="color:#998;font-style:italic">// compile error: cannot inherit from final class
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string_view getName() <span style="font-weight:bold">const</span> <span style="font-weight:bold">override</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;C&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>There is one special case in which a derived class virtual function override can have a different return type than the base class and still be considered a matching override. If the return type of a virtual function is a pointer or a reference to some class, override function can return a pointer or reference to a derived class. These are called <strong>covariant return types</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// This version of getThis() returns a pointer to a Base class
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">virtual</span> Base<span style="font-weight:bold">*</span> getThis() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;called Base::getThis()</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; <span style="font-weight:bold">return</span> <span style="font-weight:bold">this</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printType</span>() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;returned a Base</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Normally override functions have to return objects of the same type as the base function
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// However, because Derived is derived from Base, it&#39;s okay to return Derived* instead of Base*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    Derived<span style="font-weight:bold">*</span> getThis() <span style="font-weight:bold">override</span> { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;called Derived::getThis()</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="font-weight:bold">return</span> <span style="font-weight:bold">this</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printType</span>() { std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;returned a Derived</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Derived d{};
</span></span><span style="display:flex;"><span>    Base<span style="font-weight:bold">*</span> b{ <span style="font-weight:bold">&amp;</span>d };
</span></span><span style="display:flex;"><span>    d.getThis()<span style="font-weight:bold">-&gt;</span>printType(); <span style="color:#998;font-style:italic">// calls Derived::getThis(), returns a Derived*, calls Derived::printType
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    b<span style="font-weight:bold">-&gt;</span>getThis()<span style="font-weight:bold">-&gt;</span>printType(); <span style="color:#998;font-style:italic">// calls Derived::getThis(), returns a Base*, calls Base::printType
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="virtual-destructors-virtual-assignment-and-overriding-virtualization">Virtual destructors, virtual assignment and overriding virtualization</h2>
<p>Whenever we need to define our own destructor for a derived class, we need to make it virtual:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">*</span> m_array {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">int</span> length) <span style="font-weight:bold">:</span> m_array{<span style="font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span>[length]} {}
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> <span style="font-weight:bold">~</span>Derived() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_array;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>It is not necessary to create an empty derived class destructor just to mark it as virtual, as derived overrides are all assumed virtual if not otherwise specified.</p>
<p>As for virtual assignments, it&rsquo;s generally not needed nor suggested to consider virtualizing assignment operators for the interest of simplicity.</p>
<p>More often, we can ignore virtualization by uisng scope resolution operator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Derived derived {};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> Base<span style="font-weight:bold">&amp;</span> base { derived };
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> base.Base<span style="font-weight:bold">::</span>get_name() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally we have these rules (just as recommendations / rules of thumb):</p>
<ul>
<li>If you intend your class to be inherited from, make sure your destructor is virtual</li>
<li>If you do not intend your class to be inherited from, mark your class as final. This will prevent other classes from inheriting from it in the first place, without imposing any other use restrictions on the class itself</li>
</ul>
<h2 id="early-binding-and-late-binding">Early binding and late binding</h2>
<p>When a program is compiled, the compiler converts each statement in your C++ program into one or more lines of machine language. Each line of machine language is given its own unique sequential address. This is no different for functions &ndash; when a function is encountered, it is converted into machine language and given the next available address. Thus, each function ends up with a unique address.</p>
<p><strong>Binding</strong> refers to the process that is used to convert identifiers (such as variable and function names) into addresses. Although binding is used for both variables and functions, in this lesson we’re going to focus on function binding.</p>
<p><strong>Early binding</strong> (as known as static binding) means the compiler (or linker) is able to directly associate the identifier name (s.g. function or variable name) with a machine address. This includes cases where we define functions ahead of time and call them directly.</p>
<p><strong>Late binding</strong> (also known as dynamic binding, in the case of virtual function resolution) means the function being called is looked by name at runtime only. In C++, one way to get late binding is to use function pointers. Calling a function via a pointer is also known as an indirect function call, in which case the compiler cannot tell which function is pointed to at compile time.</p>
<h2 id="the-virtual-table">The virtual table</h2>
<p>C++ implementations typically implement virtual functions using a form of late biding known as the virtual table, which is a lookup table of functions used to resolve function calls in a dynamic/late binding manner. The virtual table sometimes goes by &ldquo;vtable&rdquo; or &ldquo;dispatch table&rdquo;.</p>
<p>Every class that uses virtual functions (or is derived from a class that uses virtual functions) has a corresponding virtual table. The table is simply a static array that the compiler sets up at compile time. A virtual table contains one entry for each virtual function that can be called by objects of the class. Each entry in this table is simply a function pointer that points to the most-derived function accessible by the class. The compiler then also adds a hidden pointer that is a member of the base class, which we call <code>*__vptr</code>. Unlike the <code>this</code> pointer, which is actually a function parameter used by the compiler to resolve self-reference, <code>*__vptr</code> is a real pointer member. It makes each class object allocated bigger by the size of one pointer. It also means <code>*__vptr</code> is inherited by the derived classes, which is important.</p>
<h2 id="pure-virtual-functions-abstract-base-classes-and-interface-classes">Pure virtual functions, abstract base classes and interface classes</h2>
<p>C++ allows us to create a special kind o virtual functions called <strong>pure virtual functions</strong> (or abstract functions) that have no body at all. A pure virtual function simply acts as a placeholder that is meant to be redefined by derived classes.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Animal</span> {  <span style="color:#998;font-style:italic">// this is an ABC
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">protected</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_name {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Animal(std<span style="font-weight:bold">::</span>string_view name) <span style="font-weight:bold">:</span> m_name{ name } {}
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> getName() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_name; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string_view speak() <span style="font-weight:bold">const</span> <span style="font-weight:bold">=</span> <span style="color:#099">0</span>; <span style="color:#998;font-style:italic">// speak is a pure virtual function
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">virtual</span> <span style="font-weight:bold">~</span>Animal() <span style="font-weight:bold">=</span> <span style="font-weight:bold">default</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Any class with one or more pure virtual functions becomes an <strong>abstract base class</strong>, which means that it cannot be instantiated.</p>
<p>An <strong>interface class</strong> is a class that has no member variables, and where all of the functions are pure virtual. Interfaces are useful when you want to define the functionality that derived classes must implement but leave the details of how the derived class implement that functionality entirely up to the derived class. Interface classes are often named beginning with &ldquo;I&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">IErrorLog</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> <span style="color:#458;font-weight:bold">bool</span> openLog(std<span style="font-weight:bold">::</span>string_view filename) <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">closeLog</span>() <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">writeError</span>(std<span style="font-weight:bold">::</span>string_view errorMessage) <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> <span style="font-weight:bold">~</span>IErrorLog() {} <span style="color:#998;font-style:italic">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper *derived* destructor is called
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>with this, we can write functions that takes a parameter in any class that conforms to the <code>IErrorLog</code> interface:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cmath&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// for sqrt()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// instead of this, assuming FileErrorLog derives from IErrorLog
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">mySqrt</span>(<span style="color:#458;font-weight:bold">double</span> value, FileErrorLog<span style="font-weight:bold">&amp;</span> log) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (value <span style="font-weight:bold">&lt;</span> <span style="color:#099">0.0</span>) {
</span></span><span style="display:flex;"><span>        log.writeError(<span style="color:#b84">&#34;Tried to take square root of value less than 0&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">0.0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>sqrt(value);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// now we have this
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">mySqrt</span>(<span style="color:#458;font-weight:bold">double</span> value, IErrorLog<span style="font-weight:bold">&amp;</span> log) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (value <span style="font-weight:bold">&lt;</span> <span style="color:#099">0.0</span>) {
</span></span><span style="display:flex;"><span>        log.writeError(<span style="color:#b84">&#34;Tried to take square root of value less than 0&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">0.0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>sqrt(value);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="virtual-base-classes">Virtual base classes</h2>
<p>We can solve the dimond problem (discussed earlier) by inheriting virtually:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">PoweredDevice</span> {
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Scanner</span><span style="font-weight:bold">:</span> <span style="font-weight:bold">virtual</span> <span style="font-weight:bold">public</span> PoweredDevice {
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Printer</span><span style="font-weight:bold">:</span> <span style="font-weight:bold">virtual</span> <span style="font-weight:bold">public</span> PoweredDevice {
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Copier</span><span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Scanner, <span style="font-weight:bold">public</span> Printer {
</span></span><span style="display:flex;"><span>};  <span style="color:#998;font-style:italic">// neither Scanner or Printer will constructor PoweredDevice -- Copier itself will do the job
</span></span></span></code></pre></div><h2 id="object-slicing">Object slicing</h2>
<p>Object slicing happens when we assign a derived object to a base type, it also happens when we push elements into a vector when the vector is of base type while the new element is of derived. We can avoid this by using references and pointers.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Derived d1 {<span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>    Derived d2 {<span style="color:#099">6</span>};
</span></span><span style="display:flex;"><span>    Baser<span style="font-weight:bold">&amp;</span> b {d2};
</span></span><span style="display:flex;"><span>    b <span style="font-weight:bold">=</span> d1;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the above example, <code>b</code> is initialized a derived from <code>d2</code> but then assigned <code>d1</code> later. However, only the base portion of the <code>d1</code> will be copied over and the result is <code>b</code> becomes base of <code>d1</code> together with derived of <code>d2</code>.</p>
<h2 id="dynamic-casting">Dynamic casting</h2>
<p>We can use <code>dynamic_cast</code> just like <code>static_cast</code> to convert a base pointer (pointing at a derived object) to a derived pointer. If the pointer being converted is not pointing to a derived object, the resulting pointer will be a null pointer. It is also konwn as <strong>downcasting</strong> (comparing with <strong>upcasting</strong> from a derived up to base). There are also several other cases where downcasting won&rsquo;t work:</p>
<ul>
<li>With protected or private inheritance</li>
<li>For classes that do not declare or inherit any virtual functions (and thus have no virtual table, which downcasting needs)</li>
<li>In certain cases involving virtual base classes, see <a href="https://learn.microsoft.com/en-us/cpp/cpp/dynamic-cast-operator?view=msvc-170&amp;redirectedfrom=MSDN">here</a></li>
</ul>
<p>Also, it turns out that we can use <code>static_cast</code> for downcasting, which will be faster but more dangerous because there will be no type checking at runtime. Instead of a null pointer, we will observe undefined behavior if we downcast a pointer <strong>not</strong> pointing at a derived object.</p>
<p>In addition to pointers, dynamic casting also works for references.</p>
<p>In general, using virtual function should be preferred over downcasting. However, there are several cases where downcasting is the better choice:</p>
<ul>
<li>When you can not modify the base class to add a virtual function (e.g. because the base class is part of the standard library)</li>
<li>When you need access to something that is derived-class specific (e.g. an access function that only exists in the derived class)</li>
<li>When adding a virtual function to your base class doesn’t make sense (e.g. there is no appropriate value for the base class to return). Using a pure virtual function may be an option here if you don’t need to instantiate the base class.</li>
</ul>
<h2 id="printing-inherited-classes-using-operator">Printing inherited classes using operator<code>&lt;&lt;</code></h2>
<p>Because we typically implement operator<code>&lt;&lt;</code> as a friend instead of member function, and friends cannot be virtualized, we can&rsquo;t simply pretend that C++ will use the most derived overload version of the function when we want to print an inherited class.</p>
<p>Instead of making operator<code>&lt;&lt;</code> virtual, a simple solution is to let it call a function that is virtualized:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">friend</span> std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">&lt;&lt;</span>(std<span style="font-weight:bold">::</span>ostream<span style="font-weight:bold">&amp;</span> os, <span style="font-weight:bold">const</span> Base<span style="font-weight:bold">&amp;</span> b) {
</span></span><span style="display:flex;"><span>        os <span style="font-weight:bold">&lt;&lt;</span> b.identify();
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> os;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">virtual</span> std<span style="font-weight:bold">::</span>string identify() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Base&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string identify() <span style="font-weight:bold">const</span> <span style="font-weight:bold">override</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Derived&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Base b{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Derived d{};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> d <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;  <span style="color:#998;font-style:italic">// this works even without explicit &lt;&lt; in Derived
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    Base<span style="font-weight:bold">&amp;</span> bref {d};
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> bref <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program will print</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Base
</span></span><span style="display:flex;"><span>Derived 
</span></span><span style="display:flex;"><span>Derived 
</span></span></code></pre></div><h1 id="templates-and-classes">Templates and Classes</h1>
<h2 id="template-classes">Template classes</h2>
<p>Let&rsquo;s say we want to create a template class of array that works with any type of elements. In <code>array.h</code> we have</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#ifndef ARRAY_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#define ARRAY_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cassert&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Array</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_len{};
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">*</span> m_data{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Array(<span style="color:#458;font-weight:bold">int</span> len) {
</span></span><span style="display:flex;"><span>        assert(len <span style="font-weight:bold">&gt;</span> <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> T[len]{};
</span></span><span style="display:flex;"><span>        m_len <span style="font-weight:bold">=</span> len;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Array(<span style="font-weight:bold">const</span> Array<span style="font-weight:bold">&amp;</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>    Array<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span><span style="font-weight:bold">=</span>(<span style="font-weight:bold">const</span> Array<span style="font-weight:bold">&amp;</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">~</span>Array() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">erase</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        m_data <span style="font-weight:bold">=</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        m_len <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span>[](<span style="color:#458;font-weight:bold">int</span> i);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">get_len</span>() <span style="font-weight:bold">const</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_len;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>T<span style="font-weight:bold">&amp;</span> Array<span style="font-weight:bold">&lt;</span>T<span style="font-weight:bold">&gt;::</span><span style="font-weight:bold">operator</span>[](<span style="color:#458;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>    assert(i <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span> <span style="font-weight:bold">&amp;&amp;</span> i <span style="font-weight:bold">&lt;</span> m_len);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m_data[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#endif
</span></span></span></code></pre></div><p>We can then use the template class as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> len{<span style="color:#099">12</span>};
</span></span><span style="display:flex;"><span>    Array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span> int_arr{len};
</span></span><span style="display:flex;"><span>    Array<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span> double_arr{len};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i{<span style="color:#099">0</span>}; i <span style="font-weight:bold">&lt;</span> len; <span style="font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        int_arr[i] <span style="font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>        double_arr[i] <span style="font-weight:bold">=</span> i <span style="font-weight:bold">+</span> <span style="color:#099">0.5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i{len <span style="font-weight:bold">-</span> <span style="color:#099">1</span>}; i <span style="font-weight:bold">&gt;=</span> <span style="color:#099">0</span>; <span style="font-weight:bold">--</span>i) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> int_arr[i] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\t&#39;</span> <span style="font-weight:bold">&lt;&lt;</span> double_arr[i] <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which prints:</p>
<pre tabindex="0"><code>11  11.5
10  10.5
9   9.5
8   8.5
7   7.5
6   6.5
5   5.5
4   4.5
3   3.5
2   2.5
1   1.5
0   0.5
</code></pre><p>Notice that we <strong>cannot</strong> also move the definition part of <code>Array::operator[]</code> into <code>array.cpp</code>. This is because a template is not a class or a function, but a stencil used to create classes or functions. We can leave everything inside the header file, or put the definitions we originally want to put in <code>array.cpp</code> now into <code>array.inl</code> (as in &ldquo;inline&rdquo;) and then include <code>array.inl</code> at the bottom of the <code>array.h</code> file. A third solution is to write declarations in <code>array.h</code>, definitions in <code>array.cpp</code>, and then include both into another file e.g. <code>templates.cpp</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;array.h&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&#34;array.cpp&#34;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Array</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="font-weight:bold">&gt;</span>;  <span style="color:#998;font-style:italic">// explicitly instantiate template class here!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">template</span> <span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Array</span><span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span>;
</span></span></code></pre></div><h2 id="template-non-type-parameters">Template non-type parameters</h2>
<p>A template non-type parameter is a template parameter where the type of the parameter is predefined and is substituted for a constexpr value passed in as an argument. A non-type parameter can be any of the following types:</p>
<ul>
<li>An integral type</li>
<li>An enumeration type</li>
<li>A pointer or reference to a class object</li>
<li>A pointer or reference to a function</li>
<li>A pointer or reference to a class member function</li>
<li><code>std::nullptr_t</code></li>
<li>A floating point type (since C++20)</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, <span style="color:#458;font-weight:bold">int</span> size<span style="font-weight:bold">&gt;</span>  <span style="color:#998;font-style:italic">// size here is an integral non-type parameter 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">StaticArray</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    T m_array[size] {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">*</span> get_array();
</span></span><span style="display:flex;"><span>    T<span style="font-weight:bold">&amp;</span> <span style="font-weight:bold">operator</span>[](<span style="color:#458;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> m_array[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span><span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T, <span style="color:#458;font-weight:bold">int</span> size<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>T<span style="font-weight:bold">*</span> StaticArray<span style="font-weight:bold">&lt;</span>T, size<span style="font-weight:bold">&gt;::</span>get_array() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m_array;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="function-template-specialization">Function template specialization</h2>
<p>Sometimes we want to vary a bit about the behavior of a templated function. Say we have a templated function <code>print</code> that can print integers and doubles. However, we now would like double outputs to be in scientific notation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> print(<span style="font-weight:bold">const</span> T<span style="font-weight:bold">&amp;</span> t) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> t <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span><span style="font-weight:bold">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> print<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&amp;</span> d) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>scientific <span style="font-weight:bold">&lt;&lt;</span> d <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">5</span>);
</span></span><span style="display:flex;"><span>    print(<span style="color:#099">6.7</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>5
6.700000e+000
</code></pre><p>This is called <strong>function template specialization</strong>.</p>
<h2 id="class-template-specialization">Class template specialization</h2>
<p>When we want to &ldquo;specialize&rdquo; a class member function, we&rsquo;re no longer talking about function template specialization. Instead, since the member function resides under the template class, we&rsquo;re actually trying to implement class template specialization.</p>
<p>While we can always specialize the whole class, C++ also allows us to only specialize a certain member function and automatically implements the rest as the same as the non-specialized class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">template</span> <span style="font-weight:bold">&lt;</span><span style="font-weight:bold">typename</span> T<span style="font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Storage</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    T m_value{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Storage(T value) <span style="font-weight:bold">:</span> m_value{value} {};
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> m_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">template</span><span style="font-weight:bold">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> Storage<span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">double</span><span style="font-weight:bold">&gt;::</span>print() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>scientific <span style="font-weight:bold">&lt;&lt;</span> m_value <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}  <span style="color:#998;font-style:italic">// only specializing this member function here
</span></span></span></code></pre></div><h2 id="partial-template-specialization">Partial template specialization</h2>
<p>We can partialy specialize a class but not a function.</p>
<h1 id="exceptions">Exceptions</h1>
<h2 id="basic-exception-handling">Basic exception handling</h2>
<p>There are three keywords that work in conjunction with each other in exception handling:
<code>throw</code>, <code>try</code> and <code>catch</code>.</p>
<p>In C++, a <strong>throw statement</strong> is used to signal that an exception or error case has occurred. It&rsquo;s also commonly called <strong>raising</strong> an exception.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">throw</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>;                            <span style="color:#998;font-style:italic">// throw a literal integer 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">throw</span> ENUM_INVALID_INDEX;            <span style="color:#998;font-style:italic">// throw an enum value 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">throw</span> <span style="color:#b84">&#34;can you be quiet&#34;</span>;            <span style="color:#998;font-style:italic">// throw a literal C-style string 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">throw</span> dX;                            <span style="color:#998;font-style:italic">// throw a double varaible that was previously defined 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">throw</span> <span style="color:#900;font-weight:bold">MyException</span>(<span style="color:#b84">&#34;deadly dead&#34;</span>);    <span style="color:#998;font-style:italic">// throw an object of class MyException
</span></span></span></code></pre></div><p>We can use the <code>try</code> keyword to define a block of statements (called a <strong>try block</strong>) that acts as an observer looking for any exceptions that are thrown within:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">throw</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that the above block doesn&rsquo;t define how we&rsquo;re going to handle the exception. The actual handling is done by the <strong>catch blocks</strong>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">catch</span> (<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;We caught an int exception with value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Putting them altogether, we have the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">throw</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="color:#458;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;We caught an int exception with value &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Continuing the program now...</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the program will print</p>
<pre tabindex="0"><code>We caught an int exception with value -1 
Continuing the program now...
</code></pre><p>There are four common things that a catch block may do when they catch an exception:</p>
<ul>
<li>Print what the error is</li>
<li>Return something</li>
<li>Throw another error</li>
<li>If in <code>main()</code>, catch the fatal errors and termnate the program in a clean way</li>
</ul>
<h2 id="exceptions-functions-and-stack-unwinding">Exceptions, functions and stack unwinding</h2>
<p>You can throw an exception from within a function to be caught outside, as long as the function caller is within a try block. This mechanism is called stack unwinding.</p>
<h2 id="uncaught-exceptions-and-catch-all-handlers">Uncaught exceptions and catch-all handlers</h2>
<p>When a function throws an exception that it does not handle itself, it is making the assumption that a function somewhere down the call stack will handle the exception. When no exception handler for a function can be found, <code>std::terminate()</code> is called and the application is terminated. In such cases, the call stack may or may not be unwound. If the stack is not unwound, local variables will not be destroyed and any cleanup expected upon destruction of said variables will not happen.</p>
<p>Fortunately, C++ provides us with a mechanism to catch all types of exceptions. This is known as a catch-all handler.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">throw</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="color:#458;font-weight:bold">double</span> x) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;We caught an exception of type double: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> x <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (...) {  <span style="color:#998;font-style:italic">// catch-all handler
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;We caught an exception of undetermined type</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="exceptions-classes-and-inheritance">Exceptions, classes and inheritance</h2>
<p>We can throw an exception instead of using <code>assert</code> to pass specific error code back to the caller. However, what if we still need more information? We resort to exception classes in this case.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">ArrayException</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string m_error;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    ArrayException(std<span style="font-weight:bold">::</span>string_view error) <span style="font-weight:bold">:</span> m_error{error} {}
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>string<span style="font-weight:bold">&amp;</span> get_error() <span style="font-weight:bold">const</span> { <span style="font-weight:bold">return</span> m_error; }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Because an exception class is a class, and a class can be inherited, it&rsquo;s natural that an exception class can be derived. However, C++ checks the exception class type sequentially and when a derived exception is caught, the base type will be detected before the derived:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Base() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">throw</span> Derived();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="font-weight:bold">const</span> Base<span style="font-weight:bold">&amp;</span> base) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Caught Base</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="font-weight:bold">const</span> Derived<span style="font-weight:bold">&amp;</span> derived) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Caught Derived</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above program will print</p>
<pre tabindex="0"><code>Caught Base
</code></pre><p>and to make it work properly we have to swap the order of the two catch blocks.</p>
<p>In C++ STL we have <code>std::exception</code> (provided in <code>&lt;exception&gt;</code>) that basically is the base class of all exception classes, so we can easily catch all exceptions (by the STL) using this class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;exception&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="font-weight:bold">const</span> std<span style="font-weight:bold">::</span>exception<span style="font-weight:bold">&amp;</span> exception) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Standard exception: &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> exception.what() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and when we want to handle specific STL exceptions differently, we just add those particular catch blocks <strong>before</strong> this general block.</p>
<p>We can throw STL exceptions or derive our own exception class from <code>std::exception</code> however we like, as long as we keep the custom exception class copyable, as the compiler makes a copy of the exception object to some piece of unspecified memory (outside of the call stack) reserved for handling exceptions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Base() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived() {}
</span></span><span style="display:flex;"><span>    Derived(<span style="font-weight:bold">const</span> Derived<span style="font-weight:bold">&amp;</span>) <span style="font-weight:bold">=</span> <span style="font-weight:bold">delete</span>;   <span style="color:#998;font-style:italic">// explicitly making it not copyable 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    Derived d{};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">throw</span> d;  <span style="color:#998;font-style:italic">// compile error!!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="rethrowing-exceptions">Rethrowing exceptions</h2>
<p>When we want to rethrow an exception, we cannot just <code>throw x</code> assuming <code>x</code> is the captured exception, as class type slicing will bring unexpected behavior:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">throw</span> Derived{};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">catch</span> (Base<span style="font-weight:bold">&amp;</span> b) {
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Caught base b which is actually a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">throw</span> b;  <span style="color:#998;font-style:italic">// the Derived obj gets SLICED here!!!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (Base<span style="font-weight:bold">&amp;</span> b) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Caught base b which is actually a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The program above prints</p>
<pre tabindex="0"><code>Caught a base which is actually a Derived
Caught a base which is actually a Base
</code></pre><p>To solve this problem, simply use <code>throw</code> when we want to rethrow an exception from within a <code>catch</code> block:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">throw</span> Derived{};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">catch</span> (Base<span style="font-weight:bold">&amp;</span> b) {
</span></span><span style="display:flex;"><span>            std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Caught base b which is actually a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">throw</span>;  <span style="color:#998;font-style:italic">// the Derived obj is thrown as it is
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (Base<span style="font-weight:bold">&amp;</span> b) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Caught base b which is actually a &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> b <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>Caught a base which is actually a Derived
Caught a base which is actually a Derived
</code></pre><h2 id="function-try-blocks">Function try blocks</h2>
<p>Consider the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Base</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> m_x{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Base(<span style="color:#458;font-weight:bold">int</span> x) m_x{x} {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (x <span style="font-weight:bold">&lt;=</span> <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">throw</span> <span style="color:#099">1</span>;  <span style="color:#998;font-style:italic">// thrown inside Base()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">int</span> x) <span style="font-weight:bold">:</span> Base{x} {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// what if we want to catch the error here?
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        Derived Derived{<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// caught here
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to catch the exception inside the constructor of <code>Derived()</code>, we have to use a slightly modified try block called a <strong>function try block</strong>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// same goes for Base 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Derived</span> <span style="font-weight:bold">:</span> <span style="font-weight:bold">public</span> Base {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    Derived(<span style="color:#458;font-weight:bold">int</span> x) <span style="font-weight:bold">try</span> <span style="font-weight:bold">:</span> Base{x} { <span style="color:#998;font-style:italic">// notice the keyword try in the end!!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// whatever we want to do inside the constructor 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (...) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Exception caught inside the constructor</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">throw</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        Derived b{<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">catch</span> (<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Oops</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It is obvious that function try blocks cannot resolve exceptions or return anything, and it&rsquo;s important to know that reaching the end of the catch block will implicitly rethrow (although we explicitly rethrew here). In summary we have</p>
<table>
<thead>
<tr>
<th>function type</th>
<th>can resolve exceptions via return statement</th>
<th>behavior at the end of catch block</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>no (must throw or rethrow )</td>
<td>implicit rethrow</td>
</tr>
<tr>
<td>destructor</td>
<td>yes</td>
<td>implicit rethrow</td>
</tr>
<tr>
<td>non-value returning function</td>
<td>yes</td>
<td>resolve exception</td>
</tr>
<tr>
<td>value-returning function</td>
<td>yes</td>
<td>undefined behavior</td>
</tr>
</tbody>
</table>
<h2 id="exception-dangers-and-downsides">Exception dangers and downsides</h2>
<p>Here are some problems that might occur when using exceptions:</p>
<ul>
<li>You might forget to clean up the resources within the block &ndash; use <code>std::unique_ptr</code> which automatically deallocates when going out of scope</li>
<li>Exceptions thrown from within a destructor can cause undefined behavior &ndash; don&rsquo;t use exceptions in destructors altogether</li>
<li>Exceptions come with performance cost</li>
</ul>
<p>So when should we use exceptions at all?</p>
<ul>
<li>When the error being handled is likely to occur only infrequently</li>
<li>When the error is serious and execution could not continue otherwise</li>
<li>When the error cannot be handled at the place where it occurs</li>
<li>When there isn&rsquo;t a good alternative way to return an error code back to the caller</li>
</ul>
<h2 id="exception-specifications-and-noexcept">Exception specifications and <code>noexcept</code></h2>
<p>In C++, all functions are classified as either <em>non-throwing</em> or <em>potentially throwing</em>. To define a function as non-throwing, we simply use the <code>noexcept</code> specifier at the en of the signature:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">some_function</span>() <span style="font-weight:bold">noexcept</span>;
</span></span></code></pre></div><p>The <code>noexcept</code> here is nothing but a contractual promise &ndash; when an unhandled exception happens from within the function, undetermined behavior would occur and <code>std::terminate</code> will be called.</p>
<p>Functions that are implicitly non-throwing:</p>
<ul>
<li>Destructors</li>
</ul>
<p>Functions that are non-throwing by default for implicitly-declared or defaulted functions:</p>
<ul>
<li>Constructors: default, copy, move</li>
<li>Assignments: copy, move</li>
<li>Comparison operators (as of C++20)</li>
</ul>
<p>Functions that are potentially throwing (if not implicitly-declared or defaulted):</p>
<ul>
<li>Normal functions</li>
<li>User-defined constructors</li>
<li>User-defined operators</li>
</ul>
<p>In addition to being a specifier, <code>noexcept</code> also serves as an operator that returns <code>true</code> or <code>false</code> indicating whether the compiler thinks the content within will throw an exception or not:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">foo</span>() {<span style="font-weight:bold">throw</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>;}
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">boo</span>() {};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">goo</span>() <span style="font-weight:bold">noexcept</span> {};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">S</span>{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> b1{ <span style="font-weight:bold">noexcept</span>(<span style="color:#099">5</span> <span style="font-weight:bold">+</span> <span style="color:#099">3</span>) }; <span style="color:#998;font-style:italic">// true; ints are non-throwing
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> b2{ <span style="font-weight:bold">noexcept</span>(foo()) }; <span style="color:#998;font-style:italic">// false; foo() throws an exception
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> b3{ <span style="font-weight:bold">noexcept</span>(boo()) }; <span style="color:#998;font-style:italic">// false; boo() is implicitly noexcept(false)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> b4{ <span style="font-weight:bold">noexcept</span>(goo()) }; <span style="color:#998;font-style:italic">// true; goo() is explicitly noexcept(true)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">bool</span> b5{ <span style="font-weight:bold">noexcept</span>(S{}) };   <span style="color:#998;font-style:italic">// true; a struct&#39;s default constructor is noexcept by default
</span></span></span></code></pre></div><p>The <code>noexcept</code> operator is checked statically at compile-time and <strong>doesn&rsquo;t</strong> actually evaluate the input expression.</p>
<p>There are four levels of exception safety guarantees (which is yet another contractual guideline):</p>
<ul>
<li>No guarantee: there might be memory leak</li>
<li>Basic guarantee: no memory will be leaked if an exception is thrown</li>
<li>Strong guarantee: no memory leak, program state won&rsquo;t be changed</li>
<li>No throw / no fail guarantee: the function will always succeed (no fail) or fail without exception (no throw)</li>
</ul>
<p>Examples of code that should be no throw:</p>
<ul>
<li>Destructors and memory deallocation/cleanup functions</li>
<li>Functions that higher-level caller is no throw</li>
</ul>
<p>Examples of code that should be no fail:</p>
<ul>
<li>Move constructors and move assignments</li>
<li>Swap functions</li>
<li>Clear/erase/reset functions</li>
<li>Operations on <code>std::unique_ptr</code></li>
<li>Functions that higher-level caller is no fail</li>
</ul>
<h2 id="stdmove_if_noexcept"><code>std::move_if_noexcept</code></h2>
<p><code>std::move_if_noexcept</code> will return a movable r-value if the object ha a <code>noexcept</code> move constructor, otherwise it will return a copyable l-value. We can use <code>noexcept</code> specifier in conjunction with <code>std::move_if_noexcept</code> to use move semantics only when a strong exception guarantee exists (and use copy semantics otherwise).</p>
<h1 id="input-and-output-io">Input and Output (I/O)</h1>
<h2 id="input-and-output-io-streams">Input and output (I/O) streams</h2>
<p>Input and output functinality is not defined as part of the core C++ language but included in the STL.</p>
<p>We can include the <code>&lt;iostream&gt;</code> header to gain access to the hierarchy of classes including streams, which is just a sequence of bytes that can be accessed sequentially by definition. Specifically, input streams are used to hold input from a data producer, such as a keyboard, a file, or a network. Output streams are used to hold output for a particular data consumer, such as a monitor, a file, or a printer.</p>
<p><code>ios</code> is a typedef for <code>std::basic_ios&lt;char&gt;</code> that defines a bunch of stuff that is common to both input and output streams. The <code>istream</code> class is the primary class used when dealing with input streams, in which case the extraction operator <code>&gt;&gt;</code> is used to remove values from the stream. The <code>ostream</code> class is the primary class used when dealing with output streams, in which case the insertion operator <code>&lt;&lt;</code> is used to put values in the stream.</p>
<p>The standard stream is a pre-connected stream provided to a computer program by its environment. C++ comes with four predefined standard stream objects that have already been st up for your use:</p>
<ul>
<li><code>cin</code>: an <code>istream</code> object tied to the standard input (typically keyboard)</li>
<li><code>cout</code>: an <code>ostream</code> object tied to the standard output (typically the monitor)</li>
<li><code>cerr</code>: an <code>ostream</code> object tied to the standard error (typically the monitor), providing unbuffered output</li>
<li><code>clog</code>: an <code>ostream</code> object tied to the standard error (typically the monitor), providing buffered output</li>
</ul>
<h2 id="input-with-istream">Input with istream</h2>
<p>When using the extraction operator <code>&lt;&lt;</code>, we can use <code>std::setw()</code> manipulator to limit the number of characters read in from a stream:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iomanip&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span><span style="color:#458;font-weight:bold">char</span> buf[<span style="color:#099">10</span>]{};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> std<span style="font-weight:bold">::</span>setw(<span style="color:#099">10</span>) <span style="font-weight:bold">&gt;&gt;</span> buf;
</span></span></code></pre></div><p>Notice <code>&gt;&gt;</code> omits spaces and newlines:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> ch{}
</span></span><span style="display:flex;"><span><span style="font-weight:bold">while</span> (std<span style="font-weight:bold">::</span>cin <span style="font-weight:bold">&gt;&gt;</span> ch) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ch;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>the above prints everything <strong>without</strong> spaces. In order to keep the spaces we can use <code>cin.get()</code> which doesn&rsquo;t skip any character:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> ch{}
</span></span><span style="display:flex;"><span><span style="font-weight:bold">while</span> (std<span style="font-weight:bold">::</span>cin.get(ch)) {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> ch;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also specify the maximum number of characters to read:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> strBuf[<span style="color:#099">11</span>]{};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cin.get(strBuf, <span style="color:#099">11</span>);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> strBuf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>Notice that we&rsquo;re only reading 10 characters here since we have to leave one character for the terminator. The remaining characters were left in the istream.</p>
<p>There is another function <code>cin.getline()</code> which works just like <code>cin.get()</code> but discards the delimiter:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> strBuf[<span style="color:#099">11</span>]{};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cin.getline(strBuf, <span style="color:#099">11</span>);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> strBuf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>If we need to know how many character were extracted by the last call of <code>getline()</code>, we can use <code>gcount()</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>cin.gcount() <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34; characters were read</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span></code></pre></div><p>There is also a special version of <code>getline()</code> which, instead of residing under <code>cin</code>, is included in the string header:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>string strBuf{};
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>getline(std<span style="font-weight:bold">::</span>cin, strBuf);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> strBuf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>Here are a few more useful <code>istream</code> functions:</p>
<ul>
<li><code>ignore()</code> discards the first character in the stream</li>
<li><code>ignore(int nCount)</code> discards the first <code>nCount</code> characters</li>
<li><code>peek()</code> allows you to read a character from the stream without removing it from the stream</li>
<li><code>unget()</code> returns the last character read back into the stream so it can be read again by the next call</li>
<li><code>putback(char ch)</code> allows you to put back a character of your choice back into the stream to be read by the next call</li>
</ul>
<h2 id="output-with-ostream-and-ios">Output with <code>ostream</code> and ios</h2>
<p>The insertion operator <code>&lt;&lt;</code> is used to put information into an output stream. C++ has predefined insertion operations for all the built-in data types. When using this operator, there are two ways to change the formatting options: flags and manipulators. You can think of <strong>flags</strong> as boolean variables that can be turned on and off, and <strong>manipulators</strong> as objects placed in a stream that affect the way things are input and output.</p>
<p>To switch a flag on, we can use <code>cout.setf()</code> function with the appropriate flag as a parameter, for example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout.setf(std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>showpos);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">27</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>+27
</code></pre><p>You can also turn on multiple ios flags at once using the bitwise OR <code>|</code> operator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout.setf(std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>showpos <span style="font-weight:bold">|</span> std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>uppercase);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">1234567.89f</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>+1.23457E+06
</code></pre><p>To turn a flag off, we can use <code>std::cout.unsetf()</code>. There is one intricacy here that when a flag is turned on, it cannot automatically turn off other mutually exclusive flags. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout.setf(std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>hex);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">27</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>which prints</p>
<pre tabindex="0"><code>27
</code></pre><p>Why? This is because the default <code>std::ios::dec</code> hasn&rsquo;t been turned off yet. We need to manually turn off the decimal formatter which is mutually exclusive with <code>std::ios::hex</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout.unsetf(std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>dec);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout.setf(std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>hex);
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">27</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>and how it prints</p>
<pre tabindex="0"><code>1b
</code></pre><p>Alternatively, we can use manipulators to do the same thing without worrying about manually turning on and off these flags:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>hex <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">27</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// print 27 in hex
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">28</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;             <span style="color:#998;font-style:italic">// we&#39;re still in hex
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> std<span style="font-weight:bold">::</span>dec <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#099">29</span> <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>; <span style="color:#998;font-style:italic">// back to decimal
</span></span></span></code></pre></div><p>Here is a list of useful flags, manipulators and member functions:</p>
<ul>
<li>Print boolean as true/false or 1/0:
<ul>
<li>flag: <code>std::ios::boolalpha</code></li>
<li>manipulator: <code>std::boolalpha</code> and <code>std::noboolalpha</code></li>
</ul>
</li>
<li>Prefix the positive numbers with a plus (+) sign:
<ul>
<li>flag: <code>std::ios::showpos</code></li>
<li>manipulator: <code>std::showpos</code> and <code>std::noshowpos</code></li>
</ul>
</li>
<li>Use upper case letters:
<ul>
<li>flag: <code>std::ios::uppercase</code></li>
<li>manipulator: <code>std::uppercase</code> and <code>std::nouppercase</code></li>
</ul>
</li>
<li>Print numbers in decimal/hexadeciaml/octal
<ul>
<li>flag: <code>std::ios::dec</code>, <code>std::ios::hex</code> and <code>std::ios::oct</code></li>
<li>manipulator:<code>std::dec</code>, <code>std::hex</code> and <code>std::oct</code></li>
</ul>
</li>
<li>Print floating point numbers with different precision and format
<ul>
<li>flag: <code>std::ios::fixed</code>, <code>std::ios::scientific</code> and <code>std::ios::showpoint</code></li>
<li>manipulator: <code>std::fixed</code>, <code>std::scientific</code>, <code>std::showpoint</code>, <code>std::noshowpoint</code> and <code>std::setprecision(int)</code></li>
<li>function: <code>std::ios_base::precision()</code> (returns the current precision) and <code>std::ios_base::precision(int)</code></li>
</ul>
</li>
<li>Width, fill characters and justification
<ul>
<li>flag: <code>std::ios::internal</code> (left sign, right number), <code>std::ios::left</code> and <code>std::ios::right</code></li>
<li>manipulator: <code>std::internal</code>, <code>std::left</code>, <code>std::right</code>, <code>std::setfill(char)</code>, <code>std::setw(int)</code></li>
<li>function: <code>std::basic_ostream::fill()</code> (returns the current fill character), <code>std::basic_ostream::fill(char)</code>, <code>std::ios_base::width()</code> (returns the current width) and <code>std::ios_base::width(int)</code></li>
</ul>
</li>
</ul>
<p>Specifically, here is a table showing what different precision formatting works:</p>
<table>
<thead>
<tr>
<th>option</th>
<th>precision</th>
<th>12345.0</th>
<th>0.12345</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>3</td>
<td>1.23e+004</td>
<td>0.123</td>
</tr>
<tr>
<td>normal</td>
<td>4</td>
<td>1.235e+004</td>
<td>0.1235</td>
</tr>
<tr>
<td>normal</td>
<td>5</td>
<td>12345</td>
<td>0.12345</td>
</tr>
<tr>
<td>normal</td>
<td>6</td>
<td>12345</td>
<td>0.12345</td>
</tr>
<tr>
<td>showpoint</td>
<td>3</td>
<td>1.23e+004</td>
<td>0.123</td>
</tr>
<tr>
<td>showpoint</td>
<td>4</td>
<td>1.235e+004</td>
<td>0.1235</td>
</tr>
<tr>
<td>showpoint</td>
<td>5</td>
<td>12345.</td>
<td>0.12345</td>
</tr>
<tr>
<td>showpoint</td>
<td>6</td>
<td>12345.0</td>
<td>0.123450</td>
</tr>
<tr>
<td>fixed</td>
<td>3</td>
<td>12345.000</td>
<td>0.123</td>
</tr>
<tr>
<td>fixed</td>
<td>4</td>
<td>12345.0000</td>
<td>0.1234</td>
</tr>
<tr>
<td>fixed</td>
<td>5</td>
<td>12345.00000</td>
<td>0.12345</td>
</tr>
<tr>
<td>fixed</td>
<td>6</td>
<td>12345.000000</td>
<td>0.123450</td>
</tr>
<tr>
<td>scientific</td>
<td>3</td>
<td>1.235e+004</td>
<td>1.234e-001</td>
</tr>
<tr>
<td>scientific</td>
<td>4</td>
<td>1.2345e+004</td>
<td>1.2345e-001</td>
</tr>
<tr>
<td>scientific</td>
<td>5</td>
<td>1.23450e+004</td>
<td>1.23450e-001</td>
</tr>
<tr>
<td>scientific</td>
<td>6</td>
<td>1.234500e+004</td>
<td>1.234500e-001</td>
</tr>
</tbody>
</table>
<h2 id="stream-classes-for-strings">Stream classes for strings</h2>
<p>In addition to I/O streams, there is also another set of classes called the stream classes for strings that allow you to use the familiar insertions <code>&lt;&lt;</code> and extractions <code>&gt;&gt;</code> operators to work with strings. There are specifically six stream classes for strings: <code>istringstream</code> (derived from <code>istream</code>), <code>ostringstream</code> (derived from <code>ostream</code>) and <code>stringstream</code> (derived from <code>iostream</code>) are used for reading and writing normal characters width strings, <code>wistringstream</code>, <code>wostringstream</code> and <code>wstringstream</code> are used for reading and writing wide character strings. To use <code>stringstreams</code>, you need to include <code>&lt;sstream&gt;</code> header.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;sstream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>stringstream os{};
</span></span><span style="display:flex;"><span>os <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;well well well</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;  <span style="color:#998;font-style:italic">// works just like std::cout
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">int</span> nValue{<span style="color:#099">123</span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">constexpr</span> <span style="color:#458;font-weight:bold">double</span> dValue{<span style="color:#099">4.5</span>};
</span></span><span style="display:flex;"><span>os <span style="font-weight:bold">&lt;&lt;</span> nValue <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39; &#39;</span> <span style="font-weight:bold">&lt;&lt;</span> dValue;  <span style="color:#998;font-style:italic">// works too
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>stringstream os2{<span style="color:#099">123</span> <span style="color:#099">4.5</span>};
</span></span><span style="display:flex;"><span>os <span style="font-weight:bold">&gt;&gt;</span> nValue <span style="font-weight:bold">&gt;&gt;</span> dValue;  <span style="color:#998;font-style:italic">// works just like std::cin
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>os.str(<span style="color:#b84">&#34;&#34;</span>);  <span style="color:#998;font-style:italic">// erase the buffer 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>os.clear();  <span style="color:#998;font-style:italic">// reset error flags
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>os <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;what?</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> os.str();  <span style="color:#998;font-style:italic">// retrieving the string and print
</span></span></span></code></pre></div><h2 id="stream-states-and-input-validation">Stream states and input validation</h2>
<p>There are four stream states in C++:</p>
<ul>
<li><code>goodbit</code>: everything is ok</li>
<li><code>badbit</code>: fatal error</li>
<li><code>failbit</code>: non-fatal error</li>
<li><code>eofbit</code>: end of file</li>
</ul>
<p>and <code>ios</code> also provides these functions to access these states:</p>
<ul>
<li><code>good()</code>: boolean</li>
<li><code>bad()</code>: boolean</li>
<li><code>eod()</code>: boolean</li>
<li><code>fail()</code>: boolean</li>
<li><code>clear()</code>: clear all flags and restore to <code>goodbit</code> state</li>
<li><code>clear(state)</code>: clear all flags and sets the state flag</li>
<li><code>rdstate()</code>: returns the current state</li>
<li><code>setstate(state)</code>: set the state</li>
</ul>
<p>In terms of input validation, there are a list of useful functions provided by the <code>&lt;cctype&gt;</code> header:</p>
<ul>
<li><code>std::isalnum(int)</code>: returns non-zero if the parameter is a letter or a digit</li>
<li><code>std::isalpha(int)</code>: returns non-zero if the parameter is a letter</li>
<li><code>std::iscntrl(int)</code>: returns non-zero if the parameter is a control character</li>
<li><code>std::isdigit(int)</code>: returns non-zero if the parameter is a digit</li>
<li><code>std::isgraph(int)</code>: returns non-zero if the parameter is printable character that is not whitespace</li>
<li><code>std::isprint(int)</code>: returns non-zero if the parameter is printable character including whitespace</li>
<li><code>std::ispunct(int)</code>: returns non-zero if the parameter is neither alphanumeric nor whitespace</li>
<li><code>std::isspace(int)</code>: returns non-zero if the parameter is whitespace</li>
<li><code>std::isxdigit(int)</code>: returns non-zero if the parameter is a hexadecimal digit (0-9, a-f, A-F)</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#999;font-weight:bold"> </span><span style="color:#998;font-style:italic">// std::all_of
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;cctype&gt;</span><span style="color:#999;font-weight:bold">    </span><span style="color:#998;font-style:italic">// std::isalpha, std::isspace
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;ranges&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string_view&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">isValidName</span>(std<span style="font-weight:bold">::</span>string_view name) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>ranges<span style="font-weight:bold">::</span>all_of(name, [](<span style="color:#458;font-weight:bold">char</span> ch) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> std<span style="font-weight:bold">::</span>isalpha(ch) <span style="font-weight:bold">||</span> std<span style="font-weight:bold">::</span>isspace(ch);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>string name{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">do</span> {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Enter your name: &#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>getline(std<span style="font-weight:bold">::</span>cin, name); <span style="color:#998;font-style:italic">// get the entire line, including spaces
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  } <span style="font-weight:bold">while</span> (<span style="font-weight:bold">!</span>isValidName(name));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Hello &#34;</span> <span style="font-weight:bold">&lt;&lt;</span> name <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="basic-file-io">Basic file I/O</h2>
<p>We need <code>&lt;fstream&gt;</code> for file I/O in C++.</p>
<p>To write stuff into a file:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;fstream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>ofstream outf{ <span style="color:#b84">&#34;Sample.txt&#34;</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>outf) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Uh oh, Sample.txt could not be opened for writing!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    outf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 1</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    outf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 2</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unlike Python, here the destructor of <code>ofstream</code> will automatically close the file when going out of scope.</p>
<p>To read stuff from a file:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;fstream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;string&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>ifstream inf{ <span style="color:#b84">&#34;Sample.txt&#34;</span> };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>inf) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Uh oh, Sample.txt could not be opened for reading!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>string strInput{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// two ways to read:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">while</span> (inf <span style="font-weight:bold">&gt;&gt;</span> strInput) { <span style="color:#998;font-style:italic">// this reads word by word and breaks on whitespace
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> strInput <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">while</span> (std<span style="font-weight:bold">::</span>getline(inf, strInput)) {  <span style="color:#998;font-style:italic">// alternatively, read by lines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        std<span style="font-weight:bold">::</span>cout <span style="font-weight:bold">&lt;&lt;</span> strInput <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The file stream constructors take an optional second parameter that allows you to specify information about how the file should be opened:</p>
<ul>
<li><code>app</code>: opens the file in append mode</li>
<li><code>ate</code>: seeks to the end of the file before read/write</li>
<li><code>binary</code>: opens the file in binary mode (instead of text mode)</li>
<li><code>in</code>: opens the file in read mode (default for <code>ifstream</code>)</li>
<li><code>out</code>: opens the file in write mode (default for <code>ofstream</code>)</li>
<li><code>trunc</code>: erases the file if it already exists</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;iostream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;fstream&gt;</span><span style="color:#999;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>ofstream outf{ <span style="color:#b84">&#34;Sample.txt&#34;</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>app };  <span style="color:#998;font-style:italic">// append instead of overwrite 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>outf) {
</span></span><span style="display:flex;"><span>        std<span style="font-weight:bold">::</span>cerr <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;Uh oh, Sample.txt could not be opened for writing!</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    outf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 3</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>    outf <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 4</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Although the file stream automatically closes itself upon destruction of the class, we can still manually open and close a file:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>ofstream fout{<span style="color:#b84">&#34;Sample.txt&#34;</span>};
</span></span><span style="display:flex;"><span>fout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 1</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>fout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 2</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fout.open(<span style="color:#b84">&#34;Sample.txt&#34;</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>app);
</span></span><span style="display:flex;"><span>fout <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#34;This is line 3</span><span style="color:#b84">\n</span><span style="color:#b84">&#34;</span>;
</span></span><span style="display:flex;"><span>fout.close();
</span></span></code></pre></div><h2 id="random-file-io">Random file I/O</h2>
<p>Instead of reading from the beginning (<code>in</code> and <code>out</code> mode) or from the end (<code>ate</code> and <code>app</code> mode), it is also possible to do a random file access, that is, skip around to various points in the file to read its contents. This can be useful when your file is full of records, adn you wish to retrieve a specific record. Rather than reading all the records until getting the desired one, we can skip directly to the record we wish to retrieve.</p>
<p>Random file access is done by manipulating the file pointer using either <code>seekg()</code> function (&ldquo;get&rdquo; for input) and <code>seekp()</code> function (&ldquo;put&rdquo; for output). Both functions take two parameters, one for how many bytes to move the file pointer, and one for the <code>ios</code> flag that specifies where the offset is from. The available flags are:</p>
<ul>
<li><code>beg</code>: offset is relative to the beginning of the file (default)</li>
<li><code>cur</code>: offset is relative to the current location of the file pointer</li>
<li><code>end</code>: offset is relative to the end of the file</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>fin.seekg(<span style="color:#099">14</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>cur);    <span style="color:#998;font-style:italic">// move forward 14 bytes 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>fin.seekg(<span style="font-weight:bold">-</span><span style="color:#099">18</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>cur);   <span style="color:#998;font-style:italic">// move backwards 18 bytes 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>fin.seekg(<span style="color:#099">22</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>beg);    <span style="color:#998;font-style:italic">// move to 22nd byte in file 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>fin.seekg(<span style="font-weight:bold">-</span><span style="color:#099">28</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>end);   <span style="color:#998;font-style:italic">// move to 28th byte before EOF
</span></span></span></code></pre></div><p>There are two more functions <code>tellg()</code> and <code>tellp()</code> which returns the absolute position of the file pointer.</p>
<p>It&rsquo;s worth notice that it&rsquo;s possible to switch the read and write mode of a <code>fstream</code> (if you use <code>fstream</code> instead of <code>ifstream</code> or <code>ofstream</code>). However, you can only switch with an explicit <code>seekg()</code> or <code>seekp()</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="font-weight:bold">::</span>fstream file{<span style="color:#b84">&#34;Sample.txt&#34;</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>in <span style="font-weight:bold">|</span> std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>out};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> ch{};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">while</span> (file.get(ch)) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">switch</span> (ch) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;a&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;e&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;i&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;o&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;u&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;A&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;E&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;I&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;O&#39;</span><span style="font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">case</span> <span style="color:#b84">&#39;U&#39;</span><span style="font-weight:bold">:</span>  <span style="color:#998;font-style:italic">// if we file a vowel
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            file.seekg(<span style="font-weight:bold">-</span><span style="color:#099">1</span>, std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>cur);  <span style="color:#998;font-style:italic">// go back 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            file <span style="font-weight:bold">&lt;&lt;</span> <span style="color:#b84">&#39;#&#39;</span>;  <span style="color:#998;font-style:italic">// overwrite with # (now in write mode!)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            file.seekg(file.tellg(), std<span style="font-weight:bold">::</span>ios<span style="font-weight:bold">::</span>beg);  <span style="color:#998;font-style:italic">// switch back to read mode
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Lastly we have <code>remove()</code> function to delete a file, and <code>is_open()</code> function to tell if a file stream is currently open or not.</p>
<h1 id="miscellaneous-subjects">Miscellaneous Subjects</h1>
<h2 id="static-and-dynamic-libraries">Static and dynamic libraries</h2>
<p>A <strong>library</strong> is a package of code that is meant to be reused by many programs. Typically, a C++ library comes in two pieces:</p>
<ul>
<li>A header file that defines the functionality the library is exposing (offering) to the programs using it</li>
<li>A precompiled binary that contains the implementation of that functionality pre-compiled into machine language</li>
</ul>
<p>Some libraries may be split into multiple files and/or multiple header files.</p>
<p>There are two types of libraries, static libraries and dynamic libraries.</p>
<p>A <strong>static library</strong> (also known as an <strong>archive</strong>) consists of routines that are compiled and linked directly into your program. When you compile a program that uses a static library, all the functionality of the static library that your program uses becomes part of your executable. On Windows, static libraries typically have a <code>.lib</code> extension, whereas on Linux, static libraries typically have a <code>.a</code> (archive) extension. The benefits of using static libraries are:</p>
<ul>
<li>You only have to distribute the executable in order for users to run your program.</li>
<li>This ensures the right version of the library is always used with your program</li>
<li>Since the static libraries becomes part of your program, you can use them just like functionality you&rsquo;ve written for your own program</li>
</ul>
<p>On the downside:</p>
<ul>
<li>Because a copy of the library becomes part of every executable that uses it, this can cause a lot of wasted space</li>
<li>They tend to be hard to upgrade, as updating the library means to replace the whole executable</li>
</ul>
<p>A <strong>dynamic library</strong> (also known as a <strong>shared library</strong>) consists of routines that are loaded into your application at runtime. When you compile a program that uses a dynamic library, the library does not become part of the executable. Instead, it remains as a separate unit. On Windows, dynamic libraries typically have a <code>.dll</code> (as in <strong>d</strong>ynamic <strong>l</strong>ink <strong>l</strong>ibrary) extension, whereas on Linux, they typically have a <code>.so</code> (as in shared object) extension. Most linkers can build an import library for a dynamic library when the dynamic library is created.</p>
<h2 id="c-faq">C++ FAQ</h2>
<ul>
<li>Why shouldn&rsquo;t we use <code>using namespace std</code>: namespace pollution, different versions of STL may cause name collision, and the lack of <code>std::</code> prefixes makes it harder for readers to understand what is from STL and what is user-defined</li>
<li>Why can&rsquo;t I use type T without including the header that defines T: to not reply on implicit inclusion of packages, which may or may not break on a different compiler</li>
<li>My code that produces undefined behavior appears to be working fine, is it ok: no</li>
<li>Why does my code that produces undefined behavior generate a certain result: it&rsquo;s not important</li>
<li>Why am I getting a compile error: feel free to Google it, or check CPPReference website</li>
<li>Why should I include &ldquo;foo.h&rdquo; inside &ldquo;foo.cpp&rdquo;: maybe there&rsquo;re definitions inside &ldquo;foo.h&rdquo; that&rsquo;s needed for &ldquo;foo.cpp&rdquo; to compile; also it&rsquo;s good practice to include &ldquo;foo.h&rdquo; to just let the compiler check if there&rsquo;s any inconsistency between the two files</li>
<li>Why should we always include &ldquo;foo.cpp&rdquo; inside &ldquo;main.cpp&rdquo; just to make the project compile and work: it can result in naming collision; it can be hard to avoid ODR violations; any change to any <code>.cpp</code> file will result in the whole project to be recompiled, which can take a long time</li>
<li>What&rsquo;s causing the error &ldquo;argument list for class template XXX is missing&rdquo;: most likely it&rsquo;s due to the use of a feature called Class Template Argument Deduction (CTAD), which is a C++17 feature while most compilers default to C++14 (and doesn&rsquo;t work in the following example)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#999;font-weight:bold">#include</span> <span style="color:#999;font-weight:bold">&lt;utility&gt;</span><span style="color:#999;font-weight:bold">  </span><span style="color:#998;font-style:italic">// for std::pair
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="font-weight:bold">::</span>pair point{<span style="color:#099">1</span>, <span style="color:#099">2</span>};  <span style="color:#998;font-style:italic">// CTAD to deduce std::pair&lt;int, int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="c-updates">C++ Updates</h1>
<h2 id="introduction-to-c11">Introduction to C++11</h2>
<p>On August 12, 2011, the International Organization for Standardization (ISO) approved a new version of C++, namely C++11. Bjarne Stroustrup characterized the goals of C++11 as:</p>
<ul>
<li>Build on C++&rsquo;s strengths &ndash; rather than trying to extend C++ to new areas where it may be weaker (eg. Windows applications with heavy GUI), focus on making it do what it does well even better.</li>
<li>Make C++ easier to learn, use, and teach &ndash; provide functionality that makes the language more consistent and easier to use.</li>
</ul>
<p>C++11 isn&rsquo;t a large departure from C++03 thematically, but it did add a huge amount of new functionality:</p>
<ul>
<li><code>auto</code></li>
<li><code>char16_t</code>and <code>char32_t</code></li>
<li><code>constexpr</code></li>
<li><code>decltype</code></li>
<li><code>default</code> specifier</li>
<li>delegating constructors</li>
<li><code>delete</code> specifier</li>
<li><code>enum</code> classes</li>
<li><code>extern</code> templates</li>
<li><code>lambda</code> expressions</li>
<li><code>long long int</code></li>
<li><code>move</code></li>
<li><code>noexcept</code> specifier</li>
<li><code>nullptr</code></li>
<li><code>override</code> and <code>final</code> specifiers</li>
<li>range-based for statements</li>
<li>r-value references</li>
<li><code>static_assert</code></li>
<li><code>std::initializer_list</code></li>
<li>trailing return type syntax</li>
<li>type alias</li>
<li><code>typedef</code> for template classes</li>
<li>uniform initialization</li>
<li>user-defined literals</li>
<li>variadic templates</li>
<li>two <code>&gt;&gt;</code> symbols without a space between them will now properly be interpreted as closing a template object</li>
</ul>
<p>There are also many new classes in the STL:</p>
<ul>
<li>Better support for multi-threading and thread-local storage</li>
<li>Hash tables</li>
<li>Random number generation improvements</li>
<li>Reference wrappers</li>
<li>Regular expressions</li>
<li><code>std::auto_ptr</code> has now been depreciated</li>
<li><code>std::tuple</code></li>
<li><code>std::unique_ptr</code></li>
</ul>
<h2 id="introduction-to-c14">Introduction to C++14</h2>
<p>On August 18, 2014, the ISO approved a new version of C++, namely C++14. Compared with C++11, which added a huge amount of functionality, C++14 is a relatively minor update:</p>
<ul>
<li>aggregate member initialization</li>
<li>binary literals</li>
<li><code>[[deprecated]]</code> attribute</li>
<li>digit separators</li>
<li>function return type deduction</li>
<li>generic lambdas</li>
<li>relaxed <code>constexpr</code> functions</li>
<li>variable templates</li>
<li><code>std::make_unique</code></li>
</ul>
<h2 id="introduction-to-c17">Introduction to C++17</h2>
<p>In September 2017, the ISO approved C++17, which contains a fair amount of new content:</p>
<ul>
<li><code>__has_include</code> preprocessor identifier to check if optional header files are available</li>
<li>if statements that resolve at compile time</li>
<li>initializers in if statements and switch statements</li>
<li>inline variables</li>
<li>fold expressions</li>
<li>mandatory copy elision for some cases</li>
<li>nested namespace can now be defined as namespace <code>X::Y</code></li>
<li>removal of <code>std::auto_ptr</code> and some other deprecated types</li>
<li><code>static_assert</code> no longer requires a diagnostic text message parameter</li>
<li><code>std::any</code></li>
<li><code>std::byte</code></li>
<li><code>std::filesystem</code></li>
<li><code>std::optional</code></li>
<li><code>std::shared_ptr</code> can now manage C-syyle arrays (but <code>std::make_shared</code> cannot create them yet)</li>
<li><code>std::size</code></li>
<li><code>std::string_view</code></li>
<li>structured binding declarations</li>
<li>template deduction for constructors</li>
<li>trigraphs have been removed</li>
<li>typename can now be used (instead of class) in a template template parameter</li>
<li>UTF-8 (u8) character literals</li>
</ul>
<h2 id="introduction-to-c20">Introduction to C++20</h2>
<p>In February 2020, the ISO approved C++20, which contains the most changes since C++11:</p>
<ul>
<li>abbreviated function templates via <code>auto</code> parameters</li>
<li>chrono extensions for calendar and time zone support</li>
<li>concepts, which allow you to put constraints on template parameters</li>
<li><code>constexpr</code> virtual functions, <code>unions</code>, <code>try</code>, <code>catch</code>, <code>dynamic_cast</code> and <code>typeid</code></li>
<li><code>constinit</code> keyword, to assert that a variable has static initialization</li>
<li>coroutines</li>
<li>designated initializers</li>
<li>immediate functions using the <code>consteval</code> keyword</li>
<li>modules, a replacement for <code>#include</code></li>
<li>ranges</li>
<li><code>std::erase</code></li>
<li><code>std::make_shared</code> for arrays</li>
<li><code>std::map::contains()</code></li>
<li><code>std::span</code></li>
<li>string formatting library</li>
<li>string literals as template parameters</li>
<li>three-way comparison using the spaceship operator <code>&lt;=&gt;</code></li>
<li>using scoped enums</li>
<li>views</li>
</ul>
<h2 id="introduction-to-c23">Introduction to C++23</h2>
<p>In February 2023, the ISO approved C++23, which includes:</p>
<ul>
<li><code>constexpr</code> version <code>&lt;cmath&gt;</code> (e.g. <code>std::abs()</code>) and <code>&lt;cstdlib&gt;</code></li>
<li><code>constexpr</code> version <code>std::bitset</code> and <code>std::unique_ptr</code></li>
<li>explicit <code>this</code> parameter</li>
<li>formatted printing functions <code>std::print</code> and <code>std::println</code></li>
<li>literal suffixes for <code>std::size_t</code> and the corresponding signed type</li>
<li>multidimensional subscript <code>operator[]</code></li>
<li>multidimensional span <code>std::mdspan</code></li>
<li>preprocessor directives <code>#elifdef</code> and <code>#elifndef</code></li>
<li>preprocessor directive <code>#warning</code></li>
<li>stacktrace library</li>
<li>standard library modules <code>std</code> and <code>std.compat</code></li>
<li>static <code>operator()</code> and <code>operator[]</code></li>
<li><code>std::expected</code></li>
<li><code>std::ranges</code> algorithms <code>starts_with</code>, <code>ends_with</code> and <code>contains</code></li>
<li><code>std::string::contains</code> and <code>std::string_view::contains</code></li>
<li><code>std::to_underlying</code> to get the underlying type of enum</li>
<li><code>std::unreachable()</code></li>
<li>using known pointers and references in constant expressions</li>
</ul>
<h1 id="the-end">The End</h1>
<p>Here are some directions you may want to explore next:</p>
<ul>
<li>data structures</li>
<li>algorithms</li>
<li>design patterns</li>
<li>the C++ STL</li>
<li>graphical applications</li>
<li>TCP/IP network programming</li>
<li>multithreading</li>
<li>the CPP Core Guidelines: <a href="https://github.com/isocpp/CppCoreGuidelines">repo</a> and <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">website</a></li>
<li>online contests e.g. <a href="https://www.codewars.com">codewars</a></li>
</ul>


<script>
  var unfocusableElems = document.querySelectorAll('pre');
  unfocusableElems.forEach(function (el) { el.setAttribute("tabindex", "-1"); });
  var unfocusableElems = document.querySelectorAll('iframe');
  unfocusableElems.forEach(function (el) { el.setAttribute("tabindex", "-1"); });
</script>

<footer>
  
<br><br>
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/blog/jenkov-notes/">Notes on Java Basics</a></span>
  <span class="nav-next"><a href="/blog/obsession/">我执</a> &rarr;</span>
</nav>

<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/blog\/jenkov-notes\/';
    
  } else if (e.which == 39) {  
    
    url = '\/blog\/obsession\/';
    
  }
  if (url) window.location = url;
});
</script>



<script src="https://giscus.app/client.js" data-repo="allenfrostline/allenfrostline.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnk3NzEzOTkxNg==" data-category="General" data-category-id="DIC_kwDOBJkPzM4CbgIQ"
        data-mapping="pathname" data-strict="0" data-reactions-enabled="0" data-emit-metadata="0"
        data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"
        async>
        </script>



<script async src="/js/alt-title.js"></script>

<script async src="/js/center-img.js"></script>

<script async src="/js/external-link.js"></script>

<script async src="/js/fix-footnote.js"></script>

<script async src="/js/header-link.js"></script>

<script async src="/js/load-typekit.js"></script>

<script async src="/js/math-code.js"></script>

<script async src="/js/mermaid.min.js"></script>

<script async src="/js/right-quote.js"></script>


<script src="/js/math-code.js"></script>

  
  
  
  
</footer>
</article>
</body>

</html>
